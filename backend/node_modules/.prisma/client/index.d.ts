
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Empresa
 * 
 */
export type Empresa = $Result.DefaultSelection<Prisma.$EmpresaPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Conselho
 * 
 */
export type Conselho = $Result.DefaultSelection<Prisma.$ConselhoPayload>
/**
 * Model Profissional
 * 
 */
export type Profissional = $Result.DefaultSelection<Prisma.$ProfissionalPayload>
/**
 * Model Cliente
 * 
 */
export type Cliente = $Result.DefaultSelection<Prisma.$ClientePayload>
/**
 * Model Especie
 * 
 */
export type Especie = $Result.DefaultSelection<Prisma.$EspeciePayload>
/**
 * Model Animal
 * 
 */
export type Animal = $Result.DefaultSelection<Prisma.$AnimalPayload>
/**
 * Model Exame
 * 
 */
export type Exame = $Result.DefaultSelection<Prisma.$ExamePayload>
/**
 * Model ParametroExame
 * 
 */
export type ParametroExame = $Result.DefaultSelection<Prisma.$ParametroExamePayload>
/**
 * Model Pedido
 * 
 */
export type Pedido = $Result.DefaultSelection<Prisma.$PedidoPayload>
/**
 * Model PedidoExame
 * 
 */
export type PedidoExame = $Result.DefaultSelection<Prisma.$PedidoExamePayload>
/**
 * Model ResultadoExame
 * 
 */
export type ResultadoExame = $Result.DefaultSelection<Prisma.$ResultadoExamePayload>
/**
 * Model Laudo
 * 
 */
export type Laudo = $Result.DefaultSelection<Prisma.$LaudoPayload>
/**
 * Model Banco
 * 
 */
export type Banco = $Result.DefaultSelection<Prisma.$BancoPayload>
/**
 * Model Conta
 * 
 */
export type Conta = $Result.DefaultSelection<Prisma.$ContaPayload>
/**
 * Model LogSistema
 * 
 */
export type LogSistema = $Result.DefaultSelection<Prisma.$LogSistemaPayload>
/**
 * Model ConfiguracaoSistema
 * 
 */
export type ConfiguracaoSistema = $Result.DefaultSelection<Prisma.$ConfiguracaoSistemaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PerfilUsuario: {
  ADMIN: 'ADMIN',
  GERENTE: 'GERENTE',
  VETERINARIO: 'VETERINARIO',
  TECNICO: 'TECNICO',
  OPERADOR: 'OPERADOR'
};

export type PerfilUsuario = (typeof PerfilUsuario)[keyof typeof PerfilUsuario]


export const TipoProfissional: {
  SOLICITANTE: 'SOLICITANTE',
  INTERNO: 'INTERNO',
  AMBOS: 'AMBOS'
};

export type TipoProfissional = (typeof TipoProfissional)[keyof typeof TipoProfissional]


export const SexoAnimal: {
  MACHO: 'MACHO',
  FEMEA: 'FEMEA',
  INDEFINIDO: 'INDEFINIDO'
};

export type SexoAnimal = (typeof SexoAnimal)[keyof typeof SexoAnimal]


export const StatusPedido: {
  PENDENTE: 'PENDENTE',
  COLETADO: 'COLETADO',
  EM_ANALISE: 'EM_ANALISE',
  LIBERADO: 'LIBERADO',
  ENTREGUE: 'ENTREGUE',
  CANCELADO: 'CANCELADO'
};

export type StatusPedido = (typeof StatusPedido)[keyof typeof StatusPedido]


export const StatusExame: {
  PENDENTE: 'PENDENTE',
  EM_ANALISE: 'EM_ANALISE',
  LIBERADO: 'LIBERADO',
  CANCELADO: 'CANCELADO'
};

export type StatusExame = (typeof StatusExame)[keyof typeof StatusExame]


export const TipoConta: {
  RECEBER: 'RECEBER',
  PAGAR: 'PAGAR'
};

export type TipoConta = (typeof TipoConta)[keyof typeof TipoConta]


export const StatusConta: {
  PENDENTE: 'PENDENTE',
  PAGO: 'PAGO',
  VENCIDO: 'VENCIDO',
  CANCELADO: 'CANCELADO'
};

export type StatusConta = (typeof StatusConta)[keyof typeof StatusConta]


export const TipoConfiguracao: {
  STRING: 'STRING',
  NUMBER: 'NUMBER',
  BOOLEAN: 'BOOLEAN',
  JSON: 'JSON'
};

export type TipoConfiguracao = (typeof TipoConfiguracao)[keyof typeof TipoConfiguracao]

}

export type PerfilUsuario = $Enums.PerfilUsuario

export const PerfilUsuario: typeof $Enums.PerfilUsuario

export type TipoProfissional = $Enums.TipoProfissional

export const TipoProfissional: typeof $Enums.TipoProfissional

export type SexoAnimal = $Enums.SexoAnimal

export const SexoAnimal: typeof $Enums.SexoAnimal

export type StatusPedido = $Enums.StatusPedido

export const StatusPedido: typeof $Enums.StatusPedido

export type StatusExame = $Enums.StatusExame

export const StatusExame: typeof $Enums.StatusExame

export type TipoConta = $Enums.TipoConta

export const TipoConta: typeof $Enums.TipoConta

export type StatusConta = $Enums.StatusConta

export const StatusConta: typeof $Enums.StatusConta

export type TipoConfiguracao = $Enums.TipoConfiguracao

export const TipoConfiguracao: typeof $Enums.TipoConfiguracao

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Empresas
 * const empresas = await prisma.empresa.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Empresas
   * const empresas = await prisma.empresa.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.empresa`: Exposes CRUD operations for the **Empresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empresas
    * const empresas = await prisma.empresa.findMany()
    * ```
    */
  get empresa(): Prisma.EmpresaDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.conselho`: Exposes CRUD operations for the **Conselho** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conselhos
    * const conselhos = await prisma.conselho.findMany()
    * ```
    */
  get conselho(): Prisma.ConselhoDelegate<ExtArgs>;

  /**
   * `prisma.profissional`: Exposes CRUD operations for the **Profissional** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profissionals
    * const profissionals = await prisma.profissional.findMany()
    * ```
    */
  get profissional(): Prisma.ProfissionalDelegate<ExtArgs>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<ExtArgs>;

  /**
   * `prisma.especie`: Exposes CRUD operations for the **Especie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Especies
    * const especies = await prisma.especie.findMany()
    * ```
    */
  get especie(): Prisma.EspecieDelegate<ExtArgs>;

  /**
   * `prisma.animal`: Exposes CRUD operations for the **Animal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Animals
    * const animals = await prisma.animal.findMany()
    * ```
    */
  get animal(): Prisma.AnimalDelegate<ExtArgs>;

  /**
   * `prisma.exame`: Exposes CRUD operations for the **Exame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exames
    * const exames = await prisma.exame.findMany()
    * ```
    */
  get exame(): Prisma.ExameDelegate<ExtArgs>;

  /**
   * `prisma.parametroExame`: Exposes CRUD operations for the **ParametroExame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParametroExames
    * const parametroExames = await prisma.parametroExame.findMany()
    * ```
    */
  get parametroExame(): Prisma.ParametroExameDelegate<ExtArgs>;

  /**
   * `prisma.pedido`: Exposes CRUD operations for the **Pedido** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pedidos
    * const pedidos = await prisma.pedido.findMany()
    * ```
    */
  get pedido(): Prisma.PedidoDelegate<ExtArgs>;

  /**
   * `prisma.pedidoExame`: Exposes CRUD operations for the **PedidoExame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PedidoExames
    * const pedidoExames = await prisma.pedidoExame.findMany()
    * ```
    */
  get pedidoExame(): Prisma.PedidoExameDelegate<ExtArgs>;

  /**
   * `prisma.resultadoExame`: Exposes CRUD operations for the **ResultadoExame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResultadoExames
    * const resultadoExames = await prisma.resultadoExame.findMany()
    * ```
    */
  get resultadoExame(): Prisma.ResultadoExameDelegate<ExtArgs>;

  /**
   * `prisma.laudo`: Exposes CRUD operations for the **Laudo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Laudos
    * const laudos = await prisma.laudo.findMany()
    * ```
    */
  get laudo(): Prisma.LaudoDelegate<ExtArgs>;

  /**
   * `prisma.banco`: Exposes CRUD operations for the **Banco** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bancos
    * const bancos = await prisma.banco.findMany()
    * ```
    */
  get banco(): Prisma.BancoDelegate<ExtArgs>;

  /**
   * `prisma.conta`: Exposes CRUD operations for the **Conta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contas
    * const contas = await prisma.conta.findMany()
    * ```
    */
  get conta(): Prisma.ContaDelegate<ExtArgs>;

  /**
   * `prisma.logSistema`: Exposes CRUD operations for the **LogSistema** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogSistemas
    * const logSistemas = await prisma.logSistema.findMany()
    * ```
    */
  get logSistema(): Prisma.LogSistemaDelegate<ExtArgs>;

  /**
   * `prisma.configuracaoSistema`: Exposes CRUD operations for the **ConfiguracaoSistema** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfiguracaoSistemas
    * const configuracaoSistemas = await prisma.configuracaoSistema.findMany()
    * ```
    */
  get configuracaoSistema(): Prisma.ConfiguracaoSistemaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Empresa: 'Empresa',
    Usuario: 'Usuario',
    Conselho: 'Conselho',
    Profissional: 'Profissional',
    Cliente: 'Cliente',
    Especie: 'Especie',
    Animal: 'Animal',
    Exame: 'Exame',
    ParametroExame: 'ParametroExame',
    Pedido: 'Pedido',
    PedidoExame: 'PedidoExame',
    ResultadoExame: 'ResultadoExame',
    Laudo: 'Laudo',
    Banco: 'Banco',
    Conta: 'Conta',
    LogSistema: 'LogSistema',
    ConfiguracaoSistema: 'ConfiguracaoSistema'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "empresa" | "usuario" | "conselho" | "profissional" | "cliente" | "especie" | "animal" | "exame" | "parametroExame" | "pedido" | "pedidoExame" | "resultadoExame" | "laudo" | "banco" | "conta" | "logSistema" | "configuracaoSistema"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Empresa: {
        payload: Prisma.$EmpresaPayload<ExtArgs>
        fields: Prisma.EmpresaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpresaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpresaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findFirst: {
            args: Prisma.EmpresaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpresaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          findMany: {
            args: Prisma.EmpresaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          create: {
            args: Prisma.EmpresaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          createMany: {
            args: Prisma.EmpresaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmpresaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>[]
          }
          delete: {
            args: Prisma.EmpresaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          update: {
            args: Prisma.EmpresaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          deleteMany: {
            args: Prisma.EmpresaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpresaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpresaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpresaPayload>
          }
          aggregate: {
            args: Prisma.EmpresaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpresa>
          }
          groupBy: {
            args: Prisma.EmpresaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpresaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpresaCountArgs<ExtArgs>
            result: $Utils.Optional<EmpresaCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Conselho: {
        payload: Prisma.$ConselhoPayload<ExtArgs>
        fields: Prisma.ConselhoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConselhoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConselhoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConselhoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConselhoPayload>
          }
          findFirst: {
            args: Prisma.ConselhoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConselhoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConselhoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConselhoPayload>
          }
          findMany: {
            args: Prisma.ConselhoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConselhoPayload>[]
          }
          create: {
            args: Prisma.ConselhoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConselhoPayload>
          }
          createMany: {
            args: Prisma.ConselhoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConselhoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConselhoPayload>[]
          }
          delete: {
            args: Prisma.ConselhoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConselhoPayload>
          }
          update: {
            args: Prisma.ConselhoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConselhoPayload>
          }
          deleteMany: {
            args: Prisma.ConselhoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConselhoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConselhoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConselhoPayload>
          }
          aggregate: {
            args: Prisma.ConselhoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConselho>
          }
          groupBy: {
            args: Prisma.ConselhoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConselhoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConselhoCountArgs<ExtArgs>
            result: $Utils.Optional<ConselhoCountAggregateOutputType> | number
          }
        }
      }
      Profissional: {
        payload: Prisma.$ProfissionalPayload<ExtArgs>
        fields: Prisma.ProfissionalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfissionalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfissionalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>
          }
          findFirst: {
            args: Prisma.ProfissionalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfissionalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>
          }
          findMany: {
            args: Prisma.ProfissionalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>[]
          }
          create: {
            args: Prisma.ProfissionalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>
          }
          createMany: {
            args: Prisma.ProfissionalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfissionalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>[]
          }
          delete: {
            args: Prisma.ProfissionalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>
          }
          update: {
            args: Prisma.ProfissionalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>
          }
          deleteMany: {
            args: Prisma.ProfissionalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfissionalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfissionalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfissionalPayload>
          }
          aggregate: {
            args: Prisma.ProfissionalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfissional>
          }
          groupBy: {
            args: Prisma.ProfissionalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfissionalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfissionalCountArgs<ExtArgs>
            result: $Utils.Optional<ProfissionalCountAggregateOutputType> | number
          }
        }
      }
      Cliente: {
        payload: Prisma.$ClientePayload<ExtArgs>
        fields: Prisma.ClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findFirst: {
            args: Prisma.ClienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findMany: {
            args: Prisma.ClienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          create: {
            args: Prisma.ClienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          createMany: {
            args: Prisma.ClienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          delete: {
            args: Prisma.ClienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          update: {
            args: Prisma.ClienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          deleteMany: {
            args: Prisma.ClienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.ClienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      Especie: {
        payload: Prisma.$EspeciePayload<ExtArgs>
        fields: Prisma.EspecieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EspecieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspeciePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EspecieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspeciePayload>
          }
          findFirst: {
            args: Prisma.EspecieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspeciePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EspecieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspeciePayload>
          }
          findMany: {
            args: Prisma.EspecieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspeciePayload>[]
          }
          create: {
            args: Prisma.EspecieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspeciePayload>
          }
          createMany: {
            args: Prisma.EspecieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EspecieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspeciePayload>[]
          }
          delete: {
            args: Prisma.EspecieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspeciePayload>
          }
          update: {
            args: Prisma.EspecieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspeciePayload>
          }
          deleteMany: {
            args: Prisma.EspecieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EspecieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EspecieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EspeciePayload>
          }
          aggregate: {
            args: Prisma.EspecieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEspecie>
          }
          groupBy: {
            args: Prisma.EspecieGroupByArgs<ExtArgs>
            result: $Utils.Optional<EspecieGroupByOutputType>[]
          }
          count: {
            args: Prisma.EspecieCountArgs<ExtArgs>
            result: $Utils.Optional<EspecieCountAggregateOutputType> | number
          }
        }
      }
      Animal: {
        payload: Prisma.$AnimalPayload<ExtArgs>
        fields: Prisma.AnimalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnimalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnimalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>
          }
          findFirst: {
            args: Prisma.AnimalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnimalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>
          }
          findMany: {
            args: Prisma.AnimalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>[]
          }
          create: {
            args: Prisma.AnimalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>
          }
          createMany: {
            args: Prisma.AnimalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnimalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>[]
          }
          delete: {
            args: Prisma.AnimalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>
          }
          update: {
            args: Prisma.AnimalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>
          }
          deleteMany: {
            args: Prisma.AnimalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnimalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnimalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>
          }
          aggregate: {
            args: Prisma.AnimalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnimal>
          }
          groupBy: {
            args: Prisma.AnimalGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnimalGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnimalCountArgs<ExtArgs>
            result: $Utils.Optional<AnimalCountAggregateOutputType> | number
          }
        }
      }
      Exame: {
        payload: Prisma.$ExamePayload<ExtArgs>
        fields: Prisma.ExameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamePayload>
          }
          findFirst: {
            args: Prisma.ExameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamePayload>
          }
          findMany: {
            args: Prisma.ExameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamePayload>[]
          }
          create: {
            args: Prisma.ExameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamePayload>
          }
          createMany: {
            args: Prisma.ExameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamePayload>[]
          }
          delete: {
            args: Prisma.ExameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamePayload>
          }
          update: {
            args: Prisma.ExameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamePayload>
          }
          deleteMany: {
            args: Prisma.ExameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamePayload>
          }
          aggregate: {
            args: Prisma.ExameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExame>
          }
          groupBy: {
            args: Prisma.ExameGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExameGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExameCountArgs<ExtArgs>
            result: $Utils.Optional<ExameCountAggregateOutputType> | number
          }
        }
      }
      ParametroExame: {
        payload: Prisma.$ParametroExamePayload<ExtArgs>
        fields: Prisma.ParametroExameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParametroExameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroExamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParametroExameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroExamePayload>
          }
          findFirst: {
            args: Prisma.ParametroExameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroExamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParametroExameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroExamePayload>
          }
          findMany: {
            args: Prisma.ParametroExameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroExamePayload>[]
          }
          create: {
            args: Prisma.ParametroExameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroExamePayload>
          }
          createMany: {
            args: Prisma.ParametroExameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParametroExameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroExamePayload>[]
          }
          delete: {
            args: Prisma.ParametroExameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroExamePayload>
          }
          update: {
            args: Prisma.ParametroExameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroExamePayload>
          }
          deleteMany: {
            args: Prisma.ParametroExameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParametroExameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParametroExameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParametroExamePayload>
          }
          aggregate: {
            args: Prisma.ParametroExameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParametroExame>
          }
          groupBy: {
            args: Prisma.ParametroExameGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParametroExameGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParametroExameCountArgs<ExtArgs>
            result: $Utils.Optional<ParametroExameCountAggregateOutputType> | number
          }
        }
      }
      Pedido: {
        payload: Prisma.$PedidoPayload<ExtArgs>
        fields: Prisma.PedidoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findFirst: {
            args: Prisma.PedidoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          findMany: {
            args: Prisma.PedidoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>[]
          }
          create: {
            args: Prisma.PedidoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          createMany: {
            args: Prisma.PedidoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PedidoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>[]
          }
          delete: {
            args: Prisma.PedidoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          update: {
            args: Prisma.PedidoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          deleteMany: {
            args: Prisma.PedidoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PedidoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoPayload>
          }
          aggregate: {
            args: Prisma.PedidoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePedido>
          }
          groupBy: {
            args: Prisma.PedidoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PedidoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoCountArgs<ExtArgs>
            result: $Utils.Optional<PedidoCountAggregateOutputType> | number
          }
        }
      }
      PedidoExame: {
        payload: Prisma.$PedidoExamePayload<ExtArgs>
        fields: Prisma.PedidoExameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoExameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoExamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoExameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoExamePayload>
          }
          findFirst: {
            args: Prisma.PedidoExameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoExamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoExameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoExamePayload>
          }
          findMany: {
            args: Prisma.PedidoExameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoExamePayload>[]
          }
          create: {
            args: Prisma.PedidoExameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoExamePayload>
          }
          createMany: {
            args: Prisma.PedidoExameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PedidoExameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoExamePayload>[]
          }
          delete: {
            args: Prisma.PedidoExameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoExamePayload>
          }
          update: {
            args: Prisma.PedidoExameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoExamePayload>
          }
          deleteMany: {
            args: Prisma.PedidoExameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoExameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PedidoExameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoExamePayload>
          }
          aggregate: {
            args: Prisma.PedidoExameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePedidoExame>
          }
          groupBy: {
            args: Prisma.PedidoExameGroupByArgs<ExtArgs>
            result: $Utils.Optional<PedidoExameGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoExameCountArgs<ExtArgs>
            result: $Utils.Optional<PedidoExameCountAggregateOutputType> | number
          }
        }
      }
      ResultadoExame: {
        payload: Prisma.$ResultadoExamePayload<ExtArgs>
        fields: Prisma.ResultadoExameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResultadoExameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultadoExamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResultadoExameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultadoExamePayload>
          }
          findFirst: {
            args: Prisma.ResultadoExameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultadoExamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResultadoExameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultadoExamePayload>
          }
          findMany: {
            args: Prisma.ResultadoExameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultadoExamePayload>[]
          }
          create: {
            args: Prisma.ResultadoExameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultadoExamePayload>
          }
          createMany: {
            args: Prisma.ResultadoExameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResultadoExameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultadoExamePayload>[]
          }
          delete: {
            args: Prisma.ResultadoExameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultadoExamePayload>
          }
          update: {
            args: Prisma.ResultadoExameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultadoExamePayload>
          }
          deleteMany: {
            args: Prisma.ResultadoExameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResultadoExameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResultadoExameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultadoExamePayload>
          }
          aggregate: {
            args: Prisma.ResultadoExameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResultadoExame>
          }
          groupBy: {
            args: Prisma.ResultadoExameGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResultadoExameGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResultadoExameCountArgs<ExtArgs>
            result: $Utils.Optional<ResultadoExameCountAggregateOutputType> | number
          }
        }
      }
      Laudo: {
        payload: Prisma.$LaudoPayload<ExtArgs>
        fields: Prisma.LaudoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaudoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaudoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaudoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaudoPayload>
          }
          findFirst: {
            args: Prisma.LaudoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaudoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaudoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaudoPayload>
          }
          findMany: {
            args: Prisma.LaudoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaudoPayload>[]
          }
          create: {
            args: Prisma.LaudoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaudoPayload>
          }
          createMany: {
            args: Prisma.LaudoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LaudoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaudoPayload>[]
          }
          delete: {
            args: Prisma.LaudoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaudoPayload>
          }
          update: {
            args: Prisma.LaudoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaudoPayload>
          }
          deleteMany: {
            args: Prisma.LaudoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaudoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LaudoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaudoPayload>
          }
          aggregate: {
            args: Prisma.LaudoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaudo>
          }
          groupBy: {
            args: Prisma.LaudoGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaudoGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaudoCountArgs<ExtArgs>
            result: $Utils.Optional<LaudoCountAggregateOutputType> | number
          }
        }
      }
      Banco: {
        payload: Prisma.$BancoPayload<ExtArgs>
        fields: Prisma.BancoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BancoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BancoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BancoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BancoPayload>
          }
          findFirst: {
            args: Prisma.BancoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BancoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BancoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BancoPayload>
          }
          findMany: {
            args: Prisma.BancoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BancoPayload>[]
          }
          create: {
            args: Prisma.BancoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BancoPayload>
          }
          createMany: {
            args: Prisma.BancoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BancoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BancoPayload>[]
          }
          delete: {
            args: Prisma.BancoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BancoPayload>
          }
          update: {
            args: Prisma.BancoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BancoPayload>
          }
          deleteMany: {
            args: Prisma.BancoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BancoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BancoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BancoPayload>
          }
          aggregate: {
            args: Prisma.BancoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanco>
          }
          groupBy: {
            args: Prisma.BancoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BancoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BancoCountArgs<ExtArgs>
            result: $Utils.Optional<BancoCountAggregateOutputType> | number
          }
        }
      }
      Conta: {
        payload: Prisma.$ContaPayload<ExtArgs>
        fields: Prisma.ContaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>
          }
          findFirst: {
            args: Prisma.ContaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>
          }
          findMany: {
            args: Prisma.ContaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>[]
          }
          create: {
            args: Prisma.ContaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>
          }
          createMany: {
            args: Prisma.ContaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>[]
          }
          delete: {
            args: Prisma.ContaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>
          }
          update: {
            args: Prisma.ContaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>
          }
          deleteMany: {
            args: Prisma.ContaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContaPayload>
          }
          aggregate: {
            args: Prisma.ContaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConta>
          }
          groupBy: {
            args: Prisma.ContaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContaCountArgs<ExtArgs>
            result: $Utils.Optional<ContaCountAggregateOutputType> | number
          }
        }
      }
      LogSistema: {
        payload: Prisma.$LogSistemaPayload<ExtArgs>
        fields: Prisma.LogSistemaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogSistemaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSistemaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogSistemaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSistemaPayload>
          }
          findFirst: {
            args: Prisma.LogSistemaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSistemaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogSistemaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSistemaPayload>
          }
          findMany: {
            args: Prisma.LogSistemaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSistemaPayload>[]
          }
          create: {
            args: Prisma.LogSistemaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSistemaPayload>
          }
          createMany: {
            args: Prisma.LogSistemaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogSistemaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSistemaPayload>[]
          }
          delete: {
            args: Prisma.LogSistemaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSistemaPayload>
          }
          update: {
            args: Prisma.LogSistemaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSistemaPayload>
          }
          deleteMany: {
            args: Prisma.LogSistemaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogSistemaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogSistemaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogSistemaPayload>
          }
          aggregate: {
            args: Prisma.LogSistemaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogSistema>
          }
          groupBy: {
            args: Prisma.LogSistemaGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogSistemaGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogSistemaCountArgs<ExtArgs>
            result: $Utils.Optional<LogSistemaCountAggregateOutputType> | number
          }
        }
      }
      ConfiguracaoSistema: {
        payload: Prisma.$ConfiguracaoSistemaPayload<ExtArgs>
        fields: Prisma.ConfiguracaoSistemaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfiguracaoSistemaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoSistemaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfiguracaoSistemaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoSistemaPayload>
          }
          findFirst: {
            args: Prisma.ConfiguracaoSistemaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoSistemaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfiguracaoSistemaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoSistemaPayload>
          }
          findMany: {
            args: Prisma.ConfiguracaoSistemaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoSistemaPayload>[]
          }
          create: {
            args: Prisma.ConfiguracaoSistemaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoSistemaPayload>
          }
          createMany: {
            args: Prisma.ConfiguracaoSistemaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfiguracaoSistemaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoSistemaPayload>[]
          }
          delete: {
            args: Prisma.ConfiguracaoSistemaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoSistemaPayload>
          }
          update: {
            args: Prisma.ConfiguracaoSistemaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoSistemaPayload>
          }
          deleteMany: {
            args: Prisma.ConfiguracaoSistemaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfiguracaoSistemaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfiguracaoSistemaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracaoSistemaPayload>
          }
          aggregate: {
            args: Prisma.ConfiguracaoSistemaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguracaoSistema>
          }
          groupBy: {
            args: Prisma.ConfiguracaoSistemaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracaoSistemaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfiguracaoSistemaCountArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracaoSistemaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    pedidosCriados: number
    laudosLiberados: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidosCriados?: boolean | UsuarioCountOutputTypeCountPedidosCriadosArgs
    laudosLiberados?: boolean | UsuarioCountOutputTypeCountLaudosLiberadosArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPedidosCriadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountLaudosLiberadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaudoWhereInput
  }


  /**
   * Count Type ConselhoCountOutputType
   */

  export type ConselhoCountOutputType = {
    profissionais: number
  }

  export type ConselhoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profissionais?: boolean | ConselhoCountOutputTypeCountProfissionaisArgs
  }

  // Custom InputTypes
  /**
   * ConselhoCountOutputType without action
   */
  export type ConselhoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConselhoCountOutputType
     */
    select?: ConselhoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConselhoCountOutputType without action
   */
  export type ConselhoCountOutputTypeCountProfissionaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfissionalWhereInput
  }


  /**
   * Count Type ProfissionalCountOutputType
   */

  export type ProfissionalCountOutputType = {
    pedidosSolicitados: number
    laudosAssinados: number
    clientesResponsavel: number
  }

  export type ProfissionalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidosSolicitados?: boolean | ProfissionalCountOutputTypeCountPedidosSolicitadosArgs
    laudosAssinados?: boolean | ProfissionalCountOutputTypeCountLaudosAssinadosArgs
    clientesResponsavel?: boolean | ProfissionalCountOutputTypeCountClientesResponsavelArgs
  }

  // Custom InputTypes
  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfissionalCountOutputType
     */
    select?: ProfissionalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeCountPedidosSolicitadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }

  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeCountLaudosAssinadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaudoWhereInput
  }

  /**
   * ProfissionalCountOutputType without action
   */
  export type ProfissionalCountOutputTypeCountClientesResponsavelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
  }


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    animais: number
    pedidos: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animais?: boolean | ClienteCountOutputTypeCountAnimaisArgs
    pedidos?: boolean | ClienteCountOutputTypeCountPedidosArgs
  }

  // Custom InputTypes
  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountAnimaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimalWhereInput
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountPedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }


  /**
   * Count Type EspecieCountOutputType
   */

  export type EspecieCountOutputType = {
    animais: number
  }

  export type EspecieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animais?: boolean | EspecieCountOutputTypeCountAnimaisArgs
  }

  // Custom InputTypes
  /**
   * EspecieCountOutputType without action
   */
  export type EspecieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecieCountOutputType
     */
    select?: EspecieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EspecieCountOutputType without action
   */
  export type EspecieCountOutputTypeCountAnimaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimalWhereInput
  }


  /**
   * Count Type AnimalCountOutputType
   */

  export type AnimalCountOutputType = {
    pedidos: number
  }

  export type AnimalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidos?: boolean | AnimalCountOutputTypeCountPedidosArgs
  }

  // Custom InputTypes
  /**
   * AnimalCountOutputType without action
   */
  export type AnimalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalCountOutputType
     */
    select?: AnimalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnimalCountOutputType without action
   */
  export type AnimalCountOutputTypeCountPedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
  }


  /**
   * Count Type ExameCountOutputType
   */

  export type ExameCountOutputType = {
    parametros: number
    pedidoExames: number
  }

  export type ExameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parametros?: boolean | ExameCountOutputTypeCountParametrosArgs
    pedidoExames?: boolean | ExameCountOutputTypeCountPedidoExamesArgs
  }

  // Custom InputTypes
  /**
   * ExameCountOutputType without action
   */
  export type ExameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExameCountOutputType
     */
    select?: ExameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExameCountOutputType without action
   */
  export type ExameCountOutputTypeCountParametrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParametroExameWhereInput
  }

  /**
   * ExameCountOutputType without action
   */
  export type ExameCountOutputTypeCountPedidoExamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoExameWhereInput
  }


  /**
   * Count Type ParametroExameCountOutputType
   */

  export type ParametroExameCountOutputType = {
    resultados: number
  }

  export type ParametroExameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resultados?: boolean | ParametroExameCountOutputTypeCountResultadosArgs
  }

  // Custom InputTypes
  /**
   * ParametroExameCountOutputType without action
   */
  export type ParametroExameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExameCountOutputType
     */
    select?: ParametroExameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParametroExameCountOutputType without action
   */
  export type ParametroExameCountOutputTypeCountResultadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultadoExameWhereInput
  }


  /**
   * Count Type PedidoCountOutputType
   */

  export type PedidoCountOutputType = {
    exames: number
    laudos: number
    contas: number
  }

  export type PedidoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exames?: boolean | PedidoCountOutputTypeCountExamesArgs
    laudos?: boolean | PedidoCountOutputTypeCountLaudosArgs
    contas?: boolean | PedidoCountOutputTypeCountContasArgs
  }

  // Custom InputTypes
  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoCountOutputType
     */
    select?: PedidoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountExamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoExameWhereInput
  }

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountLaudosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaudoWhereInput
  }

  /**
   * PedidoCountOutputType without action
   */
  export type PedidoCountOutputTypeCountContasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContaWhereInput
  }


  /**
   * Count Type PedidoExameCountOutputType
   */

  export type PedidoExameCountOutputType = {
    resultados: number
  }

  export type PedidoExameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resultados?: boolean | PedidoExameCountOutputTypeCountResultadosArgs
  }

  // Custom InputTypes
  /**
   * PedidoExameCountOutputType without action
   */
  export type PedidoExameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExameCountOutputType
     */
    select?: PedidoExameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PedidoExameCountOutputType without action
   */
  export type PedidoExameCountOutputTypeCountResultadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultadoExameWhereInput
  }


  /**
   * Count Type BancoCountOutputType
   */

  export type BancoCountOutputType = {
    contas: number
  }

  export type BancoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contas?: boolean | BancoCountOutputTypeCountContasArgs
  }

  // Custom InputTypes
  /**
   * BancoCountOutputType without action
   */
  export type BancoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BancoCountOutputType
     */
    select?: BancoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BancoCountOutputType without action
   */
  export type BancoCountOutputTypeCountContasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Empresa
   */

  export type AggregateEmpresa = {
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  export type EmpresaAvgAggregateOutputType = {
    id: number | null
  }

  export type EmpresaSumAggregateOutputType = {
    id: number | null
  }

  export type EmpresaMinAggregateOutputType = {
    id: number | null
    razaoSocial: string | null
    nomeFantasia: string | null
    cnpj: string | null
    inscricaoEstadual: string | null
    endereco: string | null
    cidade: string | null
    uf: string | null
    cep: string | null
    telefone: string | null
    email: string | null
    logo: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmpresaMaxAggregateOutputType = {
    id: number | null
    razaoSocial: string | null
    nomeFantasia: string | null
    cnpj: string | null
    inscricaoEstadual: string | null
    endereco: string | null
    cidade: string | null
    uf: string | null
    cep: string | null
    telefone: string | null
    email: string | null
    logo: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmpresaCountAggregateOutputType = {
    id: number
    razaoSocial: number
    nomeFantasia: number
    cnpj: number
    inscricaoEstadual: number
    endereco: number
    cidade: number
    uf: number
    cep: number
    telefone: number
    email: number
    logo: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmpresaAvgAggregateInputType = {
    id?: true
  }

  export type EmpresaSumAggregateInputType = {
    id?: true
  }

  export type EmpresaMinAggregateInputType = {
    id?: true
    razaoSocial?: true
    nomeFantasia?: true
    cnpj?: true
    inscricaoEstadual?: true
    endereco?: true
    cidade?: true
    uf?: true
    cep?: true
    telefone?: true
    email?: true
    logo?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmpresaMaxAggregateInputType = {
    id?: true
    razaoSocial?: true
    nomeFantasia?: true
    cnpj?: true
    inscricaoEstadual?: true
    endereco?: true
    cidade?: true
    uf?: true
    cep?: true
    telefone?: true
    email?: true
    logo?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmpresaCountAggregateInputType = {
    id?: true
    razaoSocial?: true
    nomeFantasia?: true
    cnpj?: true
    inscricaoEstadual?: true
    endereco?: true
    cidade?: true
    uf?: true
    cep?: true
    telefone?: true
    email?: true
    logo?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmpresaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresa to aggregate.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empresas
    **/
    _count?: true | EmpresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpresaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpresaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpresaMaxAggregateInputType
  }

  export type GetEmpresaAggregateType<T extends EmpresaAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpresa[P]>
      : GetScalarType<T[P], AggregateEmpresa[P]>
  }




  export type EmpresaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpresaWhereInput
    orderBy?: EmpresaOrderByWithAggregationInput | EmpresaOrderByWithAggregationInput[]
    by: EmpresaScalarFieldEnum[] | EmpresaScalarFieldEnum
    having?: EmpresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpresaCountAggregateInputType | true
    _avg?: EmpresaAvgAggregateInputType
    _sum?: EmpresaSumAggregateInputType
    _min?: EmpresaMinAggregateInputType
    _max?: EmpresaMaxAggregateInputType
  }

  export type EmpresaGroupByOutputType = {
    id: number
    razaoSocial: string
    nomeFantasia: string | null
    cnpj: string | null
    inscricaoEstadual: string | null
    endereco: string | null
    cidade: string | null
    uf: string | null
    cep: string | null
    telefone: string | null
    email: string | null
    logo: string | null
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmpresaCountAggregateOutputType | null
    _avg: EmpresaAvgAggregateOutputType | null
    _sum: EmpresaSumAggregateOutputType | null
    _min: EmpresaMinAggregateOutputType | null
    _max: EmpresaMaxAggregateOutputType | null
  }

  type GetEmpresaGroupByPayload<T extends EmpresaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpresaGroupByOutputType[P]>
        }
      >
    >


  export type EmpresaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    cnpj?: boolean
    inscricaoEstadual?: boolean
    endereco?: boolean
    cidade?: boolean
    uf?: boolean
    cep?: boolean
    telefone?: boolean
    email?: boolean
    logo?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["empresa"]>

  export type EmpresaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    cnpj?: boolean
    inscricaoEstadual?: boolean
    endereco?: boolean
    cidade?: boolean
    uf?: boolean
    cep?: boolean
    telefone?: boolean
    email?: boolean
    logo?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["empresa"]>

  export type EmpresaSelectScalar = {
    id?: boolean
    razaoSocial?: boolean
    nomeFantasia?: boolean
    cnpj?: boolean
    inscricaoEstadual?: boolean
    endereco?: boolean
    cidade?: boolean
    uf?: boolean
    cep?: boolean
    telefone?: boolean
    email?: boolean
    logo?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $EmpresaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Empresa"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      razaoSocial: string
      nomeFantasia: string | null
      cnpj: string | null
      inscricaoEstadual: string | null
      endereco: string | null
      cidade: string | null
      uf: string | null
      cep: string | null
      telefone: string | null
      email: string | null
      logo: string | null
      ativo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["empresa"]>
    composites: {}
  }

  type EmpresaGetPayload<S extends boolean | null | undefined | EmpresaDefaultArgs> = $Result.GetResult<Prisma.$EmpresaPayload, S>

  type EmpresaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpresaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpresaCountAggregateInputType | true
    }

  export interface EmpresaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Empresa'], meta: { name: 'Empresa' } }
    /**
     * Find zero or one Empresa that matches the filter.
     * @param {EmpresaFindUniqueArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpresaFindUniqueArgs>(args: SelectSubset<T, EmpresaFindUniqueArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Empresa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmpresaFindUniqueOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpresaFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpresaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpresaFindFirstArgs>(args?: SelectSubset<T, EmpresaFindFirstArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Empresa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindFirstOrThrowArgs} args - Arguments to find a Empresa
     * @example
     * // Get one Empresa
     * const empresa = await prisma.empresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpresaFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpresaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empresas
     * const empresas = await prisma.empresa.findMany()
     * 
     * // Get first 10 Empresas
     * const empresas = await prisma.empresa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empresaWithIdOnly = await prisma.empresa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmpresaFindManyArgs>(args?: SelectSubset<T, EmpresaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Empresa.
     * @param {EmpresaCreateArgs} args - Arguments to create a Empresa.
     * @example
     * // Create one Empresa
     * const Empresa = await prisma.empresa.create({
     *   data: {
     *     // ... data to create a Empresa
     *   }
     * })
     * 
     */
    create<T extends EmpresaCreateArgs>(args: SelectSubset<T, EmpresaCreateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Empresas.
     * @param {EmpresaCreateManyArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpresaCreateManyArgs>(args?: SelectSubset<T, EmpresaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Empresas and returns the data saved in the database.
     * @param {EmpresaCreateManyAndReturnArgs} args - Arguments to create many Empresas.
     * @example
     * // Create many Empresas
     * const empresa = await prisma.empresa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Empresas and only return the `id`
     * const empresaWithIdOnly = await prisma.empresa.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmpresaCreateManyAndReturnArgs>(args?: SelectSubset<T, EmpresaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Empresa.
     * @param {EmpresaDeleteArgs} args - Arguments to delete one Empresa.
     * @example
     * // Delete one Empresa
     * const Empresa = await prisma.empresa.delete({
     *   where: {
     *     // ... filter to delete one Empresa
     *   }
     * })
     * 
     */
    delete<T extends EmpresaDeleteArgs>(args: SelectSubset<T, EmpresaDeleteArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Empresa.
     * @param {EmpresaUpdateArgs} args - Arguments to update one Empresa.
     * @example
     * // Update one Empresa
     * const empresa = await prisma.empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpresaUpdateArgs>(args: SelectSubset<T, EmpresaUpdateArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Empresas.
     * @param {EmpresaDeleteManyArgs} args - Arguments to filter Empresas to delete.
     * @example
     * // Delete a few Empresas
     * const { count } = await prisma.empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpresaDeleteManyArgs>(args?: SelectSubset<T, EmpresaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empresas
     * const empresa = await prisma.empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpresaUpdateManyArgs>(args: SelectSubset<T, EmpresaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empresa.
     * @param {EmpresaUpsertArgs} args - Arguments to update or create a Empresa.
     * @example
     * // Update or create a Empresa
     * const empresa = await prisma.empresa.upsert({
     *   create: {
     *     // ... data to create a Empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empresa we want to update
     *   }
     * })
     */
    upsert<T extends EmpresaUpsertArgs>(args: SelectSubset<T, EmpresaUpsertArgs<ExtArgs>>): Prisma__EmpresaClient<$Result.GetResult<Prisma.$EmpresaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaCountArgs} args - Arguments to filter Empresas to count.
     * @example
     * // Count the number of Empresas
     * const count = await prisma.empresa.count({
     *   where: {
     *     // ... the filter for the Empresas we want to count
     *   }
     * })
    **/
    count<T extends EmpresaCountArgs>(
      args?: Subset<T, EmpresaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpresaAggregateArgs>(args: Subset<T, EmpresaAggregateArgs>): Prisma.PrismaPromise<GetEmpresaAggregateType<T>>

    /**
     * Group by Empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpresaGroupByArgs['orderBy'] }
        : { orderBy?: EmpresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpresaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Empresa model
   */
  readonly fields: EmpresaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpresaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Empresa model
   */ 
  interface EmpresaFieldRefs {
    readonly id: FieldRef<"Empresa", 'Int'>
    readonly razaoSocial: FieldRef<"Empresa", 'String'>
    readonly nomeFantasia: FieldRef<"Empresa", 'String'>
    readonly cnpj: FieldRef<"Empresa", 'String'>
    readonly inscricaoEstadual: FieldRef<"Empresa", 'String'>
    readonly endereco: FieldRef<"Empresa", 'String'>
    readonly cidade: FieldRef<"Empresa", 'String'>
    readonly uf: FieldRef<"Empresa", 'String'>
    readonly cep: FieldRef<"Empresa", 'String'>
    readonly telefone: FieldRef<"Empresa", 'String'>
    readonly email: FieldRef<"Empresa", 'String'>
    readonly logo: FieldRef<"Empresa", 'String'>
    readonly ativo: FieldRef<"Empresa", 'Boolean'>
    readonly createdAt: FieldRef<"Empresa", 'DateTime'>
    readonly updatedAt: FieldRef<"Empresa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Empresa findUnique
   */
  export type EmpresaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findUniqueOrThrow
   */
  export type EmpresaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa findFirst
   */
  export type EmpresaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findFirstOrThrow
   */
  export type EmpresaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Filter, which Empresa to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empresas.
     */
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa findMany
   */
  export type EmpresaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Filter, which Empresas to fetch.
     */
    where?: EmpresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empresas to fetch.
     */
    orderBy?: EmpresaOrderByWithRelationInput | EmpresaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empresas.
     */
    cursor?: EmpresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empresas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empresas.
     */
    skip?: number
    distinct?: EmpresaScalarFieldEnum | EmpresaScalarFieldEnum[]
  }

  /**
   * Empresa create
   */
  export type EmpresaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * The data needed to create a Empresa.
     */
    data: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
  }

  /**
   * Empresa createMany
   */
  export type EmpresaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Empresas.
     */
    data: EmpresaCreateManyInput | EmpresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empresa createManyAndReturn
   */
  export type EmpresaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Empresas.
     */
    data: EmpresaCreateManyInput | EmpresaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empresa update
   */
  export type EmpresaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * The data needed to update a Empresa.
     */
    data: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
    /**
     * Choose, which Empresa to update.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa updateMany
   */
  export type EmpresaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Empresas.
     */
    data: XOR<EmpresaUpdateManyMutationInput, EmpresaUncheckedUpdateManyInput>
    /**
     * Filter which Empresas to update
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa upsert
   */
  export type EmpresaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * The filter to search for the Empresa to update in case it exists.
     */
    where: EmpresaWhereUniqueInput
    /**
     * In case the Empresa found by the `where` argument doesn't exist, create a new Empresa with this data.
     */
    create: XOR<EmpresaCreateInput, EmpresaUncheckedCreateInput>
    /**
     * In case the Empresa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpresaUpdateInput, EmpresaUncheckedUpdateInput>
  }

  /**
   * Empresa delete
   */
  export type EmpresaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
    /**
     * Filter which Empresa to delete.
     */
    where: EmpresaWhereUniqueInput
  }

  /**
   * Empresa deleteMany
   */
  export type EmpresaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empresas to delete
     */
    where?: EmpresaWhereInput
  }

  /**
   * Empresa without action
   */
  export type EmpresaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empresa
     */
    select?: EmpresaSelect<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    senha: string | null
    perfil: $Enums.PerfilUsuario | null
    ativo: boolean | null
    ultimoLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    email: string | null
    senha: string | null
    perfil: $Enums.PerfilUsuario | null
    ativo: boolean | null
    ultimoLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    senha: number
    perfil: number
    ativo: number
    ultimoLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    perfil?: true
    ativo?: true
    ultimoLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    perfil?: true
    ativo?: true
    ultimoLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    perfil?: true
    ativo?: true
    ultimoLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nome: string
    email: string
    senha: string
    perfil: $Enums.PerfilUsuario
    ativo: boolean
    ultimoLogin: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    perfil?: boolean
    ativo?: boolean
    ultimoLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pedidosCriados?: boolean | Usuario$pedidosCriadosArgs<ExtArgs>
    laudosLiberados?: boolean | Usuario$laudosLiberadosArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    perfil?: boolean
    ativo?: boolean
    ultimoLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    perfil?: boolean
    ativo?: boolean
    ultimoLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidosCriados?: boolean | Usuario$pedidosCriadosArgs<ExtArgs>
    laudosLiberados?: boolean | Usuario$laudosLiberadosArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      pedidosCriados: Prisma.$PedidoPayload<ExtArgs>[]
      laudosLiberados: Prisma.$LaudoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      email: string
      senha: string
      perfil: $Enums.PerfilUsuario
      ativo: boolean
      ultimoLogin: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedidosCriados<T extends Usuario$pedidosCriadosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$pedidosCriadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findMany"> | Null>
    laudosLiberados<T extends Usuario$laudosLiberadosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$laudosLiberadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly nome: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly senha: FieldRef<"Usuario", 'String'>
    readonly perfil: FieldRef<"Usuario", 'PerfilUsuario'>
    readonly ativo: FieldRef<"Usuario", 'Boolean'>
    readonly ultimoLogin: FieldRef<"Usuario", 'DateTime'>
    readonly createdAt: FieldRef<"Usuario", 'DateTime'>
    readonly updatedAt: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.pedidosCriados
   */
  export type Usuario$pedidosCriadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Usuario.laudosLiberados
   */
  export type Usuario$laudosLiberadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
    where?: LaudoWhereInput
    orderBy?: LaudoOrderByWithRelationInput | LaudoOrderByWithRelationInput[]
    cursor?: LaudoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaudoScalarFieldEnum | LaudoScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Conselho
   */

  export type AggregateConselho = {
    _count: ConselhoCountAggregateOutputType | null
    _avg: ConselhoAvgAggregateOutputType | null
    _sum: ConselhoSumAggregateOutputType | null
    _min: ConselhoMinAggregateOutputType | null
    _max: ConselhoMaxAggregateOutputType | null
  }

  export type ConselhoAvgAggregateOutputType = {
    id: number | null
  }

  export type ConselhoSumAggregateOutputType = {
    id: number | null
  }

  export type ConselhoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    sigla: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConselhoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    sigla: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConselhoCountAggregateOutputType = {
    id: number
    nome: number
    sigla: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConselhoAvgAggregateInputType = {
    id?: true
  }

  export type ConselhoSumAggregateInputType = {
    id?: true
  }

  export type ConselhoMinAggregateInputType = {
    id?: true
    nome?: true
    sigla?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConselhoMaxAggregateInputType = {
    id?: true
    nome?: true
    sigla?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConselhoCountAggregateInputType = {
    id?: true
    nome?: true
    sigla?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConselhoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conselho to aggregate.
     */
    where?: ConselhoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conselhos to fetch.
     */
    orderBy?: ConselhoOrderByWithRelationInput | ConselhoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConselhoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conselhos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conselhos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conselhos
    **/
    _count?: true | ConselhoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConselhoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConselhoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConselhoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConselhoMaxAggregateInputType
  }

  export type GetConselhoAggregateType<T extends ConselhoAggregateArgs> = {
        [P in keyof T & keyof AggregateConselho]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConselho[P]>
      : GetScalarType<T[P], AggregateConselho[P]>
  }




  export type ConselhoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConselhoWhereInput
    orderBy?: ConselhoOrderByWithAggregationInput | ConselhoOrderByWithAggregationInput[]
    by: ConselhoScalarFieldEnum[] | ConselhoScalarFieldEnum
    having?: ConselhoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConselhoCountAggregateInputType | true
    _avg?: ConselhoAvgAggregateInputType
    _sum?: ConselhoSumAggregateInputType
    _min?: ConselhoMinAggregateInputType
    _max?: ConselhoMaxAggregateInputType
  }

  export type ConselhoGroupByOutputType = {
    id: number
    nome: string
    sigla: string
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    _count: ConselhoCountAggregateOutputType | null
    _avg: ConselhoAvgAggregateOutputType | null
    _sum: ConselhoSumAggregateOutputType | null
    _min: ConselhoMinAggregateOutputType | null
    _max: ConselhoMaxAggregateOutputType | null
  }

  type GetConselhoGroupByPayload<T extends ConselhoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConselhoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConselhoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConselhoGroupByOutputType[P]>
            : GetScalarType<T[P], ConselhoGroupByOutputType[P]>
        }
      >
    >


  export type ConselhoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    sigla?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profissionais?: boolean | Conselho$profissionaisArgs<ExtArgs>
    _count?: boolean | ConselhoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conselho"]>

  export type ConselhoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    sigla?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conselho"]>

  export type ConselhoSelectScalar = {
    id?: boolean
    nome?: boolean
    sigla?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConselhoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profissionais?: boolean | Conselho$profissionaisArgs<ExtArgs>
    _count?: boolean | ConselhoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConselhoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConselhoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conselho"
    objects: {
      profissionais: Prisma.$ProfissionalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      sigla: string
      ativo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conselho"]>
    composites: {}
  }

  type ConselhoGetPayload<S extends boolean | null | undefined | ConselhoDefaultArgs> = $Result.GetResult<Prisma.$ConselhoPayload, S>

  type ConselhoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConselhoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConselhoCountAggregateInputType | true
    }

  export interface ConselhoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conselho'], meta: { name: 'Conselho' } }
    /**
     * Find zero or one Conselho that matches the filter.
     * @param {ConselhoFindUniqueArgs} args - Arguments to find a Conselho
     * @example
     * // Get one Conselho
     * const conselho = await prisma.conselho.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConselhoFindUniqueArgs>(args: SelectSubset<T, ConselhoFindUniqueArgs<ExtArgs>>): Prisma__ConselhoClient<$Result.GetResult<Prisma.$ConselhoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conselho that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConselhoFindUniqueOrThrowArgs} args - Arguments to find a Conselho
     * @example
     * // Get one Conselho
     * const conselho = await prisma.conselho.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConselhoFindUniqueOrThrowArgs>(args: SelectSubset<T, ConselhoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConselhoClient<$Result.GetResult<Prisma.$ConselhoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conselho that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConselhoFindFirstArgs} args - Arguments to find a Conselho
     * @example
     * // Get one Conselho
     * const conselho = await prisma.conselho.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConselhoFindFirstArgs>(args?: SelectSubset<T, ConselhoFindFirstArgs<ExtArgs>>): Prisma__ConselhoClient<$Result.GetResult<Prisma.$ConselhoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conselho that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConselhoFindFirstOrThrowArgs} args - Arguments to find a Conselho
     * @example
     * // Get one Conselho
     * const conselho = await prisma.conselho.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConselhoFindFirstOrThrowArgs>(args?: SelectSubset<T, ConselhoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConselhoClient<$Result.GetResult<Prisma.$ConselhoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conselhos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConselhoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conselhos
     * const conselhos = await prisma.conselho.findMany()
     * 
     * // Get first 10 Conselhos
     * const conselhos = await prisma.conselho.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conselhoWithIdOnly = await prisma.conselho.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConselhoFindManyArgs>(args?: SelectSubset<T, ConselhoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConselhoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conselho.
     * @param {ConselhoCreateArgs} args - Arguments to create a Conselho.
     * @example
     * // Create one Conselho
     * const Conselho = await prisma.conselho.create({
     *   data: {
     *     // ... data to create a Conselho
     *   }
     * })
     * 
     */
    create<T extends ConselhoCreateArgs>(args: SelectSubset<T, ConselhoCreateArgs<ExtArgs>>): Prisma__ConselhoClient<$Result.GetResult<Prisma.$ConselhoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conselhos.
     * @param {ConselhoCreateManyArgs} args - Arguments to create many Conselhos.
     * @example
     * // Create many Conselhos
     * const conselho = await prisma.conselho.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConselhoCreateManyArgs>(args?: SelectSubset<T, ConselhoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conselhos and returns the data saved in the database.
     * @param {ConselhoCreateManyAndReturnArgs} args - Arguments to create many Conselhos.
     * @example
     * // Create many Conselhos
     * const conselho = await prisma.conselho.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conselhos and only return the `id`
     * const conselhoWithIdOnly = await prisma.conselho.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConselhoCreateManyAndReturnArgs>(args?: SelectSubset<T, ConselhoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConselhoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conselho.
     * @param {ConselhoDeleteArgs} args - Arguments to delete one Conselho.
     * @example
     * // Delete one Conselho
     * const Conselho = await prisma.conselho.delete({
     *   where: {
     *     // ... filter to delete one Conselho
     *   }
     * })
     * 
     */
    delete<T extends ConselhoDeleteArgs>(args: SelectSubset<T, ConselhoDeleteArgs<ExtArgs>>): Prisma__ConselhoClient<$Result.GetResult<Prisma.$ConselhoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conselho.
     * @param {ConselhoUpdateArgs} args - Arguments to update one Conselho.
     * @example
     * // Update one Conselho
     * const conselho = await prisma.conselho.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConselhoUpdateArgs>(args: SelectSubset<T, ConselhoUpdateArgs<ExtArgs>>): Prisma__ConselhoClient<$Result.GetResult<Prisma.$ConselhoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conselhos.
     * @param {ConselhoDeleteManyArgs} args - Arguments to filter Conselhos to delete.
     * @example
     * // Delete a few Conselhos
     * const { count } = await prisma.conselho.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConselhoDeleteManyArgs>(args?: SelectSubset<T, ConselhoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conselhos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConselhoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conselhos
     * const conselho = await prisma.conselho.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConselhoUpdateManyArgs>(args: SelectSubset<T, ConselhoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conselho.
     * @param {ConselhoUpsertArgs} args - Arguments to update or create a Conselho.
     * @example
     * // Update or create a Conselho
     * const conselho = await prisma.conselho.upsert({
     *   create: {
     *     // ... data to create a Conselho
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conselho we want to update
     *   }
     * })
     */
    upsert<T extends ConselhoUpsertArgs>(args: SelectSubset<T, ConselhoUpsertArgs<ExtArgs>>): Prisma__ConselhoClient<$Result.GetResult<Prisma.$ConselhoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conselhos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConselhoCountArgs} args - Arguments to filter Conselhos to count.
     * @example
     * // Count the number of Conselhos
     * const count = await prisma.conselho.count({
     *   where: {
     *     // ... the filter for the Conselhos we want to count
     *   }
     * })
    **/
    count<T extends ConselhoCountArgs>(
      args?: Subset<T, ConselhoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConselhoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conselho.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConselhoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConselhoAggregateArgs>(args: Subset<T, ConselhoAggregateArgs>): Prisma.PrismaPromise<GetConselhoAggregateType<T>>

    /**
     * Group by Conselho.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConselhoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConselhoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConselhoGroupByArgs['orderBy'] }
        : { orderBy?: ConselhoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConselhoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConselhoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conselho model
   */
  readonly fields: ConselhoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conselho.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConselhoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profissionais<T extends Conselho$profissionaisArgs<ExtArgs> = {}>(args?: Subset<T, Conselho$profissionaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conselho model
   */ 
  interface ConselhoFieldRefs {
    readonly id: FieldRef<"Conselho", 'Int'>
    readonly nome: FieldRef<"Conselho", 'String'>
    readonly sigla: FieldRef<"Conselho", 'String'>
    readonly ativo: FieldRef<"Conselho", 'Boolean'>
    readonly createdAt: FieldRef<"Conselho", 'DateTime'>
    readonly updatedAt: FieldRef<"Conselho", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conselho findUnique
   */
  export type ConselhoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conselho
     */
    select?: ConselhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConselhoInclude<ExtArgs> | null
    /**
     * Filter, which Conselho to fetch.
     */
    where: ConselhoWhereUniqueInput
  }

  /**
   * Conselho findUniqueOrThrow
   */
  export type ConselhoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conselho
     */
    select?: ConselhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConselhoInclude<ExtArgs> | null
    /**
     * Filter, which Conselho to fetch.
     */
    where: ConselhoWhereUniqueInput
  }

  /**
   * Conselho findFirst
   */
  export type ConselhoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conselho
     */
    select?: ConselhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConselhoInclude<ExtArgs> | null
    /**
     * Filter, which Conselho to fetch.
     */
    where?: ConselhoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conselhos to fetch.
     */
    orderBy?: ConselhoOrderByWithRelationInput | ConselhoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conselhos.
     */
    cursor?: ConselhoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conselhos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conselhos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conselhos.
     */
    distinct?: ConselhoScalarFieldEnum | ConselhoScalarFieldEnum[]
  }

  /**
   * Conselho findFirstOrThrow
   */
  export type ConselhoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conselho
     */
    select?: ConselhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConselhoInclude<ExtArgs> | null
    /**
     * Filter, which Conselho to fetch.
     */
    where?: ConselhoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conselhos to fetch.
     */
    orderBy?: ConselhoOrderByWithRelationInput | ConselhoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conselhos.
     */
    cursor?: ConselhoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conselhos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conselhos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conselhos.
     */
    distinct?: ConselhoScalarFieldEnum | ConselhoScalarFieldEnum[]
  }

  /**
   * Conselho findMany
   */
  export type ConselhoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conselho
     */
    select?: ConselhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConselhoInclude<ExtArgs> | null
    /**
     * Filter, which Conselhos to fetch.
     */
    where?: ConselhoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conselhos to fetch.
     */
    orderBy?: ConselhoOrderByWithRelationInput | ConselhoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conselhos.
     */
    cursor?: ConselhoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conselhos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conselhos.
     */
    skip?: number
    distinct?: ConselhoScalarFieldEnum | ConselhoScalarFieldEnum[]
  }

  /**
   * Conselho create
   */
  export type ConselhoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conselho
     */
    select?: ConselhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConselhoInclude<ExtArgs> | null
    /**
     * The data needed to create a Conselho.
     */
    data: XOR<ConselhoCreateInput, ConselhoUncheckedCreateInput>
  }

  /**
   * Conselho createMany
   */
  export type ConselhoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conselhos.
     */
    data: ConselhoCreateManyInput | ConselhoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conselho createManyAndReturn
   */
  export type ConselhoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conselho
     */
    select?: ConselhoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Conselhos.
     */
    data: ConselhoCreateManyInput | ConselhoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conselho update
   */
  export type ConselhoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conselho
     */
    select?: ConselhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConselhoInclude<ExtArgs> | null
    /**
     * The data needed to update a Conselho.
     */
    data: XOR<ConselhoUpdateInput, ConselhoUncheckedUpdateInput>
    /**
     * Choose, which Conselho to update.
     */
    where: ConselhoWhereUniqueInput
  }

  /**
   * Conselho updateMany
   */
  export type ConselhoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conselhos.
     */
    data: XOR<ConselhoUpdateManyMutationInput, ConselhoUncheckedUpdateManyInput>
    /**
     * Filter which Conselhos to update
     */
    where?: ConselhoWhereInput
  }

  /**
   * Conselho upsert
   */
  export type ConselhoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conselho
     */
    select?: ConselhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConselhoInclude<ExtArgs> | null
    /**
     * The filter to search for the Conselho to update in case it exists.
     */
    where: ConselhoWhereUniqueInput
    /**
     * In case the Conselho found by the `where` argument doesn't exist, create a new Conselho with this data.
     */
    create: XOR<ConselhoCreateInput, ConselhoUncheckedCreateInput>
    /**
     * In case the Conselho was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConselhoUpdateInput, ConselhoUncheckedUpdateInput>
  }

  /**
   * Conselho delete
   */
  export type ConselhoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conselho
     */
    select?: ConselhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConselhoInclude<ExtArgs> | null
    /**
     * Filter which Conselho to delete.
     */
    where: ConselhoWhereUniqueInput
  }

  /**
   * Conselho deleteMany
   */
  export type ConselhoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conselhos to delete
     */
    where?: ConselhoWhereInput
  }

  /**
   * Conselho.profissionais
   */
  export type Conselho$profissionaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    where?: ProfissionalWhereInput
    orderBy?: ProfissionalOrderByWithRelationInput | ProfissionalOrderByWithRelationInput[]
    cursor?: ProfissionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfissionalScalarFieldEnum | ProfissionalScalarFieldEnum[]
  }

  /**
   * Conselho without action
   */
  export type ConselhoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conselho
     */
    select?: ConselhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConselhoInclude<ExtArgs> | null
  }


  /**
   * Model Profissional
   */

  export type AggregateProfissional = {
    _count: ProfissionalCountAggregateOutputType | null
    _avg: ProfissionalAvgAggregateOutputType | null
    _sum: ProfissionalSumAggregateOutputType | null
    _min: ProfissionalMinAggregateOutputType | null
    _max: ProfissionalMaxAggregateOutputType | null
  }

  export type ProfissionalAvgAggregateOutputType = {
    id: number | null
    conselhoId: number | null
  }

  export type ProfissionalSumAggregateOutputType = {
    id: number | null
    conselhoId: number | null
  }

  export type ProfissionalMinAggregateOutputType = {
    id: number | null
    nome: string | null
    documento: string | null
    registro: string | null
    conselhoId: number | null
    telefone: string | null
    email: string | null
    endereco: string | null
    cidade: string | null
    uf: string | null
    cep: string | null
    tipo: $Enums.TipoProfissional | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfissionalMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    documento: string | null
    registro: string | null
    conselhoId: number | null
    telefone: string | null
    email: string | null
    endereco: string | null
    cidade: string | null
    uf: string | null
    cep: string | null
    tipo: $Enums.TipoProfissional | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfissionalCountAggregateOutputType = {
    id: number
    nome: number
    documento: number
    registro: number
    conselhoId: number
    telefone: number
    email: number
    endereco: number
    cidade: number
    uf: number
    cep: number
    tipo: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfissionalAvgAggregateInputType = {
    id?: true
    conselhoId?: true
  }

  export type ProfissionalSumAggregateInputType = {
    id?: true
    conselhoId?: true
  }

  export type ProfissionalMinAggregateInputType = {
    id?: true
    nome?: true
    documento?: true
    registro?: true
    conselhoId?: true
    telefone?: true
    email?: true
    endereco?: true
    cidade?: true
    uf?: true
    cep?: true
    tipo?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfissionalMaxAggregateInputType = {
    id?: true
    nome?: true
    documento?: true
    registro?: true
    conselhoId?: true
    telefone?: true
    email?: true
    endereco?: true
    cidade?: true
    uf?: true
    cep?: true
    tipo?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfissionalCountAggregateInputType = {
    id?: true
    nome?: true
    documento?: true
    registro?: true
    conselhoId?: true
    telefone?: true
    email?: true
    endereco?: true
    cidade?: true
    uf?: true
    cep?: true
    tipo?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfissionalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profissional to aggregate.
     */
    where?: ProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profissionals to fetch.
     */
    orderBy?: ProfissionalOrderByWithRelationInput | ProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profissionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profissionals
    **/
    _count?: true | ProfissionalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfissionalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfissionalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfissionalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfissionalMaxAggregateInputType
  }

  export type GetProfissionalAggregateType<T extends ProfissionalAggregateArgs> = {
        [P in keyof T & keyof AggregateProfissional]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfissional[P]>
      : GetScalarType<T[P], AggregateProfissional[P]>
  }




  export type ProfissionalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfissionalWhereInput
    orderBy?: ProfissionalOrderByWithAggregationInput | ProfissionalOrderByWithAggregationInput[]
    by: ProfissionalScalarFieldEnum[] | ProfissionalScalarFieldEnum
    having?: ProfissionalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfissionalCountAggregateInputType | true
    _avg?: ProfissionalAvgAggregateInputType
    _sum?: ProfissionalSumAggregateInputType
    _min?: ProfissionalMinAggregateInputType
    _max?: ProfissionalMaxAggregateInputType
  }

  export type ProfissionalGroupByOutputType = {
    id: number
    nome: string
    documento: string | null
    registro: string | null
    conselhoId: number | null
    telefone: string | null
    email: string | null
    endereco: string | null
    cidade: string | null
    uf: string | null
    cep: string | null
    tipo: $Enums.TipoProfissional
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProfissionalCountAggregateOutputType | null
    _avg: ProfissionalAvgAggregateOutputType | null
    _sum: ProfissionalSumAggregateOutputType | null
    _min: ProfissionalMinAggregateOutputType | null
    _max: ProfissionalMaxAggregateOutputType | null
  }

  type GetProfissionalGroupByPayload<T extends ProfissionalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfissionalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfissionalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfissionalGroupByOutputType[P]>
            : GetScalarType<T[P], ProfissionalGroupByOutputType[P]>
        }
      >
    >


  export type ProfissionalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    documento?: boolean
    registro?: boolean
    conselhoId?: boolean
    telefone?: boolean
    email?: boolean
    endereco?: boolean
    cidade?: boolean
    uf?: boolean
    cep?: boolean
    tipo?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conselho?: boolean | Profissional$conselhoArgs<ExtArgs>
    pedidosSolicitados?: boolean | Profissional$pedidosSolicitadosArgs<ExtArgs>
    laudosAssinados?: boolean | Profissional$laudosAssinadosArgs<ExtArgs>
    clientesResponsavel?: boolean | Profissional$clientesResponsavelArgs<ExtArgs>
    _count?: boolean | ProfissionalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profissional"]>

  export type ProfissionalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    documento?: boolean
    registro?: boolean
    conselhoId?: boolean
    telefone?: boolean
    email?: boolean
    endereco?: boolean
    cidade?: boolean
    uf?: boolean
    cep?: boolean
    tipo?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conselho?: boolean | Profissional$conselhoArgs<ExtArgs>
  }, ExtArgs["result"]["profissional"]>

  export type ProfissionalSelectScalar = {
    id?: boolean
    nome?: boolean
    documento?: boolean
    registro?: boolean
    conselhoId?: boolean
    telefone?: boolean
    email?: boolean
    endereco?: boolean
    cidade?: boolean
    uf?: boolean
    cep?: boolean
    tipo?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfissionalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conselho?: boolean | Profissional$conselhoArgs<ExtArgs>
    pedidosSolicitados?: boolean | Profissional$pedidosSolicitadosArgs<ExtArgs>
    laudosAssinados?: boolean | Profissional$laudosAssinadosArgs<ExtArgs>
    clientesResponsavel?: boolean | Profissional$clientesResponsavelArgs<ExtArgs>
    _count?: boolean | ProfissionalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfissionalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conselho?: boolean | Profissional$conselhoArgs<ExtArgs>
  }

  export type $ProfissionalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profissional"
    objects: {
      conselho: Prisma.$ConselhoPayload<ExtArgs> | null
      pedidosSolicitados: Prisma.$PedidoPayload<ExtArgs>[]
      laudosAssinados: Prisma.$LaudoPayload<ExtArgs>[]
      clientesResponsavel: Prisma.$ClientePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      documento: string | null
      registro: string | null
      conselhoId: number | null
      telefone: string | null
      email: string | null
      endereco: string | null
      cidade: string | null
      uf: string | null
      cep: string | null
      tipo: $Enums.TipoProfissional
      ativo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profissional"]>
    composites: {}
  }

  type ProfissionalGetPayload<S extends boolean | null | undefined | ProfissionalDefaultArgs> = $Result.GetResult<Prisma.$ProfissionalPayload, S>

  type ProfissionalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfissionalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfissionalCountAggregateInputType | true
    }

  export interface ProfissionalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profissional'], meta: { name: 'Profissional' } }
    /**
     * Find zero or one Profissional that matches the filter.
     * @param {ProfissionalFindUniqueArgs} args - Arguments to find a Profissional
     * @example
     * // Get one Profissional
     * const profissional = await prisma.profissional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfissionalFindUniqueArgs>(args: SelectSubset<T, ProfissionalFindUniqueArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profissional that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfissionalFindUniqueOrThrowArgs} args - Arguments to find a Profissional
     * @example
     * // Get one Profissional
     * const profissional = await prisma.profissional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfissionalFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfissionalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profissional that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalFindFirstArgs} args - Arguments to find a Profissional
     * @example
     * // Get one Profissional
     * const profissional = await prisma.profissional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfissionalFindFirstArgs>(args?: SelectSubset<T, ProfissionalFindFirstArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profissional that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalFindFirstOrThrowArgs} args - Arguments to find a Profissional
     * @example
     * // Get one Profissional
     * const profissional = await prisma.profissional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfissionalFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfissionalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profissionals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profissionals
     * const profissionals = await prisma.profissional.findMany()
     * 
     * // Get first 10 Profissionals
     * const profissionals = await prisma.profissional.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profissionalWithIdOnly = await prisma.profissional.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfissionalFindManyArgs>(args?: SelectSubset<T, ProfissionalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profissional.
     * @param {ProfissionalCreateArgs} args - Arguments to create a Profissional.
     * @example
     * // Create one Profissional
     * const Profissional = await prisma.profissional.create({
     *   data: {
     *     // ... data to create a Profissional
     *   }
     * })
     * 
     */
    create<T extends ProfissionalCreateArgs>(args: SelectSubset<T, ProfissionalCreateArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profissionals.
     * @param {ProfissionalCreateManyArgs} args - Arguments to create many Profissionals.
     * @example
     * // Create many Profissionals
     * const profissional = await prisma.profissional.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfissionalCreateManyArgs>(args?: SelectSubset<T, ProfissionalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profissionals and returns the data saved in the database.
     * @param {ProfissionalCreateManyAndReturnArgs} args - Arguments to create many Profissionals.
     * @example
     * // Create many Profissionals
     * const profissional = await prisma.profissional.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profissionals and only return the `id`
     * const profissionalWithIdOnly = await prisma.profissional.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfissionalCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfissionalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profissional.
     * @param {ProfissionalDeleteArgs} args - Arguments to delete one Profissional.
     * @example
     * // Delete one Profissional
     * const Profissional = await prisma.profissional.delete({
     *   where: {
     *     // ... filter to delete one Profissional
     *   }
     * })
     * 
     */
    delete<T extends ProfissionalDeleteArgs>(args: SelectSubset<T, ProfissionalDeleteArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profissional.
     * @param {ProfissionalUpdateArgs} args - Arguments to update one Profissional.
     * @example
     * // Update one Profissional
     * const profissional = await prisma.profissional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfissionalUpdateArgs>(args: SelectSubset<T, ProfissionalUpdateArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profissionals.
     * @param {ProfissionalDeleteManyArgs} args - Arguments to filter Profissionals to delete.
     * @example
     * // Delete a few Profissionals
     * const { count } = await prisma.profissional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfissionalDeleteManyArgs>(args?: SelectSubset<T, ProfissionalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profissionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profissionals
     * const profissional = await prisma.profissional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfissionalUpdateManyArgs>(args: SelectSubset<T, ProfissionalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profissional.
     * @param {ProfissionalUpsertArgs} args - Arguments to update or create a Profissional.
     * @example
     * // Update or create a Profissional
     * const profissional = await prisma.profissional.upsert({
     *   create: {
     *     // ... data to create a Profissional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profissional we want to update
     *   }
     * })
     */
    upsert<T extends ProfissionalUpsertArgs>(args: SelectSubset<T, ProfissionalUpsertArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profissionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalCountArgs} args - Arguments to filter Profissionals to count.
     * @example
     * // Count the number of Profissionals
     * const count = await prisma.profissional.count({
     *   where: {
     *     // ... the filter for the Profissionals we want to count
     *   }
     * })
    **/
    count<T extends ProfissionalCountArgs>(
      args?: Subset<T, ProfissionalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfissionalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profissional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfissionalAggregateArgs>(args: Subset<T, ProfissionalAggregateArgs>): Prisma.PrismaPromise<GetProfissionalAggregateType<T>>

    /**
     * Group by Profissional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfissionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfissionalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfissionalGroupByArgs['orderBy'] }
        : { orderBy?: ProfissionalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfissionalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfissionalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profissional model
   */
  readonly fields: ProfissionalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profissional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfissionalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conselho<T extends Profissional$conselhoArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$conselhoArgs<ExtArgs>>): Prisma__ConselhoClient<$Result.GetResult<Prisma.$ConselhoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    pedidosSolicitados<T extends Profissional$pedidosSolicitadosArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$pedidosSolicitadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findMany"> | Null>
    laudosAssinados<T extends Profissional$laudosAssinadosArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$laudosAssinadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "findMany"> | Null>
    clientesResponsavel<T extends Profissional$clientesResponsavelArgs<ExtArgs> = {}>(args?: Subset<T, Profissional$clientesResponsavelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profissional model
   */ 
  interface ProfissionalFieldRefs {
    readonly id: FieldRef<"Profissional", 'Int'>
    readonly nome: FieldRef<"Profissional", 'String'>
    readonly documento: FieldRef<"Profissional", 'String'>
    readonly registro: FieldRef<"Profissional", 'String'>
    readonly conselhoId: FieldRef<"Profissional", 'Int'>
    readonly telefone: FieldRef<"Profissional", 'String'>
    readonly email: FieldRef<"Profissional", 'String'>
    readonly endereco: FieldRef<"Profissional", 'String'>
    readonly cidade: FieldRef<"Profissional", 'String'>
    readonly uf: FieldRef<"Profissional", 'String'>
    readonly cep: FieldRef<"Profissional", 'String'>
    readonly tipo: FieldRef<"Profissional", 'TipoProfissional'>
    readonly ativo: FieldRef<"Profissional", 'Boolean'>
    readonly createdAt: FieldRef<"Profissional", 'DateTime'>
    readonly updatedAt: FieldRef<"Profissional", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profissional findUnique
   */
  export type ProfissionalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which Profissional to fetch.
     */
    where: ProfissionalWhereUniqueInput
  }

  /**
   * Profissional findUniqueOrThrow
   */
  export type ProfissionalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which Profissional to fetch.
     */
    where: ProfissionalWhereUniqueInput
  }

  /**
   * Profissional findFirst
   */
  export type ProfissionalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which Profissional to fetch.
     */
    where?: ProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profissionals to fetch.
     */
    orderBy?: ProfissionalOrderByWithRelationInput | ProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profissionals.
     */
    cursor?: ProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profissionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profissionals.
     */
    distinct?: ProfissionalScalarFieldEnum | ProfissionalScalarFieldEnum[]
  }

  /**
   * Profissional findFirstOrThrow
   */
  export type ProfissionalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which Profissional to fetch.
     */
    where?: ProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profissionals to fetch.
     */
    orderBy?: ProfissionalOrderByWithRelationInput | ProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profissionals.
     */
    cursor?: ProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profissionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profissionals.
     */
    distinct?: ProfissionalScalarFieldEnum | ProfissionalScalarFieldEnum[]
  }

  /**
   * Profissional findMany
   */
  export type ProfissionalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * Filter, which Profissionals to fetch.
     */
    where?: ProfissionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profissionals to fetch.
     */
    orderBy?: ProfissionalOrderByWithRelationInput | ProfissionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profissionals.
     */
    cursor?: ProfissionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profissionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profissionals.
     */
    skip?: number
    distinct?: ProfissionalScalarFieldEnum | ProfissionalScalarFieldEnum[]
  }

  /**
   * Profissional create
   */
  export type ProfissionalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * The data needed to create a Profissional.
     */
    data: XOR<ProfissionalCreateInput, ProfissionalUncheckedCreateInput>
  }

  /**
   * Profissional createMany
   */
  export type ProfissionalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profissionals.
     */
    data: ProfissionalCreateManyInput | ProfissionalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profissional createManyAndReturn
   */
  export type ProfissionalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profissionals.
     */
    data: ProfissionalCreateManyInput | ProfissionalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profissional update
   */
  export type ProfissionalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * The data needed to update a Profissional.
     */
    data: XOR<ProfissionalUpdateInput, ProfissionalUncheckedUpdateInput>
    /**
     * Choose, which Profissional to update.
     */
    where: ProfissionalWhereUniqueInput
  }

  /**
   * Profissional updateMany
   */
  export type ProfissionalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profissionals.
     */
    data: XOR<ProfissionalUpdateManyMutationInput, ProfissionalUncheckedUpdateManyInput>
    /**
     * Filter which Profissionals to update
     */
    where?: ProfissionalWhereInput
  }

  /**
   * Profissional upsert
   */
  export type ProfissionalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * The filter to search for the Profissional to update in case it exists.
     */
    where: ProfissionalWhereUniqueInput
    /**
     * In case the Profissional found by the `where` argument doesn't exist, create a new Profissional with this data.
     */
    create: XOR<ProfissionalCreateInput, ProfissionalUncheckedCreateInput>
    /**
     * In case the Profissional was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfissionalUpdateInput, ProfissionalUncheckedUpdateInput>
  }

  /**
   * Profissional delete
   */
  export type ProfissionalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    /**
     * Filter which Profissional to delete.
     */
    where: ProfissionalWhereUniqueInput
  }

  /**
   * Profissional deleteMany
   */
  export type ProfissionalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profissionals to delete
     */
    where?: ProfissionalWhereInput
  }

  /**
   * Profissional.conselho
   */
  export type Profissional$conselhoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conselho
     */
    select?: ConselhoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConselhoInclude<ExtArgs> | null
    where?: ConselhoWhereInput
  }

  /**
   * Profissional.pedidosSolicitados
   */
  export type Profissional$pedidosSolicitadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Profissional.laudosAssinados
   */
  export type Profissional$laudosAssinadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
    where?: LaudoWhereInput
    orderBy?: LaudoOrderByWithRelationInput | LaudoOrderByWithRelationInput[]
    cursor?: LaudoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaudoScalarFieldEnum | LaudoScalarFieldEnum[]
  }

  /**
   * Profissional.clientesResponsavel
   */
  export type Profissional$clientesResponsavelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    cursor?: ClienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Profissional without action
   */
  export type ProfissionalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
  }


  /**
   * Model Cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteAvgAggregateOutputType = {
    id: number | null
    codVetResp: number | null
  }

  export type ClienteSumAggregateOutputType = {
    id: number | null
    codVetResp: number | null
  }

  export type ClienteMinAggregateOutputType = {
    id: number | null
    nome: string | null
    endereco: string | null
    numero: string | null
    complemento: string | null
    bairro: string | null
    cep: string | null
    cidade: string | null
    uf: string | null
    telefone: string | null
    fax: string | null
    celular: string | null
    email: string | null
    cpfCnpj: string | null
    contato: string | null
    dataCadastro: Date | null
    restricao: string | null
    dataAtualizacao: Date | null
    ativo: string | null
    codVetResp: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClienteMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    endereco: string | null
    numero: string | null
    complemento: string | null
    bairro: string | null
    cep: string | null
    cidade: string | null
    uf: string | null
    telefone: string | null
    fax: string | null
    celular: string | null
    email: string | null
    cpfCnpj: string | null
    contato: string | null
    dataCadastro: Date | null
    restricao: string | null
    dataAtualizacao: Date | null
    ativo: string | null
    codVetResp: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClienteCountAggregateOutputType = {
    id: number
    nome: number
    endereco: number
    numero: number
    complemento: number
    bairro: number
    cep: number
    cidade: number
    uf: number
    telefone: number
    fax: number
    celular: number
    email: number
    cpfCnpj: number
    contato: number
    dataCadastro: number
    restricao: number
    dataAtualizacao: number
    ativo: number
    codVetResp: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClienteAvgAggregateInputType = {
    id?: true
    codVetResp?: true
  }

  export type ClienteSumAggregateInputType = {
    id?: true
    codVetResp?: true
  }

  export type ClienteMinAggregateInputType = {
    id?: true
    nome?: true
    endereco?: true
    numero?: true
    complemento?: true
    bairro?: true
    cep?: true
    cidade?: true
    uf?: true
    telefone?: true
    fax?: true
    celular?: true
    email?: true
    cpfCnpj?: true
    contato?: true
    dataCadastro?: true
    restricao?: true
    dataAtualizacao?: true
    ativo?: true
    codVetResp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClienteMaxAggregateInputType = {
    id?: true
    nome?: true
    endereco?: true
    numero?: true
    complemento?: true
    bairro?: true
    cep?: true
    cidade?: true
    uf?: true
    telefone?: true
    fax?: true
    celular?: true
    email?: true
    cpfCnpj?: true
    contato?: true
    dataCadastro?: true
    restricao?: true
    dataAtualizacao?: true
    ativo?: true
    codVetResp?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClienteCountAggregateInputType = {
    id?: true
    nome?: true
    endereco?: true
    numero?: true
    complemento?: true
    bairro?: true
    cep?: true
    cidade?: true
    uf?: true
    telefone?: true
    fax?: true
    celular?: true
    email?: true
    cpfCnpj?: true
    contato?: true
    dataCadastro?: true
    restricao?: true
    dataAtualizacao?: true
    ativo?: true
    codVetResp?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cliente to aggregate.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithAggregationInput | ClienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _avg?: ClienteAvgAggregateInputType
    _sum?: ClienteSumAggregateInputType
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    id: number
    nome: string
    endereco: string | null
    numero: string | null
    complemento: string | null
    bairro: string | null
    cep: string | null
    cidade: string | null
    uf: string | null
    telefone: string | null
    fax: string | null
    celular: string | null
    email: string | null
    cpfCnpj: string | null
    contato: string | null
    dataCadastro: Date
    restricao: string | null
    dataAtualizacao: Date | null
    ativo: string
    codVetResp: number | null
    createdAt: Date
    updatedAt: Date
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    endereco?: boolean
    numero?: boolean
    complemento?: boolean
    bairro?: boolean
    cep?: boolean
    cidade?: boolean
    uf?: boolean
    telefone?: boolean
    fax?: boolean
    celular?: boolean
    email?: boolean
    cpfCnpj?: boolean
    contato?: boolean
    dataCadastro?: boolean
    restricao?: boolean
    dataAtualizacao?: boolean
    ativo?: boolean
    codVetResp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    animais?: boolean | Cliente$animaisArgs<ExtArgs>
    pedidos?: boolean | Cliente$pedidosArgs<ExtArgs>
    veterinarioResp?: boolean | Cliente$veterinarioRespArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    endereco?: boolean
    numero?: boolean
    complemento?: boolean
    bairro?: boolean
    cep?: boolean
    cidade?: boolean
    uf?: boolean
    telefone?: boolean
    fax?: boolean
    celular?: boolean
    email?: boolean
    cpfCnpj?: boolean
    contato?: boolean
    dataCadastro?: boolean
    restricao?: boolean
    dataAtualizacao?: boolean
    ativo?: boolean
    codVetResp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    veterinarioResp?: boolean | Cliente$veterinarioRespArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectScalar = {
    id?: boolean
    nome?: boolean
    endereco?: boolean
    numero?: boolean
    complemento?: boolean
    bairro?: boolean
    cep?: boolean
    cidade?: boolean
    uf?: boolean
    telefone?: boolean
    fax?: boolean
    celular?: boolean
    email?: boolean
    cpfCnpj?: boolean
    contato?: boolean
    dataCadastro?: boolean
    restricao?: boolean
    dataAtualizacao?: boolean
    ativo?: boolean
    codVetResp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animais?: boolean | Cliente$animaisArgs<ExtArgs>
    pedidos?: boolean | Cliente$pedidosArgs<ExtArgs>
    veterinarioResp?: boolean | Cliente$veterinarioRespArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    veterinarioResp?: boolean | Cliente$veterinarioRespArgs<ExtArgs>
  }

  export type $ClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cliente"
    objects: {
      animais: Prisma.$AnimalPayload<ExtArgs>[]
      pedidos: Prisma.$PedidoPayload<ExtArgs>[]
      veterinarioResp: Prisma.$ProfissionalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      endereco: string | null
      numero: string | null
      complemento: string | null
      bairro: string | null
      cep: string | null
      cidade: string | null
      uf: string | null
      telefone: string | null
      fax: string | null
      celular: string | null
      email: string | null
      cpfCnpj: string | null
      contato: string | null
      dataCadastro: Date
      restricao: string | null
      dataAtualizacao: Date | null
      ativo: string
      codVetResp: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }

  type ClienteGetPayload<S extends boolean | null | undefined | ClienteDefaultArgs> = $Result.GetResult<Prisma.$ClientePayload, S>

  type ClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface ClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cliente'], meta: { name: 'Cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteFindUniqueArgs>(args: SelectSubset<T, ClienteFindUniqueArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteFindFirstArgs>(args?: SelectSubset<T, ClienteFindFirstArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteWithIdOnly = await prisma.cliente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteFindManyArgs>(args?: SelectSubset<T, ClienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
     */
    create<T extends ClienteCreateArgs>(args: SelectSubset<T, ClienteCreateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clientes.
     * @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteCreateManyArgs>(args?: SelectSubset<T, ClienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {ClienteCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clientes and only return the `id`
     * const clienteWithIdOnly = await prisma.cliente.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
     */
    delete<T extends ClienteDeleteArgs>(args: SelectSubset<T, ClienteDeleteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteUpdateArgs>(args: SelectSubset<T, ClienteUpdateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteDeleteManyArgs>(args?: SelectSubset<T, ClienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteUpdateManyArgs>(args: SelectSubset<T, ClienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends ClienteUpsertArgs>(args: SelectSubset<T, ClienteUpsertArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cliente model
   */
  readonly fields: ClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animais<T extends Cliente$animaisArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$animaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findMany"> | Null>
    pedidos<T extends Cliente$pedidosArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$pedidosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findMany"> | Null>
    veterinarioResp<T extends Cliente$veterinarioRespArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$veterinarioRespArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cliente model
   */ 
  interface ClienteFieldRefs {
    readonly id: FieldRef<"Cliente", 'Int'>
    readonly nome: FieldRef<"Cliente", 'String'>
    readonly endereco: FieldRef<"Cliente", 'String'>
    readonly numero: FieldRef<"Cliente", 'String'>
    readonly complemento: FieldRef<"Cliente", 'String'>
    readonly bairro: FieldRef<"Cliente", 'String'>
    readonly cep: FieldRef<"Cliente", 'String'>
    readonly cidade: FieldRef<"Cliente", 'String'>
    readonly uf: FieldRef<"Cliente", 'String'>
    readonly telefone: FieldRef<"Cliente", 'String'>
    readonly fax: FieldRef<"Cliente", 'String'>
    readonly celular: FieldRef<"Cliente", 'String'>
    readonly email: FieldRef<"Cliente", 'String'>
    readonly cpfCnpj: FieldRef<"Cliente", 'String'>
    readonly contato: FieldRef<"Cliente", 'String'>
    readonly dataCadastro: FieldRef<"Cliente", 'DateTime'>
    readonly restricao: FieldRef<"Cliente", 'String'>
    readonly dataAtualizacao: FieldRef<"Cliente", 'DateTime'>
    readonly ativo: FieldRef<"Cliente", 'String'>
    readonly codVetResp: FieldRef<"Cliente", 'Int'>
    readonly createdAt: FieldRef<"Cliente", 'DateTime'>
    readonly updatedAt: FieldRef<"Cliente", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cliente findUnique
   */
  export type ClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findFirst
   */
  export type ClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente create
   */
  export type ClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Cliente.
     */
    data: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }

  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente createManyAndReturn
   */
  export type ClienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cliente update
   */
  export type ClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Cliente.
     */
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     */
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     */
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }

  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter which Cliente to delete.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente.animais
   */
  export type Cliente$animaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    where?: AnimalWhereInput
    orderBy?: AnimalOrderByWithRelationInput | AnimalOrderByWithRelationInput[]
    cursor?: AnimalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnimalScalarFieldEnum | AnimalScalarFieldEnum[]
  }

  /**
   * Cliente.pedidos
   */
  export type Cliente$pedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Cliente.veterinarioResp
   */
  export type Cliente$veterinarioRespArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    where?: ProfissionalWhereInput
  }

  /**
   * Cliente without action
   */
  export type ClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
  }


  /**
   * Model Especie
   */

  export type AggregateEspecie = {
    _count: EspecieCountAggregateOutputType | null
    _avg: EspecieAvgAggregateOutputType | null
    _sum: EspecieSumAggregateOutputType | null
    _min: EspecieMinAggregateOutputType | null
    _max: EspecieMaxAggregateOutputType | null
  }

  export type EspecieAvgAggregateOutputType = {
    id: number | null
  }

  export type EspecieSumAggregateOutputType = {
    id: number | null
  }

  export type EspecieMinAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EspecieMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EspecieCountAggregateOutputType = {
    id: number
    nome: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EspecieAvgAggregateInputType = {
    id?: true
  }

  export type EspecieSumAggregateInputType = {
    id?: true
  }

  export type EspecieMinAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EspecieMaxAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EspecieCountAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EspecieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Especie to aggregate.
     */
    where?: EspecieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Especies to fetch.
     */
    orderBy?: EspecieOrderByWithRelationInput | EspecieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EspecieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Especies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Especies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Especies
    **/
    _count?: true | EspecieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EspecieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EspecieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EspecieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EspecieMaxAggregateInputType
  }

  export type GetEspecieAggregateType<T extends EspecieAggregateArgs> = {
        [P in keyof T & keyof AggregateEspecie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspecie[P]>
      : GetScalarType<T[P], AggregateEspecie[P]>
  }




  export type EspecieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EspecieWhereInput
    orderBy?: EspecieOrderByWithAggregationInput | EspecieOrderByWithAggregationInput[]
    by: EspecieScalarFieldEnum[] | EspecieScalarFieldEnum
    having?: EspecieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EspecieCountAggregateInputType | true
    _avg?: EspecieAvgAggregateInputType
    _sum?: EspecieSumAggregateInputType
    _min?: EspecieMinAggregateInputType
    _max?: EspecieMaxAggregateInputType
  }

  export type EspecieGroupByOutputType = {
    id: number
    nome: string
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    _count: EspecieCountAggregateOutputType | null
    _avg: EspecieAvgAggregateOutputType | null
    _sum: EspecieSumAggregateOutputType | null
    _min: EspecieMinAggregateOutputType | null
    _max: EspecieMaxAggregateOutputType | null
  }

  type GetEspecieGroupByPayload<T extends EspecieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EspecieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EspecieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EspecieGroupByOutputType[P]>
            : GetScalarType<T[P], EspecieGroupByOutputType[P]>
        }
      >
    >


  export type EspecieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    animais?: boolean | Especie$animaisArgs<ExtArgs>
    _count?: boolean | EspecieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["especie"]>

  export type EspecieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["especie"]>

  export type EspecieSelectScalar = {
    id?: boolean
    nome?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EspecieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animais?: boolean | Especie$animaisArgs<ExtArgs>
    _count?: boolean | EspecieCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EspecieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EspeciePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Especie"
    objects: {
      animais: Prisma.$AnimalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      ativo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["especie"]>
    composites: {}
  }

  type EspecieGetPayload<S extends boolean | null | undefined | EspecieDefaultArgs> = $Result.GetResult<Prisma.$EspeciePayload, S>

  type EspecieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EspecieFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EspecieCountAggregateInputType | true
    }

  export interface EspecieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Especie'], meta: { name: 'Especie' } }
    /**
     * Find zero or one Especie that matches the filter.
     * @param {EspecieFindUniqueArgs} args - Arguments to find a Especie
     * @example
     * // Get one Especie
     * const especie = await prisma.especie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EspecieFindUniqueArgs>(args: SelectSubset<T, EspecieFindUniqueArgs<ExtArgs>>): Prisma__EspecieClient<$Result.GetResult<Prisma.$EspeciePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Especie that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EspecieFindUniqueOrThrowArgs} args - Arguments to find a Especie
     * @example
     * // Get one Especie
     * const especie = await prisma.especie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EspecieFindUniqueOrThrowArgs>(args: SelectSubset<T, EspecieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EspecieClient<$Result.GetResult<Prisma.$EspeciePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Especie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieFindFirstArgs} args - Arguments to find a Especie
     * @example
     * // Get one Especie
     * const especie = await prisma.especie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EspecieFindFirstArgs>(args?: SelectSubset<T, EspecieFindFirstArgs<ExtArgs>>): Prisma__EspecieClient<$Result.GetResult<Prisma.$EspeciePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Especie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieFindFirstOrThrowArgs} args - Arguments to find a Especie
     * @example
     * // Get one Especie
     * const especie = await prisma.especie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EspecieFindFirstOrThrowArgs>(args?: SelectSubset<T, EspecieFindFirstOrThrowArgs<ExtArgs>>): Prisma__EspecieClient<$Result.GetResult<Prisma.$EspeciePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Especies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Especies
     * const especies = await prisma.especie.findMany()
     * 
     * // Get first 10 Especies
     * const especies = await prisma.especie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const especieWithIdOnly = await prisma.especie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EspecieFindManyArgs>(args?: SelectSubset<T, EspecieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspeciePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Especie.
     * @param {EspecieCreateArgs} args - Arguments to create a Especie.
     * @example
     * // Create one Especie
     * const Especie = await prisma.especie.create({
     *   data: {
     *     // ... data to create a Especie
     *   }
     * })
     * 
     */
    create<T extends EspecieCreateArgs>(args: SelectSubset<T, EspecieCreateArgs<ExtArgs>>): Prisma__EspecieClient<$Result.GetResult<Prisma.$EspeciePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Especies.
     * @param {EspecieCreateManyArgs} args - Arguments to create many Especies.
     * @example
     * // Create many Especies
     * const especie = await prisma.especie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EspecieCreateManyArgs>(args?: SelectSubset<T, EspecieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Especies and returns the data saved in the database.
     * @param {EspecieCreateManyAndReturnArgs} args - Arguments to create many Especies.
     * @example
     * // Create many Especies
     * const especie = await prisma.especie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Especies and only return the `id`
     * const especieWithIdOnly = await prisma.especie.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EspecieCreateManyAndReturnArgs>(args?: SelectSubset<T, EspecieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EspeciePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Especie.
     * @param {EspecieDeleteArgs} args - Arguments to delete one Especie.
     * @example
     * // Delete one Especie
     * const Especie = await prisma.especie.delete({
     *   where: {
     *     // ... filter to delete one Especie
     *   }
     * })
     * 
     */
    delete<T extends EspecieDeleteArgs>(args: SelectSubset<T, EspecieDeleteArgs<ExtArgs>>): Prisma__EspecieClient<$Result.GetResult<Prisma.$EspeciePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Especie.
     * @param {EspecieUpdateArgs} args - Arguments to update one Especie.
     * @example
     * // Update one Especie
     * const especie = await prisma.especie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EspecieUpdateArgs>(args: SelectSubset<T, EspecieUpdateArgs<ExtArgs>>): Prisma__EspecieClient<$Result.GetResult<Prisma.$EspeciePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Especies.
     * @param {EspecieDeleteManyArgs} args - Arguments to filter Especies to delete.
     * @example
     * // Delete a few Especies
     * const { count } = await prisma.especie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EspecieDeleteManyArgs>(args?: SelectSubset<T, EspecieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Especies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Especies
     * const especie = await prisma.especie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EspecieUpdateManyArgs>(args: SelectSubset<T, EspecieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Especie.
     * @param {EspecieUpsertArgs} args - Arguments to update or create a Especie.
     * @example
     * // Update or create a Especie
     * const especie = await prisma.especie.upsert({
     *   create: {
     *     // ... data to create a Especie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Especie we want to update
     *   }
     * })
     */
    upsert<T extends EspecieUpsertArgs>(args: SelectSubset<T, EspecieUpsertArgs<ExtArgs>>): Prisma__EspecieClient<$Result.GetResult<Prisma.$EspeciePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Especies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieCountArgs} args - Arguments to filter Especies to count.
     * @example
     * // Count the number of Especies
     * const count = await prisma.especie.count({
     *   where: {
     *     // ... the filter for the Especies we want to count
     *   }
     * })
    **/
    count<T extends EspecieCountArgs>(
      args?: Subset<T, EspecieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EspecieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Especie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EspecieAggregateArgs>(args: Subset<T, EspecieAggregateArgs>): Prisma.PrismaPromise<GetEspecieAggregateType<T>>

    /**
     * Group by Especie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EspecieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EspecieGroupByArgs['orderBy'] }
        : { orderBy?: EspecieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EspecieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspecieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Especie model
   */
  readonly fields: EspecieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Especie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EspecieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animais<T extends Especie$animaisArgs<ExtArgs> = {}>(args?: Subset<T, Especie$animaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Especie model
   */ 
  interface EspecieFieldRefs {
    readonly id: FieldRef<"Especie", 'Int'>
    readonly nome: FieldRef<"Especie", 'String'>
    readonly ativo: FieldRef<"Especie", 'Boolean'>
    readonly createdAt: FieldRef<"Especie", 'DateTime'>
    readonly updatedAt: FieldRef<"Especie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Especie findUnique
   */
  export type EspecieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especie
     */
    select?: EspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInclude<ExtArgs> | null
    /**
     * Filter, which Especie to fetch.
     */
    where: EspecieWhereUniqueInput
  }

  /**
   * Especie findUniqueOrThrow
   */
  export type EspecieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especie
     */
    select?: EspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInclude<ExtArgs> | null
    /**
     * Filter, which Especie to fetch.
     */
    where: EspecieWhereUniqueInput
  }

  /**
   * Especie findFirst
   */
  export type EspecieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especie
     */
    select?: EspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInclude<ExtArgs> | null
    /**
     * Filter, which Especie to fetch.
     */
    where?: EspecieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Especies to fetch.
     */
    orderBy?: EspecieOrderByWithRelationInput | EspecieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Especies.
     */
    cursor?: EspecieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Especies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Especies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Especies.
     */
    distinct?: EspecieScalarFieldEnum | EspecieScalarFieldEnum[]
  }

  /**
   * Especie findFirstOrThrow
   */
  export type EspecieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especie
     */
    select?: EspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInclude<ExtArgs> | null
    /**
     * Filter, which Especie to fetch.
     */
    where?: EspecieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Especies to fetch.
     */
    orderBy?: EspecieOrderByWithRelationInput | EspecieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Especies.
     */
    cursor?: EspecieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Especies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Especies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Especies.
     */
    distinct?: EspecieScalarFieldEnum | EspecieScalarFieldEnum[]
  }

  /**
   * Especie findMany
   */
  export type EspecieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especie
     */
    select?: EspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInclude<ExtArgs> | null
    /**
     * Filter, which Especies to fetch.
     */
    where?: EspecieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Especies to fetch.
     */
    orderBy?: EspecieOrderByWithRelationInput | EspecieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Especies.
     */
    cursor?: EspecieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Especies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Especies.
     */
    skip?: number
    distinct?: EspecieScalarFieldEnum | EspecieScalarFieldEnum[]
  }

  /**
   * Especie create
   */
  export type EspecieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especie
     */
    select?: EspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInclude<ExtArgs> | null
    /**
     * The data needed to create a Especie.
     */
    data: XOR<EspecieCreateInput, EspecieUncheckedCreateInput>
  }

  /**
   * Especie createMany
   */
  export type EspecieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Especies.
     */
    data: EspecieCreateManyInput | EspecieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Especie createManyAndReturn
   */
  export type EspecieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especie
     */
    select?: EspecieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Especies.
     */
    data: EspecieCreateManyInput | EspecieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Especie update
   */
  export type EspecieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especie
     */
    select?: EspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInclude<ExtArgs> | null
    /**
     * The data needed to update a Especie.
     */
    data: XOR<EspecieUpdateInput, EspecieUncheckedUpdateInput>
    /**
     * Choose, which Especie to update.
     */
    where: EspecieWhereUniqueInput
  }

  /**
   * Especie updateMany
   */
  export type EspecieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Especies.
     */
    data: XOR<EspecieUpdateManyMutationInput, EspecieUncheckedUpdateManyInput>
    /**
     * Filter which Especies to update
     */
    where?: EspecieWhereInput
  }

  /**
   * Especie upsert
   */
  export type EspecieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especie
     */
    select?: EspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInclude<ExtArgs> | null
    /**
     * The filter to search for the Especie to update in case it exists.
     */
    where: EspecieWhereUniqueInput
    /**
     * In case the Especie found by the `where` argument doesn't exist, create a new Especie with this data.
     */
    create: XOR<EspecieCreateInput, EspecieUncheckedCreateInput>
    /**
     * In case the Especie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EspecieUpdateInput, EspecieUncheckedUpdateInput>
  }

  /**
   * Especie delete
   */
  export type EspecieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especie
     */
    select?: EspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInclude<ExtArgs> | null
    /**
     * Filter which Especie to delete.
     */
    where: EspecieWhereUniqueInput
  }

  /**
   * Especie deleteMany
   */
  export type EspecieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Especies to delete
     */
    where?: EspecieWhereInput
  }

  /**
   * Especie.animais
   */
  export type Especie$animaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    where?: AnimalWhereInput
    orderBy?: AnimalOrderByWithRelationInput | AnimalOrderByWithRelationInput[]
    cursor?: AnimalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnimalScalarFieldEnum | AnimalScalarFieldEnum[]
  }

  /**
   * Especie without action
   */
  export type EspecieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Especie
     */
    select?: EspecieSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EspecieInclude<ExtArgs> | null
  }


  /**
   * Model Animal
   */

  export type AggregateAnimal = {
    _count: AnimalCountAggregateOutputType | null
    _avg: AnimalAvgAggregateOutputType | null
    _sum: AnimalSumAggregateOutputType | null
    _min: AnimalMinAggregateOutputType | null
    _max: AnimalMaxAggregateOutputType | null
  }

  export type AnimalAvgAggregateOutputType = {
    id: number | null
    especieId: number | null
    peso: Decimal | null
    clienteId: number | null
  }

  export type AnimalSumAggregateOutputType = {
    id: number | null
    especieId: number | null
    peso: Decimal | null
    clienteId: number | null
  }

  export type AnimalMinAggregateOutputType = {
    id: number | null
    nome: string | null
    especieId: number | null
    raca: string | null
    sexo: $Enums.SexoAnimal | null
    idade: string | null
    peso: Decimal | null
    cor: string | null
    clienteId: number | null
    observacoes: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnimalMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    especieId: number | null
    raca: string | null
    sexo: $Enums.SexoAnimal | null
    idade: string | null
    peso: Decimal | null
    cor: string | null
    clienteId: number | null
    observacoes: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnimalCountAggregateOutputType = {
    id: number
    nome: number
    especieId: number
    raca: number
    sexo: number
    idade: number
    peso: number
    cor: number
    clienteId: number
    observacoes: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnimalAvgAggregateInputType = {
    id?: true
    especieId?: true
    peso?: true
    clienteId?: true
  }

  export type AnimalSumAggregateInputType = {
    id?: true
    especieId?: true
    peso?: true
    clienteId?: true
  }

  export type AnimalMinAggregateInputType = {
    id?: true
    nome?: true
    especieId?: true
    raca?: true
    sexo?: true
    idade?: true
    peso?: true
    cor?: true
    clienteId?: true
    observacoes?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnimalMaxAggregateInputType = {
    id?: true
    nome?: true
    especieId?: true
    raca?: true
    sexo?: true
    idade?: true
    peso?: true
    cor?: true
    clienteId?: true
    observacoes?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnimalCountAggregateInputType = {
    id?: true
    nome?: true
    especieId?: true
    raca?: true
    sexo?: true
    idade?: true
    peso?: true
    cor?: true
    clienteId?: true
    observacoes?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnimalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Animal to aggregate.
     */
    where?: AnimalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Animals to fetch.
     */
    orderBy?: AnimalOrderByWithRelationInput | AnimalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnimalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Animals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Animals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Animals
    **/
    _count?: true | AnimalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnimalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnimalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnimalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnimalMaxAggregateInputType
  }

  export type GetAnimalAggregateType<T extends AnimalAggregateArgs> = {
        [P in keyof T & keyof AggregateAnimal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnimal[P]>
      : GetScalarType<T[P], AggregateAnimal[P]>
  }




  export type AnimalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimalWhereInput
    orderBy?: AnimalOrderByWithAggregationInput | AnimalOrderByWithAggregationInput[]
    by: AnimalScalarFieldEnum[] | AnimalScalarFieldEnum
    having?: AnimalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnimalCountAggregateInputType | true
    _avg?: AnimalAvgAggregateInputType
    _sum?: AnimalSumAggregateInputType
    _min?: AnimalMinAggregateInputType
    _max?: AnimalMaxAggregateInputType
  }

  export type AnimalGroupByOutputType = {
    id: number
    nome: string
    especieId: number
    raca: string | null
    sexo: $Enums.SexoAnimal
    idade: string | null
    peso: Decimal | null
    cor: string | null
    clienteId: number
    observacoes: string | null
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    _count: AnimalCountAggregateOutputType | null
    _avg: AnimalAvgAggregateOutputType | null
    _sum: AnimalSumAggregateOutputType | null
    _min: AnimalMinAggregateOutputType | null
    _max: AnimalMaxAggregateOutputType | null
  }

  type GetAnimalGroupByPayload<T extends AnimalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnimalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnimalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnimalGroupByOutputType[P]>
            : GetScalarType<T[P], AnimalGroupByOutputType[P]>
        }
      >
    >


  export type AnimalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    especieId?: boolean
    raca?: boolean
    sexo?: boolean
    idade?: boolean
    peso?: boolean
    cor?: boolean
    clienteId?: boolean
    observacoes?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    especie?: boolean | EspecieDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    pedidos?: boolean | Animal$pedidosArgs<ExtArgs>
    _count?: boolean | AnimalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["animal"]>

  export type AnimalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    especieId?: boolean
    raca?: boolean
    sexo?: boolean
    idade?: boolean
    peso?: boolean
    cor?: boolean
    clienteId?: boolean
    observacoes?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    especie?: boolean | EspecieDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["animal"]>

  export type AnimalSelectScalar = {
    id?: boolean
    nome?: boolean
    especieId?: boolean
    raca?: boolean
    sexo?: boolean
    idade?: boolean
    peso?: boolean
    cor?: boolean
    clienteId?: boolean
    observacoes?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnimalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especie?: boolean | EspecieDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    pedidos?: boolean | Animal$pedidosArgs<ExtArgs>
    _count?: boolean | AnimalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnimalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    especie?: boolean | EspecieDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
  }

  export type $AnimalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Animal"
    objects: {
      especie: Prisma.$EspeciePayload<ExtArgs>
      cliente: Prisma.$ClientePayload<ExtArgs>
      pedidos: Prisma.$PedidoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      especieId: number
      raca: string | null
      sexo: $Enums.SexoAnimal
      idade: string | null
      peso: Prisma.Decimal | null
      cor: string | null
      clienteId: number
      observacoes: string | null
      ativo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["animal"]>
    composites: {}
  }

  type AnimalGetPayload<S extends boolean | null | undefined | AnimalDefaultArgs> = $Result.GetResult<Prisma.$AnimalPayload, S>

  type AnimalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnimalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnimalCountAggregateInputType | true
    }

  export interface AnimalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Animal'], meta: { name: 'Animal' } }
    /**
     * Find zero or one Animal that matches the filter.
     * @param {AnimalFindUniqueArgs} args - Arguments to find a Animal
     * @example
     * // Get one Animal
     * const animal = await prisma.animal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnimalFindUniqueArgs>(args: SelectSubset<T, AnimalFindUniqueArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Animal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnimalFindUniqueOrThrowArgs} args - Arguments to find a Animal
     * @example
     * // Get one Animal
     * const animal = await prisma.animal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnimalFindUniqueOrThrowArgs>(args: SelectSubset<T, AnimalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Animal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalFindFirstArgs} args - Arguments to find a Animal
     * @example
     * // Get one Animal
     * const animal = await prisma.animal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnimalFindFirstArgs>(args?: SelectSubset<T, AnimalFindFirstArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Animal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalFindFirstOrThrowArgs} args - Arguments to find a Animal
     * @example
     * // Get one Animal
     * const animal = await prisma.animal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnimalFindFirstOrThrowArgs>(args?: SelectSubset<T, AnimalFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Animals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Animals
     * const animals = await prisma.animal.findMany()
     * 
     * // Get first 10 Animals
     * const animals = await prisma.animal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const animalWithIdOnly = await prisma.animal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnimalFindManyArgs>(args?: SelectSubset<T, AnimalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Animal.
     * @param {AnimalCreateArgs} args - Arguments to create a Animal.
     * @example
     * // Create one Animal
     * const Animal = await prisma.animal.create({
     *   data: {
     *     // ... data to create a Animal
     *   }
     * })
     * 
     */
    create<T extends AnimalCreateArgs>(args: SelectSubset<T, AnimalCreateArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Animals.
     * @param {AnimalCreateManyArgs} args - Arguments to create many Animals.
     * @example
     * // Create many Animals
     * const animal = await prisma.animal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnimalCreateManyArgs>(args?: SelectSubset<T, AnimalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Animals and returns the data saved in the database.
     * @param {AnimalCreateManyAndReturnArgs} args - Arguments to create many Animals.
     * @example
     * // Create many Animals
     * const animal = await prisma.animal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Animals and only return the `id`
     * const animalWithIdOnly = await prisma.animal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnimalCreateManyAndReturnArgs>(args?: SelectSubset<T, AnimalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Animal.
     * @param {AnimalDeleteArgs} args - Arguments to delete one Animal.
     * @example
     * // Delete one Animal
     * const Animal = await prisma.animal.delete({
     *   where: {
     *     // ... filter to delete one Animal
     *   }
     * })
     * 
     */
    delete<T extends AnimalDeleteArgs>(args: SelectSubset<T, AnimalDeleteArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Animal.
     * @param {AnimalUpdateArgs} args - Arguments to update one Animal.
     * @example
     * // Update one Animal
     * const animal = await prisma.animal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnimalUpdateArgs>(args: SelectSubset<T, AnimalUpdateArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Animals.
     * @param {AnimalDeleteManyArgs} args - Arguments to filter Animals to delete.
     * @example
     * // Delete a few Animals
     * const { count } = await prisma.animal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnimalDeleteManyArgs>(args?: SelectSubset<T, AnimalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Animals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Animals
     * const animal = await prisma.animal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnimalUpdateManyArgs>(args: SelectSubset<T, AnimalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Animal.
     * @param {AnimalUpsertArgs} args - Arguments to update or create a Animal.
     * @example
     * // Update or create a Animal
     * const animal = await prisma.animal.upsert({
     *   create: {
     *     // ... data to create a Animal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Animal we want to update
     *   }
     * })
     */
    upsert<T extends AnimalUpsertArgs>(args: SelectSubset<T, AnimalUpsertArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Animals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalCountArgs} args - Arguments to filter Animals to count.
     * @example
     * // Count the number of Animals
     * const count = await prisma.animal.count({
     *   where: {
     *     // ... the filter for the Animals we want to count
     *   }
     * })
    **/
    count<T extends AnimalCountArgs>(
      args?: Subset<T, AnimalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnimalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Animal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnimalAggregateArgs>(args: Subset<T, AnimalAggregateArgs>): Prisma.PrismaPromise<GetAnimalAggregateType<T>>

    /**
     * Group by Animal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnimalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnimalGroupByArgs['orderBy'] }
        : { orderBy?: AnimalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnimalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnimalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Animal model
   */
  readonly fields: AnimalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Animal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnimalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    especie<T extends EspecieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EspecieDefaultArgs<ExtArgs>>): Prisma__EspecieClient<$Result.GetResult<Prisma.$EspeciePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pedidos<T extends Animal$pedidosArgs<ExtArgs> = {}>(args?: Subset<T, Animal$pedidosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Animal model
   */ 
  interface AnimalFieldRefs {
    readonly id: FieldRef<"Animal", 'Int'>
    readonly nome: FieldRef<"Animal", 'String'>
    readonly especieId: FieldRef<"Animal", 'Int'>
    readonly raca: FieldRef<"Animal", 'String'>
    readonly sexo: FieldRef<"Animal", 'SexoAnimal'>
    readonly idade: FieldRef<"Animal", 'String'>
    readonly peso: FieldRef<"Animal", 'Decimal'>
    readonly cor: FieldRef<"Animal", 'String'>
    readonly clienteId: FieldRef<"Animal", 'Int'>
    readonly observacoes: FieldRef<"Animal", 'String'>
    readonly ativo: FieldRef<"Animal", 'Boolean'>
    readonly createdAt: FieldRef<"Animal", 'DateTime'>
    readonly updatedAt: FieldRef<"Animal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Animal findUnique
   */
  export type AnimalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * Filter, which Animal to fetch.
     */
    where: AnimalWhereUniqueInput
  }

  /**
   * Animal findUniqueOrThrow
   */
  export type AnimalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * Filter, which Animal to fetch.
     */
    where: AnimalWhereUniqueInput
  }

  /**
   * Animal findFirst
   */
  export type AnimalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * Filter, which Animal to fetch.
     */
    where?: AnimalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Animals to fetch.
     */
    orderBy?: AnimalOrderByWithRelationInput | AnimalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Animals.
     */
    cursor?: AnimalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Animals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Animals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Animals.
     */
    distinct?: AnimalScalarFieldEnum | AnimalScalarFieldEnum[]
  }

  /**
   * Animal findFirstOrThrow
   */
  export type AnimalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * Filter, which Animal to fetch.
     */
    where?: AnimalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Animals to fetch.
     */
    orderBy?: AnimalOrderByWithRelationInput | AnimalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Animals.
     */
    cursor?: AnimalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Animals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Animals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Animals.
     */
    distinct?: AnimalScalarFieldEnum | AnimalScalarFieldEnum[]
  }

  /**
   * Animal findMany
   */
  export type AnimalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * Filter, which Animals to fetch.
     */
    where?: AnimalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Animals to fetch.
     */
    orderBy?: AnimalOrderByWithRelationInput | AnimalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Animals.
     */
    cursor?: AnimalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Animals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Animals.
     */
    skip?: number
    distinct?: AnimalScalarFieldEnum | AnimalScalarFieldEnum[]
  }

  /**
   * Animal create
   */
  export type AnimalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * The data needed to create a Animal.
     */
    data: XOR<AnimalCreateInput, AnimalUncheckedCreateInput>
  }

  /**
   * Animal createMany
   */
  export type AnimalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Animals.
     */
    data: AnimalCreateManyInput | AnimalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Animal createManyAndReturn
   */
  export type AnimalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Animals.
     */
    data: AnimalCreateManyInput | AnimalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Animal update
   */
  export type AnimalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * The data needed to update a Animal.
     */
    data: XOR<AnimalUpdateInput, AnimalUncheckedUpdateInput>
    /**
     * Choose, which Animal to update.
     */
    where: AnimalWhereUniqueInput
  }

  /**
   * Animal updateMany
   */
  export type AnimalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Animals.
     */
    data: XOR<AnimalUpdateManyMutationInput, AnimalUncheckedUpdateManyInput>
    /**
     * Filter which Animals to update
     */
    where?: AnimalWhereInput
  }

  /**
   * Animal upsert
   */
  export type AnimalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * The filter to search for the Animal to update in case it exists.
     */
    where: AnimalWhereUniqueInput
    /**
     * In case the Animal found by the `where` argument doesn't exist, create a new Animal with this data.
     */
    create: XOR<AnimalCreateInput, AnimalUncheckedCreateInput>
    /**
     * In case the Animal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnimalUpdateInput, AnimalUncheckedUpdateInput>
  }

  /**
   * Animal delete
   */
  export type AnimalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * Filter which Animal to delete.
     */
    where: AnimalWhereUniqueInput
  }

  /**
   * Animal deleteMany
   */
  export type AnimalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Animals to delete
     */
    where?: AnimalWhereInput
  }

  /**
   * Animal.pedidos
   */
  export type Animal$pedidosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    cursor?: PedidoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Animal without action
   */
  export type AnimalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
  }


  /**
   * Model Exame
   */

  export type AggregateExame = {
    _count: ExameCountAggregateOutputType | null
    _avg: ExameAvgAggregateOutputType | null
    _sum: ExameSumAggregateOutputType | null
    _min: ExameMinAggregateOutputType | null
    _max: ExameMaxAggregateOutputType | null
  }

  export type ExameAvgAggregateOutputType = {
    id: number | null
    valor: Decimal | null
    tempoResultado: number | null
  }

  export type ExameSumAggregateOutputType = {
    id: number | null
    valor: Decimal | null
    tempoResultado: number | null
  }

  export type ExameMinAggregateOutputType = {
    id: number | null
    codigo: string | null
    nome: string | null
    descricao: string | null
    metodologia: string | null
    material: string | null
    valor: Decimal | null
    tempoResultado: number | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExameMaxAggregateOutputType = {
    id: number | null
    codigo: string | null
    nome: string | null
    descricao: string | null
    metodologia: string | null
    material: string | null
    valor: Decimal | null
    tempoResultado: number | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExameCountAggregateOutputType = {
    id: number
    codigo: number
    nome: number
    descricao: number
    metodologia: number
    material: number
    valor: number
    tempoResultado: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExameAvgAggregateInputType = {
    id?: true
    valor?: true
    tempoResultado?: true
  }

  export type ExameSumAggregateInputType = {
    id?: true
    valor?: true
    tempoResultado?: true
  }

  export type ExameMinAggregateInputType = {
    id?: true
    codigo?: true
    nome?: true
    descricao?: true
    metodologia?: true
    material?: true
    valor?: true
    tempoResultado?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExameMaxAggregateInputType = {
    id?: true
    codigo?: true
    nome?: true
    descricao?: true
    metodologia?: true
    material?: true
    valor?: true
    tempoResultado?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExameCountAggregateInputType = {
    id?: true
    codigo?: true
    nome?: true
    descricao?: true
    metodologia?: true
    material?: true
    valor?: true
    tempoResultado?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exame to aggregate.
     */
    where?: ExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exames to fetch.
     */
    orderBy?: ExameOrderByWithRelationInput | ExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exames
    **/
    _count?: true | ExameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExameMaxAggregateInputType
  }

  export type GetExameAggregateType<T extends ExameAggregateArgs> = {
        [P in keyof T & keyof AggregateExame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExame[P]>
      : GetScalarType<T[P], AggregateExame[P]>
  }




  export type ExameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExameWhereInput
    orderBy?: ExameOrderByWithAggregationInput | ExameOrderByWithAggregationInput[]
    by: ExameScalarFieldEnum[] | ExameScalarFieldEnum
    having?: ExameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExameCountAggregateInputType | true
    _avg?: ExameAvgAggregateInputType
    _sum?: ExameSumAggregateInputType
    _min?: ExameMinAggregateInputType
    _max?: ExameMaxAggregateInputType
  }

  export type ExameGroupByOutputType = {
    id: number
    codigo: string
    nome: string
    descricao: string | null
    metodologia: string | null
    material: string | null
    valor: Decimal | null
    tempoResultado: number | null
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExameCountAggregateOutputType | null
    _avg: ExameAvgAggregateOutputType | null
    _sum: ExameSumAggregateOutputType | null
    _min: ExameMinAggregateOutputType | null
    _max: ExameMaxAggregateOutputType | null
  }

  type GetExameGroupByPayload<T extends ExameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExameGroupByOutputType[P]>
            : GetScalarType<T[P], ExameGroupByOutputType[P]>
        }
      >
    >


  export type ExameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nome?: boolean
    descricao?: boolean
    metodologia?: boolean
    material?: boolean
    valor?: boolean
    tempoResultado?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parametros?: boolean | Exame$parametrosArgs<ExtArgs>
    pedidoExames?: boolean | Exame$pedidoExamesArgs<ExtArgs>
    _count?: boolean | ExameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exame"]>

  export type ExameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nome?: boolean
    descricao?: boolean
    metodologia?: boolean
    material?: boolean
    valor?: boolean
    tempoResultado?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["exame"]>

  export type ExameSelectScalar = {
    id?: boolean
    codigo?: boolean
    nome?: boolean
    descricao?: boolean
    metodologia?: boolean
    material?: boolean
    valor?: boolean
    tempoResultado?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parametros?: boolean | Exame$parametrosArgs<ExtArgs>
    pedidoExames?: boolean | Exame$pedidoExamesArgs<ExtArgs>
    _count?: boolean | ExameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exame"
    objects: {
      parametros: Prisma.$ParametroExamePayload<ExtArgs>[]
      pedidoExames: Prisma.$PedidoExamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigo: string
      nome: string
      descricao: string | null
      metodologia: string | null
      material: string | null
      valor: Prisma.Decimal | null
      tempoResultado: number | null
      ativo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exame"]>
    composites: {}
  }

  type ExameGetPayload<S extends boolean | null | undefined | ExameDefaultArgs> = $Result.GetResult<Prisma.$ExamePayload, S>

  type ExameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExameCountAggregateInputType | true
    }

  export interface ExameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exame'], meta: { name: 'Exame' } }
    /**
     * Find zero or one Exame that matches the filter.
     * @param {ExameFindUniqueArgs} args - Arguments to find a Exame
     * @example
     * // Get one Exame
     * const exame = await prisma.exame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExameFindUniqueArgs>(args: SelectSubset<T, ExameFindUniqueArgs<ExtArgs>>): Prisma__ExameClient<$Result.GetResult<Prisma.$ExamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exame that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExameFindUniqueOrThrowArgs} args - Arguments to find a Exame
     * @example
     * // Get one Exame
     * const exame = await prisma.exame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExameFindUniqueOrThrowArgs>(args: SelectSubset<T, ExameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExameClient<$Result.GetResult<Prisma.$ExamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameFindFirstArgs} args - Arguments to find a Exame
     * @example
     * // Get one Exame
     * const exame = await prisma.exame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExameFindFirstArgs>(args?: SelectSubset<T, ExameFindFirstArgs<ExtArgs>>): Prisma__ExameClient<$Result.GetResult<Prisma.$ExamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameFindFirstOrThrowArgs} args - Arguments to find a Exame
     * @example
     * // Get one Exame
     * const exame = await prisma.exame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExameFindFirstOrThrowArgs>(args?: SelectSubset<T, ExameFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExameClient<$Result.GetResult<Prisma.$ExamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exames
     * const exames = await prisma.exame.findMany()
     * 
     * // Get first 10 Exames
     * const exames = await prisma.exame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exameWithIdOnly = await prisma.exame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExameFindManyArgs>(args?: SelectSubset<T, ExameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exame.
     * @param {ExameCreateArgs} args - Arguments to create a Exame.
     * @example
     * // Create one Exame
     * const Exame = await prisma.exame.create({
     *   data: {
     *     // ... data to create a Exame
     *   }
     * })
     * 
     */
    create<T extends ExameCreateArgs>(args: SelectSubset<T, ExameCreateArgs<ExtArgs>>): Prisma__ExameClient<$Result.GetResult<Prisma.$ExamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exames.
     * @param {ExameCreateManyArgs} args - Arguments to create many Exames.
     * @example
     * // Create many Exames
     * const exame = await prisma.exame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExameCreateManyArgs>(args?: SelectSubset<T, ExameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exames and returns the data saved in the database.
     * @param {ExameCreateManyAndReturnArgs} args - Arguments to create many Exames.
     * @example
     * // Create many Exames
     * const exame = await prisma.exame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exames and only return the `id`
     * const exameWithIdOnly = await prisma.exame.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExameCreateManyAndReturnArgs>(args?: SelectSubset<T, ExameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Exame.
     * @param {ExameDeleteArgs} args - Arguments to delete one Exame.
     * @example
     * // Delete one Exame
     * const Exame = await prisma.exame.delete({
     *   where: {
     *     // ... filter to delete one Exame
     *   }
     * })
     * 
     */
    delete<T extends ExameDeleteArgs>(args: SelectSubset<T, ExameDeleteArgs<ExtArgs>>): Prisma__ExameClient<$Result.GetResult<Prisma.$ExamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exame.
     * @param {ExameUpdateArgs} args - Arguments to update one Exame.
     * @example
     * // Update one Exame
     * const exame = await prisma.exame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExameUpdateArgs>(args: SelectSubset<T, ExameUpdateArgs<ExtArgs>>): Prisma__ExameClient<$Result.GetResult<Prisma.$ExamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exames.
     * @param {ExameDeleteManyArgs} args - Arguments to filter Exames to delete.
     * @example
     * // Delete a few Exames
     * const { count } = await prisma.exame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExameDeleteManyArgs>(args?: SelectSubset<T, ExameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exames
     * const exame = await prisma.exame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExameUpdateManyArgs>(args: SelectSubset<T, ExameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exame.
     * @param {ExameUpsertArgs} args - Arguments to update or create a Exame.
     * @example
     * // Update or create a Exame
     * const exame = await prisma.exame.upsert({
     *   create: {
     *     // ... data to create a Exame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exame we want to update
     *   }
     * })
     */
    upsert<T extends ExameUpsertArgs>(args: SelectSubset<T, ExameUpsertArgs<ExtArgs>>): Prisma__ExameClient<$Result.GetResult<Prisma.$ExamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameCountArgs} args - Arguments to filter Exames to count.
     * @example
     * // Count the number of Exames
     * const count = await prisma.exame.count({
     *   where: {
     *     // ... the filter for the Exames we want to count
     *   }
     * })
    **/
    count<T extends ExameCountArgs>(
      args?: Subset<T, ExameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExameAggregateArgs>(args: Subset<T, ExameAggregateArgs>): Prisma.PrismaPromise<GetExameAggregateType<T>>

    /**
     * Group by Exame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExameGroupByArgs['orderBy'] }
        : { orderBy?: ExameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exame model
   */
  readonly fields: ExameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parametros<T extends Exame$parametrosArgs<ExtArgs> = {}>(args?: Subset<T, Exame$parametrosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParametroExamePayload<ExtArgs>, T, "findMany"> | Null>
    pedidoExames<T extends Exame$pedidoExamesArgs<ExtArgs> = {}>(args?: Subset<T, Exame$pedidoExamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exame model
   */ 
  interface ExameFieldRefs {
    readonly id: FieldRef<"Exame", 'Int'>
    readonly codigo: FieldRef<"Exame", 'String'>
    readonly nome: FieldRef<"Exame", 'String'>
    readonly descricao: FieldRef<"Exame", 'String'>
    readonly metodologia: FieldRef<"Exame", 'String'>
    readonly material: FieldRef<"Exame", 'String'>
    readonly valor: FieldRef<"Exame", 'Decimal'>
    readonly tempoResultado: FieldRef<"Exame", 'Int'>
    readonly ativo: FieldRef<"Exame", 'Boolean'>
    readonly createdAt: FieldRef<"Exame", 'DateTime'>
    readonly updatedAt: FieldRef<"Exame", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exame findUnique
   */
  export type ExameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exame
     */
    select?: ExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameInclude<ExtArgs> | null
    /**
     * Filter, which Exame to fetch.
     */
    where: ExameWhereUniqueInput
  }

  /**
   * Exame findUniqueOrThrow
   */
  export type ExameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exame
     */
    select?: ExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameInclude<ExtArgs> | null
    /**
     * Filter, which Exame to fetch.
     */
    where: ExameWhereUniqueInput
  }

  /**
   * Exame findFirst
   */
  export type ExameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exame
     */
    select?: ExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameInclude<ExtArgs> | null
    /**
     * Filter, which Exame to fetch.
     */
    where?: ExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exames to fetch.
     */
    orderBy?: ExameOrderByWithRelationInput | ExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exames.
     */
    cursor?: ExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exames.
     */
    distinct?: ExameScalarFieldEnum | ExameScalarFieldEnum[]
  }

  /**
   * Exame findFirstOrThrow
   */
  export type ExameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exame
     */
    select?: ExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameInclude<ExtArgs> | null
    /**
     * Filter, which Exame to fetch.
     */
    where?: ExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exames to fetch.
     */
    orderBy?: ExameOrderByWithRelationInput | ExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exames.
     */
    cursor?: ExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exames.
     */
    distinct?: ExameScalarFieldEnum | ExameScalarFieldEnum[]
  }

  /**
   * Exame findMany
   */
  export type ExameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exame
     */
    select?: ExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameInclude<ExtArgs> | null
    /**
     * Filter, which Exames to fetch.
     */
    where?: ExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exames to fetch.
     */
    orderBy?: ExameOrderByWithRelationInput | ExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exames.
     */
    cursor?: ExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exames.
     */
    skip?: number
    distinct?: ExameScalarFieldEnum | ExameScalarFieldEnum[]
  }

  /**
   * Exame create
   */
  export type ExameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exame
     */
    select?: ExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameInclude<ExtArgs> | null
    /**
     * The data needed to create a Exame.
     */
    data: XOR<ExameCreateInput, ExameUncheckedCreateInput>
  }

  /**
   * Exame createMany
   */
  export type ExameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exames.
     */
    data: ExameCreateManyInput | ExameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exame createManyAndReturn
   */
  export type ExameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exame
     */
    select?: ExameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Exames.
     */
    data: ExameCreateManyInput | ExameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exame update
   */
  export type ExameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exame
     */
    select?: ExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameInclude<ExtArgs> | null
    /**
     * The data needed to update a Exame.
     */
    data: XOR<ExameUpdateInput, ExameUncheckedUpdateInput>
    /**
     * Choose, which Exame to update.
     */
    where: ExameWhereUniqueInput
  }

  /**
   * Exame updateMany
   */
  export type ExameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exames.
     */
    data: XOR<ExameUpdateManyMutationInput, ExameUncheckedUpdateManyInput>
    /**
     * Filter which Exames to update
     */
    where?: ExameWhereInput
  }

  /**
   * Exame upsert
   */
  export type ExameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exame
     */
    select?: ExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameInclude<ExtArgs> | null
    /**
     * The filter to search for the Exame to update in case it exists.
     */
    where: ExameWhereUniqueInput
    /**
     * In case the Exame found by the `where` argument doesn't exist, create a new Exame with this data.
     */
    create: XOR<ExameCreateInput, ExameUncheckedCreateInput>
    /**
     * In case the Exame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExameUpdateInput, ExameUncheckedUpdateInput>
  }

  /**
   * Exame delete
   */
  export type ExameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exame
     */
    select?: ExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameInclude<ExtArgs> | null
    /**
     * Filter which Exame to delete.
     */
    where: ExameWhereUniqueInput
  }

  /**
   * Exame deleteMany
   */
  export type ExameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exames to delete
     */
    where?: ExameWhereInput
  }

  /**
   * Exame.parametros
   */
  export type Exame$parametrosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExame
     */
    select?: ParametroExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroExameInclude<ExtArgs> | null
    where?: ParametroExameWhereInput
    orderBy?: ParametroExameOrderByWithRelationInput | ParametroExameOrderByWithRelationInput[]
    cursor?: ParametroExameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParametroExameScalarFieldEnum | ParametroExameScalarFieldEnum[]
  }

  /**
   * Exame.pedidoExames
   */
  export type Exame$pedidoExamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameInclude<ExtArgs> | null
    where?: PedidoExameWhereInput
    orderBy?: PedidoExameOrderByWithRelationInput | PedidoExameOrderByWithRelationInput[]
    cursor?: PedidoExameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoExameScalarFieldEnum | PedidoExameScalarFieldEnum[]
  }

  /**
   * Exame without action
   */
  export type ExameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exame
     */
    select?: ExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExameInclude<ExtArgs> | null
  }


  /**
   * Model ParametroExame
   */

  export type AggregateParametroExame = {
    _count: ParametroExameCountAggregateOutputType | null
    _avg: ParametroExameAvgAggregateOutputType | null
    _sum: ParametroExameSumAggregateOutputType | null
    _min: ParametroExameMinAggregateOutputType | null
    _max: ParametroExameMaxAggregateOutputType | null
  }

  export type ParametroExameAvgAggregateOutputType = {
    id: number | null
    exameId: number | null
    ordem: number | null
  }

  export type ParametroExameSumAggregateOutputType = {
    id: number | null
    exameId: number | null
    ordem: number | null
  }

  export type ParametroExameMinAggregateOutputType = {
    id: number | null
    exameId: number | null
    nome: string | null
    unidade: string | null
    valorReferencia: string | null
    ordem: number | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParametroExameMaxAggregateOutputType = {
    id: number | null
    exameId: number | null
    nome: string | null
    unidade: string | null
    valorReferencia: string | null
    ordem: number | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParametroExameCountAggregateOutputType = {
    id: number
    exameId: number
    nome: number
    unidade: number
    valorReferencia: number
    ordem: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParametroExameAvgAggregateInputType = {
    id?: true
    exameId?: true
    ordem?: true
  }

  export type ParametroExameSumAggregateInputType = {
    id?: true
    exameId?: true
    ordem?: true
  }

  export type ParametroExameMinAggregateInputType = {
    id?: true
    exameId?: true
    nome?: true
    unidade?: true
    valorReferencia?: true
    ordem?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParametroExameMaxAggregateInputType = {
    id?: true
    exameId?: true
    nome?: true
    unidade?: true
    valorReferencia?: true
    ordem?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParametroExameCountAggregateInputType = {
    id?: true
    exameId?: true
    nome?: true
    unidade?: true
    valorReferencia?: true
    ordem?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParametroExameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParametroExame to aggregate.
     */
    where?: ParametroExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParametroExames to fetch.
     */
    orderBy?: ParametroExameOrderByWithRelationInput | ParametroExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParametroExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParametroExames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParametroExames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParametroExames
    **/
    _count?: true | ParametroExameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParametroExameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParametroExameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParametroExameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParametroExameMaxAggregateInputType
  }

  export type GetParametroExameAggregateType<T extends ParametroExameAggregateArgs> = {
        [P in keyof T & keyof AggregateParametroExame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParametroExame[P]>
      : GetScalarType<T[P], AggregateParametroExame[P]>
  }




  export type ParametroExameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParametroExameWhereInput
    orderBy?: ParametroExameOrderByWithAggregationInput | ParametroExameOrderByWithAggregationInput[]
    by: ParametroExameScalarFieldEnum[] | ParametroExameScalarFieldEnum
    having?: ParametroExameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParametroExameCountAggregateInputType | true
    _avg?: ParametroExameAvgAggregateInputType
    _sum?: ParametroExameSumAggregateInputType
    _min?: ParametroExameMinAggregateInputType
    _max?: ParametroExameMaxAggregateInputType
  }

  export type ParametroExameGroupByOutputType = {
    id: number
    exameId: number
    nome: string
    unidade: string | null
    valorReferencia: string | null
    ordem: number
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    _count: ParametroExameCountAggregateOutputType | null
    _avg: ParametroExameAvgAggregateOutputType | null
    _sum: ParametroExameSumAggregateOutputType | null
    _min: ParametroExameMinAggregateOutputType | null
    _max: ParametroExameMaxAggregateOutputType | null
  }

  type GetParametroExameGroupByPayload<T extends ParametroExameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParametroExameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParametroExameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParametroExameGroupByOutputType[P]>
            : GetScalarType<T[P], ParametroExameGroupByOutputType[P]>
        }
      >
    >


  export type ParametroExameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exameId?: boolean
    nome?: boolean
    unidade?: boolean
    valorReferencia?: boolean
    ordem?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exame?: boolean | ExameDefaultArgs<ExtArgs>
    resultados?: boolean | ParametroExame$resultadosArgs<ExtArgs>
    _count?: boolean | ParametroExameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parametroExame"]>

  export type ParametroExameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exameId?: boolean
    nome?: boolean
    unidade?: boolean
    valorReferencia?: boolean
    ordem?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exame?: boolean | ExameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parametroExame"]>

  export type ParametroExameSelectScalar = {
    id?: boolean
    exameId?: boolean
    nome?: boolean
    unidade?: boolean
    valorReferencia?: boolean
    ordem?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParametroExameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exame?: boolean | ExameDefaultArgs<ExtArgs>
    resultados?: boolean | ParametroExame$resultadosArgs<ExtArgs>
    _count?: boolean | ParametroExameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParametroExameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exame?: boolean | ExameDefaultArgs<ExtArgs>
  }

  export type $ParametroExamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParametroExame"
    objects: {
      exame: Prisma.$ExamePayload<ExtArgs>
      resultados: Prisma.$ResultadoExamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      exameId: number
      nome: string
      unidade: string | null
      valorReferencia: string | null
      ordem: number
      ativo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parametroExame"]>
    composites: {}
  }

  type ParametroExameGetPayload<S extends boolean | null | undefined | ParametroExameDefaultArgs> = $Result.GetResult<Prisma.$ParametroExamePayload, S>

  type ParametroExameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParametroExameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParametroExameCountAggregateInputType | true
    }

  export interface ParametroExameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParametroExame'], meta: { name: 'ParametroExame' } }
    /**
     * Find zero or one ParametroExame that matches the filter.
     * @param {ParametroExameFindUniqueArgs} args - Arguments to find a ParametroExame
     * @example
     * // Get one ParametroExame
     * const parametroExame = await prisma.parametroExame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParametroExameFindUniqueArgs>(args: SelectSubset<T, ParametroExameFindUniqueArgs<ExtArgs>>): Prisma__ParametroExameClient<$Result.GetResult<Prisma.$ParametroExamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ParametroExame that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParametroExameFindUniqueOrThrowArgs} args - Arguments to find a ParametroExame
     * @example
     * // Get one ParametroExame
     * const parametroExame = await prisma.parametroExame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParametroExameFindUniqueOrThrowArgs>(args: SelectSubset<T, ParametroExameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParametroExameClient<$Result.GetResult<Prisma.$ParametroExamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ParametroExame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroExameFindFirstArgs} args - Arguments to find a ParametroExame
     * @example
     * // Get one ParametroExame
     * const parametroExame = await prisma.parametroExame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParametroExameFindFirstArgs>(args?: SelectSubset<T, ParametroExameFindFirstArgs<ExtArgs>>): Prisma__ParametroExameClient<$Result.GetResult<Prisma.$ParametroExamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ParametroExame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroExameFindFirstOrThrowArgs} args - Arguments to find a ParametroExame
     * @example
     * // Get one ParametroExame
     * const parametroExame = await prisma.parametroExame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParametroExameFindFirstOrThrowArgs>(args?: SelectSubset<T, ParametroExameFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParametroExameClient<$Result.GetResult<Prisma.$ParametroExamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ParametroExames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroExameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParametroExames
     * const parametroExames = await prisma.parametroExame.findMany()
     * 
     * // Get first 10 ParametroExames
     * const parametroExames = await prisma.parametroExame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parametroExameWithIdOnly = await prisma.parametroExame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParametroExameFindManyArgs>(args?: SelectSubset<T, ParametroExameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParametroExamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ParametroExame.
     * @param {ParametroExameCreateArgs} args - Arguments to create a ParametroExame.
     * @example
     * // Create one ParametroExame
     * const ParametroExame = await prisma.parametroExame.create({
     *   data: {
     *     // ... data to create a ParametroExame
     *   }
     * })
     * 
     */
    create<T extends ParametroExameCreateArgs>(args: SelectSubset<T, ParametroExameCreateArgs<ExtArgs>>): Prisma__ParametroExameClient<$Result.GetResult<Prisma.$ParametroExamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ParametroExames.
     * @param {ParametroExameCreateManyArgs} args - Arguments to create many ParametroExames.
     * @example
     * // Create many ParametroExames
     * const parametroExame = await prisma.parametroExame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParametroExameCreateManyArgs>(args?: SelectSubset<T, ParametroExameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParametroExames and returns the data saved in the database.
     * @param {ParametroExameCreateManyAndReturnArgs} args - Arguments to create many ParametroExames.
     * @example
     * // Create many ParametroExames
     * const parametroExame = await prisma.parametroExame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParametroExames and only return the `id`
     * const parametroExameWithIdOnly = await prisma.parametroExame.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParametroExameCreateManyAndReturnArgs>(args?: SelectSubset<T, ParametroExameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParametroExamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ParametroExame.
     * @param {ParametroExameDeleteArgs} args - Arguments to delete one ParametroExame.
     * @example
     * // Delete one ParametroExame
     * const ParametroExame = await prisma.parametroExame.delete({
     *   where: {
     *     // ... filter to delete one ParametroExame
     *   }
     * })
     * 
     */
    delete<T extends ParametroExameDeleteArgs>(args: SelectSubset<T, ParametroExameDeleteArgs<ExtArgs>>): Prisma__ParametroExameClient<$Result.GetResult<Prisma.$ParametroExamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ParametroExame.
     * @param {ParametroExameUpdateArgs} args - Arguments to update one ParametroExame.
     * @example
     * // Update one ParametroExame
     * const parametroExame = await prisma.parametroExame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParametroExameUpdateArgs>(args: SelectSubset<T, ParametroExameUpdateArgs<ExtArgs>>): Prisma__ParametroExameClient<$Result.GetResult<Prisma.$ParametroExamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ParametroExames.
     * @param {ParametroExameDeleteManyArgs} args - Arguments to filter ParametroExames to delete.
     * @example
     * // Delete a few ParametroExames
     * const { count } = await prisma.parametroExame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParametroExameDeleteManyArgs>(args?: SelectSubset<T, ParametroExameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParametroExames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroExameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParametroExames
     * const parametroExame = await prisma.parametroExame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParametroExameUpdateManyArgs>(args: SelectSubset<T, ParametroExameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParametroExame.
     * @param {ParametroExameUpsertArgs} args - Arguments to update or create a ParametroExame.
     * @example
     * // Update or create a ParametroExame
     * const parametroExame = await prisma.parametroExame.upsert({
     *   create: {
     *     // ... data to create a ParametroExame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParametroExame we want to update
     *   }
     * })
     */
    upsert<T extends ParametroExameUpsertArgs>(args: SelectSubset<T, ParametroExameUpsertArgs<ExtArgs>>): Prisma__ParametroExameClient<$Result.GetResult<Prisma.$ParametroExamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ParametroExames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroExameCountArgs} args - Arguments to filter ParametroExames to count.
     * @example
     * // Count the number of ParametroExames
     * const count = await prisma.parametroExame.count({
     *   where: {
     *     // ... the filter for the ParametroExames we want to count
     *   }
     * })
    **/
    count<T extends ParametroExameCountArgs>(
      args?: Subset<T, ParametroExameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParametroExameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParametroExame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroExameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParametroExameAggregateArgs>(args: Subset<T, ParametroExameAggregateArgs>): Prisma.PrismaPromise<GetParametroExameAggregateType<T>>

    /**
     * Group by ParametroExame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParametroExameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParametroExameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParametroExameGroupByArgs['orderBy'] }
        : { orderBy?: ParametroExameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParametroExameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParametroExameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParametroExame model
   */
  readonly fields: ParametroExameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParametroExame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParametroExameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exame<T extends ExameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExameDefaultArgs<ExtArgs>>): Prisma__ExameClient<$Result.GetResult<Prisma.$ExamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resultados<T extends ParametroExame$resultadosArgs<ExtArgs> = {}>(args?: Subset<T, ParametroExame$resultadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultadoExamePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParametroExame model
   */ 
  interface ParametroExameFieldRefs {
    readonly id: FieldRef<"ParametroExame", 'Int'>
    readonly exameId: FieldRef<"ParametroExame", 'Int'>
    readonly nome: FieldRef<"ParametroExame", 'String'>
    readonly unidade: FieldRef<"ParametroExame", 'String'>
    readonly valorReferencia: FieldRef<"ParametroExame", 'String'>
    readonly ordem: FieldRef<"ParametroExame", 'Int'>
    readonly ativo: FieldRef<"ParametroExame", 'Boolean'>
    readonly createdAt: FieldRef<"ParametroExame", 'DateTime'>
    readonly updatedAt: FieldRef<"ParametroExame", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParametroExame findUnique
   */
  export type ParametroExameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExame
     */
    select?: ParametroExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroExameInclude<ExtArgs> | null
    /**
     * Filter, which ParametroExame to fetch.
     */
    where: ParametroExameWhereUniqueInput
  }

  /**
   * ParametroExame findUniqueOrThrow
   */
  export type ParametroExameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExame
     */
    select?: ParametroExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroExameInclude<ExtArgs> | null
    /**
     * Filter, which ParametroExame to fetch.
     */
    where: ParametroExameWhereUniqueInput
  }

  /**
   * ParametroExame findFirst
   */
  export type ParametroExameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExame
     */
    select?: ParametroExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroExameInclude<ExtArgs> | null
    /**
     * Filter, which ParametroExame to fetch.
     */
    where?: ParametroExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParametroExames to fetch.
     */
    orderBy?: ParametroExameOrderByWithRelationInput | ParametroExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParametroExames.
     */
    cursor?: ParametroExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParametroExames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParametroExames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParametroExames.
     */
    distinct?: ParametroExameScalarFieldEnum | ParametroExameScalarFieldEnum[]
  }

  /**
   * ParametroExame findFirstOrThrow
   */
  export type ParametroExameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExame
     */
    select?: ParametroExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroExameInclude<ExtArgs> | null
    /**
     * Filter, which ParametroExame to fetch.
     */
    where?: ParametroExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParametroExames to fetch.
     */
    orderBy?: ParametroExameOrderByWithRelationInput | ParametroExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParametroExames.
     */
    cursor?: ParametroExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParametroExames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParametroExames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParametroExames.
     */
    distinct?: ParametroExameScalarFieldEnum | ParametroExameScalarFieldEnum[]
  }

  /**
   * ParametroExame findMany
   */
  export type ParametroExameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExame
     */
    select?: ParametroExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroExameInclude<ExtArgs> | null
    /**
     * Filter, which ParametroExames to fetch.
     */
    where?: ParametroExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParametroExames to fetch.
     */
    orderBy?: ParametroExameOrderByWithRelationInput | ParametroExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParametroExames.
     */
    cursor?: ParametroExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParametroExames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParametroExames.
     */
    skip?: number
    distinct?: ParametroExameScalarFieldEnum | ParametroExameScalarFieldEnum[]
  }

  /**
   * ParametroExame create
   */
  export type ParametroExameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExame
     */
    select?: ParametroExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroExameInclude<ExtArgs> | null
    /**
     * The data needed to create a ParametroExame.
     */
    data: XOR<ParametroExameCreateInput, ParametroExameUncheckedCreateInput>
  }

  /**
   * ParametroExame createMany
   */
  export type ParametroExameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParametroExames.
     */
    data: ParametroExameCreateManyInput | ParametroExameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParametroExame createManyAndReturn
   */
  export type ParametroExameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExame
     */
    select?: ParametroExameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ParametroExames.
     */
    data: ParametroExameCreateManyInput | ParametroExameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroExameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParametroExame update
   */
  export type ParametroExameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExame
     */
    select?: ParametroExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroExameInclude<ExtArgs> | null
    /**
     * The data needed to update a ParametroExame.
     */
    data: XOR<ParametroExameUpdateInput, ParametroExameUncheckedUpdateInput>
    /**
     * Choose, which ParametroExame to update.
     */
    where: ParametroExameWhereUniqueInput
  }

  /**
   * ParametroExame updateMany
   */
  export type ParametroExameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParametroExames.
     */
    data: XOR<ParametroExameUpdateManyMutationInput, ParametroExameUncheckedUpdateManyInput>
    /**
     * Filter which ParametroExames to update
     */
    where?: ParametroExameWhereInput
  }

  /**
   * ParametroExame upsert
   */
  export type ParametroExameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExame
     */
    select?: ParametroExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroExameInclude<ExtArgs> | null
    /**
     * The filter to search for the ParametroExame to update in case it exists.
     */
    where: ParametroExameWhereUniqueInput
    /**
     * In case the ParametroExame found by the `where` argument doesn't exist, create a new ParametroExame with this data.
     */
    create: XOR<ParametroExameCreateInput, ParametroExameUncheckedCreateInput>
    /**
     * In case the ParametroExame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParametroExameUpdateInput, ParametroExameUncheckedUpdateInput>
  }

  /**
   * ParametroExame delete
   */
  export type ParametroExameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExame
     */
    select?: ParametroExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroExameInclude<ExtArgs> | null
    /**
     * Filter which ParametroExame to delete.
     */
    where: ParametroExameWhereUniqueInput
  }

  /**
   * ParametroExame deleteMany
   */
  export type ParametroExameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParametroExames to delete
     */
    where?: ParametroExameWhereInput
  }

  /**
   * ParametroExame.resultados
   */
  export type ParametroExame$resultadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameInclude<ExtArgs> | null
    where?: ResultadoExameWhereInput
    orderBy?: ResultadoExameOrderByWithRelationInput | ResultadoExameOrderByWithRelationInput[]
    cursor?: ResultadoExameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultadoExameScalarFieldEnum | ResultadoExameScalarFieldEnum[]
  }

  /**
   * ParametroExame without action
   */
  export type ParametroExameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParametroExame
     */
    select?: ParametroExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParametroExameInclude<ExtArgs> | null
  }


  /**
   * Model Pedido
   */

  export type AggregatePedido = {
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  export type PedidoAvgAggregateOutputType = {
    id: number | null
    clienteId: number | null
    animalId: number | null
    profissionalId: number | null
    usuarioId: number | null
    valorTotal: Decimal | null
    desconto: Decimal | null
  }

  export type PedidoSumAggregateOutputType = {
    id: number | null
    clienteId: number | null
    animalId: number | null
    profissionalId: number | null
    usuarioId: number | null
    valorTotal: Decimal | null
    desconto: Decimal | null
  }

  export type PedidoMinAggregateOutputType = {
    id: number | null
    numero: string | null
    clienteId: number | null
    animalId: number | null
    profissionalId: number | null
    usuarioId: number | null
    dataColeta: Date | null
    observacoes: string | null
    status: $Enums.StatusPedido | null
    valorTotal: Decimal | null
    desconto: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PedidoMaxAggregateOutputType = {
    id: number | null
    numero: string | null
    clienteId: number | null
    animalId: number | null
    profissionalId: number | null
    usuarioId: number | null
    dataColeta: Date | null
    observacoes: string | null
    status: $Enums.StatusPedido | null
    valorTotal: Decimal | null
    desconto: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PedidoCountAggregateOutputType = {
    id: number
    numero: number
    clienteId: number
    animalId: number
    profissionalId: number
    usuarioId: number
    dataColeta: number
    observacoes: number
    status: number
    valorTotal: number
    desconto: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PedidoAvgAggregateInputType = {
    id?: true
    clienteId?: true
    animalId?: true
    profissionalId?: true
    usuarioId?: true
    valorTotal?: true
    desconto?: true
  }

  export type PedidoSumAggregateInputType = {
    id?: true
    clienteId?: true
    animalId?: true
    profissionalId?: true
    usuarioId?: true
    valorTotal?: true
    desconto?: true
  }

  export type PedidoMinAggregateInputType = {
    id?: true
    numero?: true
    clienteId?: true
    animalId?: true
    profissionalId?: true
    usuarioId?: true
    dataColeta?: true
    observacoes?: true
    status?: true
    valorTotal?: true
    desconto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PedidoMaxAggregateInputType = {
    id?: true
    numero?: true
    clienteId?: true
    animalId?: true
    profissionalId?: true
    usuarioId?: true
    dataColeta?: true
    observacoes?: true
    status?: true
    valorTotal?: true
    desconto?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PedidoCountAggregateInputType = {
    id?: true
    numero?: true
    clienteId?: true
    animalId?: true
    profissionalId?: true
    usuarioId?: true
    dataColeta?: true
    observacoes?: true
    status?: true
    valorTotal?: true
    desconto?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PedidoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedido to aggregate.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pedidos
    **/
    _count?: true | PedidoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoMaxAggregateInputType
  }

  export type GetPedidoAggregateType<T extends PedidoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedido]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedido[P]>
      : GetScalarType<T[P], AggregatePedido[P]>
  }




  export type PedidoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoWhereInput
    orderBy?: PedidoOrderByWithAggregationInput | PedidoOrderByWithAggregationInput[]
    by: PedidoScalarFieldEnum[] | PedidoScalarFieldEnum
    having?: PedidoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoCountAggregateInputType | true
    _avg?: PedidoAvgAggregateInputType
    _sum?: PedidoSumAggregateInputType
    _min?: PedidoMinAggregateInputType
    _max?: PedidoMaxAggregateInputType
  }

  export type PedidoGroupByOutputType = {
    id: number
    numero: string
    clienteId: number
    animalId: number
    profissionalId: number | null
    usuarioId: number
    dataColeta: Date
    observacoes: string | null
    status: $Enums.StatusPedido
    valorTotal: Decimal | null
    desconto: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: PedidoCountAggregateOutputType | null
    _avg: PedidoAvgAggregateOutputType | null
    _sum: PedidoSumAggregateOutputType | null
    _min: PedidoMinAggregateOutputType | null
    _max: PedidoMaxAggregateOutputType | null
  }

  type GetPedidoGroupByPayload<T extends PedidoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    clienteId?: boolean
    animalId?: boolean
    profissionalId?: boolean
    usuarioId?: boolean
    dataColeta?: boolean
    observacoes?: boolean
    status?: boolean
    valorTotal?: boolean
    desconto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    profissional?: boolean | Pedido$profissionalArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    exames?: boolean | Pedido$examesArgs<ExtArgs>
    laudos?: boolean | Pedido$laudosArgs<ExtArgs>
    contas?: boolean | Pedido$contasArgs<ExtArgs>
    _count?: boolean | PedidoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedido"]>

  export type PedidoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    clienteId?: boolean
    animalId?: boolean
    profissionalId?: boolean
    usuarioId?: boolean
    dataColeta?: boolean
    observacoes?: boolean
    status?: boolean
    valorTotal?: boolean
    desconto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    profissional?: boolean | Pedido$profissionalArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedido"]>

  export type PedidoSelectScalar = {
    id?: boolean
    numero?: boolean
    clienteId?: boolean
    animalId?: boolean
    profissionalId?: boolean
    usuarioId?: boolean
    dataColeta?: boolean
    observacoes?: boolean
    status?: boolean
    valorTotal?: boolean
    desconto?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PedidoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    profissional?: boolean | Pedido$profissionalArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    exames?: boolean | Pedido$examesArgs<ExtArgs>
    laudos?: boolean | Pedido$laudosArgs<ExtArgs>
    contas?: boolean | Pedido$contasArgs<ExtArgs>
    _count?: boolean | PedidoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PedidoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    profissional?: boolean | Pedido$profissionalArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $PedidoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pedido"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs>
      animal: Prisma.$AnimalPayload<ExtArgs>
      profissional: Prisma.$ProfissionalPayload<ExtArgs> | null
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      exames: Prisma.$PedidoExamePayload<ExtArgs>[]
      laudos: Prisma.$LaudoPayload<ExtArgs>[]
      contas: Prisma.$ContaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      numero: string
      clienteId: number
      animalId: number
      profissionalId: number | null
      usuarioId: number
      dataColeta: Date
      observacoes: string | null
      status: $Enums.StatusPedido
      valorTotal: Prisma.Decimal | null
      desconto: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pedido"]>
    composites: {}
  }

  type PedidoGetPayload<S extends boolean | null | undefined | PedidoDefaultArgs> = $Result.GetResult<Prisma.$PedidoPayload, S>

  type PedidoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PedidoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PedidoCountAggregateInputType | true
    }

  export interface PedidoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pedido'], meta: { name: 'Pedido' } }
    /**
     * Find zero or one Pedido that matches the filter.
     * @param {PedidoFindUniqueArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PedidoFindUniqueArgs>(args: SelectSubset<T, PedidoFindUniqueArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pedido that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PedidoFindUniqueOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PedidoFindUniqueOrThrowArgs>(args: SelectSubset<T, PedidoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pedido that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PedidoFindFirstArgs>(args?: SelectSubset<T, PedidoFindFirstArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pedido that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindFirstOrThrowArgs} args - Arguments to find a Pedido
     * @example
     * // Get one Pedido
     * const pedido = await prisma.pedido.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PedidoFindFirstOrThrowArgs>(args?: SelectSubset<T, PedidoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pedidos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pedidos
     * const pedidos = await prisma.pedido.findMany()
     * 
     * // Get first 10 Pedidos
     * const pedidos = await prisma.pedido.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoWithIdOnly = await prisma.pedido.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PedidoFindManyArgs>(args?: SelectSubset<T, PedidoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pedido.
     * @param {PedidoCreateArgs} args - Arguments to create a Pedido.
     * @example
     * // Create one Pedido
     * const Pedido = await prisma.pedido.create({
     *   data: {
     *     // ... data to create a Pedido
     *   }
     * })
     * 
     */
    create<T extends PedidoCreateArgs>(args: SelectSubset<T, PedidoCreateArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pedidos.
     * @param {PedidoCreateManyArgs} args - Arguments to create many Pedidos.
     * @example
     * // Create many Pedidos
     * const pedido = await prisma.pedido.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PedidoCreateManyArgs>(args?: SelectSubset<T, PedidoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pedidos and returns the data saved in the database.
     * @param {PedidoCreateManyAndReturnArgs} args - Arguments to create many Pedidos.
     * @example
     * // Create many Pedidos
     * const pedido = await prisma.pedido.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pedidos and only return the `id`
     * const pedidoWithIdOnly = await prisma.pedido.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PedidoCreateManyAndReturnArgs>(args?: SelectSubset<T, PedidoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pedido.
     * @param {PedidoDeleteArgs} args - Arguments to delete one Pedido.
     * @example
     * // Delete one Pedido
     * const Pedido = await prisma.pedido.delete({
     *   where: {
     *     // ... filter to delete one Pedido
     *   }
     * })
     * 
     */
    delete<T extends PedidoDeleteArgs>(args: SelectSubset<T, PedidoDeleteArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pedido.
     * @param {PedidoUpdateArgs} args - Arguments to update one Pedido.
     * @example
     * // Update one Pedido
     * const pedido = await prisma.pedido.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PedidoUpdateArgs>(args: SelectSubset<T, PedidoUpdateArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pedidos.
     * @param {PedidoDeleteManyArgs} args - Arguments to filter Pedidos to delete.
     * @example
     * // Delete a few Pedidos
     * const { count } = await prisma.pedido.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PedidoDeleteManyArgs>(args?: SelectSubset<T, PedidoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pedidos
     * const pedido = await prisma.pedido.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PedidoUpdateManyArgs>(args: SelectSubset<T, PedidoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pedido.
     * @param {PedidoUpsertArgs} args - Arguments to update or create a Pedido.
     * @example
     * // Update or create a Pedido
     * const pedido = await prisma.pedido.upsert({
     *   create: {
     *     // ... data to create a Pedido
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pedido we want to update
     *   }
     * })
     */
    upsert<T extends PedidoUpsertArgs>(args: SelectSubset<T, PedidoUpsertArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pedidos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoCountArgs} args - Arguments to filter Pedidos to count.
     * @example
     * // Count the number of Pedidos
     * const count = await prisma.pedido.count({
     *   where: {
     *     // ... the filter for the Pedidos we want to count
     *   }
     * })
    **/
    count<T extends PedidoCountArgs>(
      args?: Subset<T, PedidoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoAggregateArgs>(args: Subset<T, PedidoAggregateArgs>): Prisma.PrismaPromise<GetPedidoAggregateType<T>>

    /**
     * Group by Pedido.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pedido model
   */
  readonly fields: PedidoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pedido.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    animal<T extends AnimalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimalDefaultArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profissional<T extends Pedido$profissionalArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$profissionalArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exames<T extends Pedido$examesArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$examesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "findMany"> | Null>
    laudos<T extends Pedido$laudosArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$laudosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "findMany"> | Null>
    contas<T extends Pedido$contasArgs<ExtArgs> = {}>(args?: Subset<T, Pedido$contasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pedido model
   */ 
  interface PedidoFieldRefs {
    readonly id: FieldRef<"Pedido", 'Int'>
    readonly numero: FieldRef<"Pedido", 'String'>
    readonly clienteId: FieldRef<"Pedido", 'Int'>
    readonly animalId: FieldRef<"Pedido", 'Int'>
    readonly profissionalId: FieldRef<"Pedido", 'Int'>
    readonly usuarioId: FieldRef<"Pedido", 'Int'>
    readonly dataColeta: FieldRef<"Pedido", 'DateTime'>
    readonly observacoes: FieldRef<"Pedido", 'String'>
    readonly status: FieldRef<"Pedido", 'StatusPedido'>
    readonly valorTotal: FieldRef<"Pedido", 'Decimal'>
    readonly desconto: FieldRef<"Pedido", 'Decimal'>
    readonly createdAt: FieldRef<"Pedido", 'DateTime'>
    readonly updatedAt: FieldRef<"Pedido", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pedido findUnique
   */
  export type PedidoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido findUniqueOrThrow
   */
  export type PedidoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido findFirst
   */
  export type PedidoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Pedido findFirstOrThrow
   */
  export type PedidoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedido to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pedidos.
     */
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Pedido findMany
   */
  export type PedidoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter, which Pedidos to fetch.
     */
    where?: PedidoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pedidos to fetch.
     */
    orderBy?: PedidoOrderByWithRelationInput | PedidoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pedidos.
     */
    cursor?: PedidoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pedidos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pedidos.
     */
    skip?: number
    distinct?: PedidoScalarFieldEnum | PedidoScalarFieldEnum[]
  }

  /**
   * Pedido create
   */
  export type PedidoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pedido.
     */
    data: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
  }

  /**
   * Pedido createMany
   */
  export type PedidoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pedidos.
     */
    data: PedidoCreateManyInput | PedidoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pedido createManyAndReturn
   */
  export type PedidoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pedidos.
     */
    data: PedidoCreateManyInput | PedidoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pedido update
   */
  export type PedidoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pedido.
     */
    data: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
    /**
     * Choose, which Pedido to update.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido updateMany
   */
  export type PedidoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pedidos.
     */
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyInput>
    /**
     * Filter which Pedidos to update
     */
    where?: PedidoWhereInput
  }

  /**
   * Pedido upsert
   */
  export type PedidoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pedido to update in case it exists.
     */
    where: PedidoWhereUniqueInput
    /**
     * In case the Pedido found by the `where` argument doesn't exist, create a new Pedido with this data.
     */
    create: XOR<PedidoCreateInput, PedidoUncheckedCreateInput>
    /**
     * In case the Pedido was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoUpdateInput, PedidoUncheckedUpdateInput>
  }

  /**
   * Pedido delete
   */
  export type PedidoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    /**
     * Filter which Pedido to delete.
     */
    where: PedidoWhereUniqueInput
  }

  /**
   * Pedido deleteMany
   */
  export type PedidoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pedidos to delete
     */
    where?: PedidoWhereInput
  }

  /**
   * Pedido.profissional
   */
  export type Pedido$profissionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    where?: ProfissionalWhereInput
  }

  /**
   * Pedido.exames
   */
  export type Pedido$examesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameInclude<ExtArgs> | null
    where?: PedidoExameWhereInput
    orderBy?: PedidoExameOrderByWithRelationInput | PedidoExameOrderByWithRelationInput[]
    cursor?: PedidoExameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoExameScalarFieldEnum | PedidoExameScalarFieldEnum[]
  }

  /**
   * Pedido.laudos
   */
  export type Pedido$laudosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
    where?: LaudoWhereInput
    orderBy?: LaudoOrderByWithRelationInput | LaudoOrderByWithRelationInput[]
    cursor?: LaudoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaudoScalarFieldEnum | LaudoScalarFieldEnum[]
  }

  /**
   * Pedido.contas
   */
  export type Pedido$contasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    where?: ContaWhereInput
    orderBy?: ContaOrderByWithRelationInput | ContaOrderByWithRelationInput[]
    cursor?: ContaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContaScalarFieldEnum | ContaScalarFieldEnum[]
  }

  /**
   * Pedido without action
   */
  export type PedidoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
  }


  /**
   * Model PedidoExame
   */

  export type AggregatePedidoExame = {
    _count: PedidoExameCountAggregateOutputType | null
    _avg: PedidoExameAvgAggregateOutputType | null
    _sum: PedidoExameSumAggregateOutputType | null
    _min: PedidoExameMinAggregateOutputType | null
    _max: PedidoExameMaxAggregateOutputType | null
  }

  export type PedidoExameAvgAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    exameId: number | null
    valor: Decimal | null
  }

  export type PedidoExameSumAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    exameId: number | null
    valor: Decimal | null
  }

  export type PedidoExameMinAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    exameId: number | null
    valor: Decimal | null
    status: $Enums.StatusExame | null
    observacoes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PedidoExameMaxAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    exameId: number | null
    valor: Decimal | null
    status: $Enums.StatusExame | null
    observacoes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PedidoExameCountAggregateOutputType = {
    id: number
    pedidoId: number
    exameId: number
    valor: number
    status: number
    observacoes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PedidoExameAvgAggregateInputType = {
    id?: true
    pedidoId?: true
    exameId?: true
    valor?: true
  }

  export type PedidoExameSumAggregateInputType = {
    id?: true
    pedidoId?: true
    exameId?: true
    valor?: true
  }

  export type PedidoExameMinAggregateInputType = {
    id?: true
    pedidoId?: true
    exameId?: true
    valor?: true
    status?: true
    observacoes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PedidoExameMaxAggregateInputType = {
    id?: true
    pedidoId?: true
    exameId?: true
    valor?: true
    status?: true
    observacoes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PedidoExameCountAggregateInputType = {
    id?: true
    pedidoId?: true
    exameId?: true
    valor?: true
    status?: true
    observacoes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PedidoExameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PedidoExame to aggregate.
     */
    where?: PedidoExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoExames to fetch.
     */
    orderBy?: PedidoExameOrderByWithRelationInput | PedidoExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoExames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoExames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PedidoExames
    **/
    _count?: true | PedidoExameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoExameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoExameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoExameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoExameMaxAggregateInputType
  }

  export type GetPedidoExameAggregateType<T extends PedidoExameAggregateArgs> = {
        [P in keyof T & keyof AggregatePedidoExame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedidoExame[P]>
      : GetScalarType<T[P], AggregatePedidoExame[P]>
  }




  export type PedidoExameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoExameWhereInput
    orderBy?: PedidoExameOrderByWithAggregationInput | PedidoExameOrderByWithAggregationInput[]
    by: PedidoExameScalarFieldEnum[] | PedidoExameScalarFieldEnum
    having?: PedidoExameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoExameCountAggregateInputType | true
    _avg?: PedidoExameAvgAggregateInputType
    _sum?: PedidoExameSumAggregateInputType
    _min?: PedidoExameMinAggregateInputType
    _max?: PedidoExameMaxAggregateInputType
  }

  export type PedidoExameGroupByOutputType = {
    id: number
    pedidoId: number
    exameId: number
    valor: Decimal | null
    status: $Enums.StatusExame
    observacoes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PedidoExameCountAggregateOutputType | null
    _avg: PedidoExameAvgAggregateOutputType | null
    _sum: PedidoExameSumAggregateOutputType | null
    _min: PedidoExameMinAggregateOutputType | null
    _max: PedidoExameMaxAggregateOutputType | null
  }

  type GetPedidoExameGroupByPayload<T extends PedidoExameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoExameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoExameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoExameGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoExameGroupByOutputType[P]>
        }
      >
    >


  export type PedidoExameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    exameId?: boolean
    valor?: boolean
    status?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    exame?: boolean | ExameDefaultArgs<ExtArgs>
    resultados?: boolean | PedidoExame$resultadosArgs<ExtArgs>
    _count?: boolean | PedidoExameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedidoExame"]>

  export type PedidoExameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    exameId?: boolean
    valor?: boolean
    status?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    exame?: boolean | ExameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedidoExame"]>

  export type PedidoExameSelectScalar = {
    id?: boolean
    pedidoId?: boolean
    exameId?: boolean
    valor?: boolean
    status?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PedidoExameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    exame?: boolean | ExameDefaultArgs<ExtArgs>
    resultados?: boolean | PedidoExame$resultadosArgs<ExtArgs>
    _count?: boolean | PedidoExameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PedidoExameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    exame?: boolean | ExameDefaultArgs<ExtArgs>
  }

  export type $PedidoExamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PedidoExame"
    objects: {
      pedido: Prisma.$PedidoPayload<ExtArgs>
      exame: Prisma.$ExamePayload<ExtArgs>
      resultados: Prisma.$ResultadoExamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pedidoId: number
      exameId: number
      valor: Prisma.Decimal | null
      status: $Enums.StatusExame
      observacoes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pedidoExame"]>
    composites: {}
  }

  type PedidoExameGetPayload<S extends boolean | null | undefined | PedidoExameDefaultArgs> = $Result.GetResult<Prisma.$PedidoExamePayload, S>

  type PedidoExameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PedidoExameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PedidoExameCountAggregateInputType | true
    }

  export interface PedidoExameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PedidoExame'], meta: { name: 'PedidoExame' } }
    /**
     * Find zero or one PedidoExame that matches the filter.
     * @param {PedidoExameFindUniqueArgs} args - Arguments to find a PedidoExame
     * @example
     * // Get one PedidoExame
     * const pedidoExame = await prisma.pedidoExame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PedidoExameFindUniqueArgs>(args: SelectSubset<T, PedidoExameFindUniqueArgs<ExtArgs>>): Prisma__PedidoExameClient<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PedidoExame that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PedidoExameFindUniqueOrThrowArgs} args - Arguments to find a PedidoExame
     * @example
     * // Get one PedidoExame
     * const pedidoExame = await prisma.pedidoExame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PedidoExameFindUniqueOrThrowArgs>(args: SelectSubset<T, PedidoExameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PedidoExameClient<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PedidoExame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoExameFindFirstArgs} args - Arguments to find a PedidoExame
     * @example
     * // Get one PedidoExame
     * const pedidoExame = await prisma.pedidoExame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PedidoExameFindFirstArgs>(args?: SelectSubset<T, PedidoExameFindFirstArgs<ExtArgs>>): Prisma__PedidoExameClient<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PedidoExame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoExameFindFirstOrThrowArgs} args - Arguments to find a PedidoExame
     * @example
     * // Get one PedidoExame
     * const pedidoExame = await prisma.pedidoExame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PedidoExameFindFirstOrThrowArgs>(args?: SelectSubset<T, PedidoExameFindFirstOrThrowArgs<ExtArgs>>): Prisma__PedidoExameClient<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PedidoExames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoExameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PedidoExames
     * const pedidoExames = await prisma.pedidoExame.findMany()
     * 
     * // Get first 10 PedidoExames
     * const pedidoExames = await prisma.pedidoExame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoExameWithIdOnly = await prisma.pedidoExame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PedidoExameFindManyArgs>(args?: SelectSubset<T, PedidoExameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PedidoExame.
     * @param {PedidoExameCreateArgs} args - Arguments to create a PedidoExame.
     * @example
     * // Create one PedidoExame
     * const PedidoExame = await prisma.pedidoExame.create({
     *   data: {
     *     // ... data to create a PedidoExame
     *   }
     * })
     * 
     */
    create<T extends PedidoExameCreateArgs>(args: SelectSubset<T, PedidoExameCreateArgs<ExtArgs>>): Prisma__PedidoExameClient<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PedidoExames.
     * @param {PedidoExameCreateManyArgs} args - Arguments to create many PedidoExames.
     * @example
     * // Create many PedidoExames
     * const pedidoExame = await prisma.pedidoExame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PedidoExameCreateManyArgs>(args?: SelectSubset<T, PedidoExameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PedidoExames and returns the data saved in the database.
     * @param {PedidoExameCreateManyAndReturnArgs} args - Arguments to create many PedidoExames.
     * @example
     * // Create many PedidoExames
     * const pedidoExame = await prisma.pedidoExame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PedidoExames and only return the `id`
     * const pedidoExameWithIdOnly = await prisma.pedidoExame.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PedidoExameCreateManyAndReturnArgs>(args?: SelectSubset<T, PedidoExameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PedidoExame.
     * @param {PedidoExameDeleteArgs} args - Arguments to delete one PedidoExame.
     * @example
     * // Delete one PedidoExame
     * const PedidoExame = await prisma.pedidoExame.delete({
     *   where: {
     *     // ... filter to delete one PedidoExame
     *   }
     * })
     * 
     */
    delete<T extends PedidoExameDeleteArgs>(args: SelectSubset<T, PedidoExameDeleteArgs<ExtArgs>>): Prisma__PedidoExameClient<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PedidoExame.
     * @param {PedidoExameUpdateArgs} args - Arguments to update one PedidoExame.
     * @example
     * // Update one PedidoExame
     * const pedidoExame = await prisma.pedidoExame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PedidoExameUpdateArgs>(args: SelectSubset<T, PedidoExameUpdateArgs<ExtArgs>>): Prisma__PedidoExameClient<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PedidoExames.
     * @param {PedidoExameDeleteManyArgs} args - Arguments to filter PedidoExames to delete.
     * @example
     * // Delete a few PedidoExames
     * const { count } = await prisma.pedidoExame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PedidoExameDeleteManyArgs>(args?: SelectSubset<T, PedidoExameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PedidoExames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoExameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PedidoExames
     * const pedidoExame = await prisma.pedidoExame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PedidoExameUpdateManyArgs>(args: SelectSubset<T, PedidoExameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PedidoExame.
     * @param {PedidoExameUpsertArgs} args - Arguments to update or create a PedidoExame.
     * @example
     * // Update or create a PedidoExame
     * const pedidoExame = await prisma.pedidoExame.upsert({
     *   create: {
     *     // ... data to create a PedidoExame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PedidoExame we want to update
     *   }
     * })
     */
    upsert<T extends PedidoExameUpsertArgs>(args: SelectSubset<T, PedidoExameUpsertArgs<ExtArgs>>): Prisma__PedidoExameClient<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PedidoExames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoExameCountArgs} args - Arguments to filter PedidoExames to count.
     * @example
     * // Count the number of PedidoExames
     * const count = await prisma.pedidoExame.count({
     *   where: {
     *     // ... the filter for the PedidoExames we want to count
     *   }
     * })
    **/
    count<T extends PedidoExameCountArgs>(
      args?: Subset<T, PedidoExameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoExameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PedidoExame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoExameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoExameAggregateArgs>(args: Subset<T, PedidoExameAggregateArgs>): Prisma.PrismaPromise<GetPedidoExameAggregateType<T>>

    /**
     * Group by PedidoExame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoExameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoExameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoExameGroupByArgs['orderBy'] }
        : { orderBy?: PedidoExameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoExameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoExameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PedidoExame model
   */
  readonly fields: PedidoExameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PedidoExame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoExameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedido<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exame<T extends ExameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExameDefaultArgs<ExtArgs>>): Prisma__ExameClient<$Result.GetResult<Prisma.$ExamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resultados<T extends PedidoExame$resultadosArgs<ExtArgs> = {}>(args?: Subset<T, PedidoExame$resultadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultadoExamePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PedidoExame model
   */ 
  interface PedidoExameFieldRefs {
    readonly id: FieldRef<"PedidoExame", 'Int'>
    readonly pedidoId: FieldRef<"PedidoExame", 'Int'>
    readonly exameId: FieldRef<"PedidoExame", 'Int'>
    readonly valor: FieldRef<"PedidoExame", 'Decimal'>
    readonly status: FieldRef<"PedidoExame", 'StatusExame'>
    readonly observacoes: FieldRef<"PedidoExame", 'String'>
    readonly createdAt: FieldRef<"PedidoExame", 'DateTime'>
    readonly updatedAt: FieldRef<"PedidoExame", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PedidoExame findUnique
   */
  export type PedidoExameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameInclude<ExtArgs> | null
    /**
     * Filter, which PedidoExame to fetch.
     */
    where: PedidoExameWhereUniqueInput
  }

  /**
   * PedidoExame findUniqueOrThrow
   */
  export type PedidoExameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameInclude<ExtArgs> | null
    /**
     * Filter, which PedidoExame to fetch.
     */
    where: PedidoExameWhereUniqueInput
  }

  /**
   * PedidoExame findFirst
   */
  export type PedidoExameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameInclude<ExtArgs> | null
    /**
     * Filter, which PedidoExame to fetch.
     */
    where?: PedidoExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoExames to fetch.
     */
    orderBy?: PedidoExameOrderByWithRelationInput | PedidoExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoExames.
     */
    cursor?: PedidoExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoExames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoExames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoExames.
     */
    distinct?: PedidoExameScalarFieldEnum | PedidoExameScalarFieldEnum[]
  }

  /**
   * PedidoExame findFirstOrThrow
   */
  export type PedidoExameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameInclude<ExtArgs> | null
    /**
     * Filter, which PedidoExame to fetch.
     */
    where?: PedidoExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoExames to fetch.
     */
    orderBy?: PedidoExameOrderByWithRelationInput | PedidoExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoExames.
     */
    cursor?: PedidoExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoExames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoExames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoExames.
     */
    distinct?: PedidoExameScalarFieldEnum | PedidoExameScalarFieldEnum[]
  }

  /**
   * PedidoExame findMany
   */
  export type PedidoExameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameInclude<ExtArgs> | null
    /**
     * Filter, which PedidoExames to fetch.
     */
    where?: PedidoExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoExames to fetch.
     */
    orderBy?: PedidoExameOrderByWithRelationInput | PedidoExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PedidoExames.
     */
    cursor?: PedidoExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoExames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoExames.
     */
    skip?: number
    distinct?: PedidoExameScalarFieldEnum | PedidoExameScalarFieldEnum[]
  }

  /**
   * PedidoExame create
   */
  export type PedidoExameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameInclude<ExtArgs> | null
    /**
     * The data needed to create a PedidoExame.
     */
    data: XOR<PedidoExameCreateInput, PedidoExameUncheckedCreateInput>
  }

  /**
   * PedidoExame createMany
   */
  export type PedidoExameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PedidoExames.
     */
    data: PedidoExameCreateManyInput | PedidoExameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PedidoExame createManyAndReturn
   */
  export type PedidoExameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PedidoExames.
     */
    data: PedidoExameCreateManyInput | PedidoExameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PedidoExame update
   */
  export type PedidoExameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameInclude<ExtArgs> | null
    /**
     * The data needed to update a PedidoExame.
     */
    data: XOR<PedidoExameUpdateInput, PedidoExameUncheckedUpdateInput>
    /**
     * Choose, which PedidoExame to update.
     */
    where: PedidoExameWhereUniqueInput
  }

  /**
   * PedidoExame updateMany
   */
  export type PedidoExameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PedidoExames.
     */
    data: XOR<PedidoExameUpdateManyMutationInput, PedidoExameUncheckedUpdateManyInput>
    /**
     * Filter which PedidoExames to update
     */
    where?: PedidoExameWhereInput
  }

  /**
   * PedidoExame upsert
   */
  export type PedidoExameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameInclude<ExtArgs> | null
    /**
     * The filter to search for the PedidoExame to update in case it exists.
     */
    where: PedidoExameWhereUniqueInput
    /**
     * In case the PedidoExame found by the `where` argument doesn't exist, create a new PedidoExame with this data.
     */
    create: XOR<PedidoExameCreateInput, PedidoExameUncheckedCreateInput>
    /**
     * In case the PedidoExame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoExameUpdateInput, PedidoExameUncheckedUpdateInput>
  }

  /**
   * PedidoExame delete
   */
  export type PedidoExameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameInclude<ExtArgs> | null
    /**
     * Filter which PedidoExame to delete.
     */
    where: PedidoExameWhereUniqueInput
  }

  /**
   * PedidoExame deleteMany
   */
  export type PedidoExameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PedidoExames to delete
     */
    where?: PedidoExameWhereInput
  }

  /**
   * PedidoExame.resultados
   */
  export type PedidoExame$resultadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameInclude<ExtArgs> | null
    where?: ResultadoExameWhereInput
    orderBy?: ResultadoExameOrderByWithRelationInput | ResultadoExameOrderByWithRelationInput[]
    cursor?: ResultadoExameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultadoExameScalarFieldEnum | ResultadoExameScalarFieldEnum[]
  }

  /**
   * PedidoExame without action
   */
  export type PedidoExameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoExame
     */
    select?: PedidoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoExameInclude<ExtArgs> | null
  }


  /**
   * Model ResultadoExame
   */

  export type AggregateResultadoExame = {
    _count: ResultadoExameCountAggregateOutputType | null
    _avg: ResultadoExameAvgAggregateOutputType | null
    _sum: ResultadoExameSumAggregateOutputType | null
    _min: ResultadoExameMinAggregateOutputType | null
    _max: ResultadoExameMaxAggregateOutputType | null
  }

  export type ResultadoExameAvgAggregateOutputType = {
    id: number | null
    pedidoExameId: number | null
    parametroId: number | null
  }

  export type ResultadoExameSumAggregateOutputType = {
    id: number | null
    pedidoExameId: number | null
    parametroId: number | null
  }

  export type ResultadoExameMinAggregateOutputType = {
    id: number | null
    pedidoExameId: number | null
    parametroId: number | null
    valor: string | null
    observacao: string | null
    alterado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultadoExameMaxAggregateOutputType = {
    id: number | null
    pedidoExameId: number | null
    parametroId: number | null
    valor: string | null
    observacao: string | null
    alterado: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultadoExameCountAggregateOutputType = {
    id: number
    pedidoExameId: number
    parametroId: number
    valor: number
    observacao: number
    alterado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResultadoExameAvgAggregateInputType = {
    id?: true
    pedidoExameId?: true
    parametroId?: true
  }

  export type ResultadoExameSumAggregateInputType = {
    id?: true
    pedidoExameId?: true
    parametroId?: true
  }

  export type ResultadoExameMinAggregateInputType = {
    id?: true
    pedidoExameId?: true
    parametroId?: true
    valor?: true
    observacao?: true
    alterado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultadoExameMaxAggregateInputType = {
    id?: true
    pedidoExameId?: true
    parametroId?: true
    valor?: true
    observacao?: true
    alterado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultadoExameCountAggregateInputType = {
    id?: true
    pedidoExameId?: true
    parametroId?: true
    valor?: true
    observacao?: true
    alterado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResultadoExameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultadoExame to aggregate.
     */
    where?: ResultadoExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultadoExames to fetch.
     */
    orderBy?: ResultadoExameOrderByWithRelationInput | ResultadoExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResultadoExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultadoExames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultadoExames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResultadoExames
    **/
    _count?: true | ResultadoExameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResultadoExameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResultadoExameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResultadoExameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResultadoExameMaxAggregateInputType
  }

  export type GetResultadoExameAggregateType<T extends ResultadoExameAggregateArgs> = {
        [P in keyof T & keyof AggregateResultadoExame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResultadoExame[P]>
      : GetScalarType<T[P], AggregateResultadoExame[P]>
  }




  export type ResultadoExameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultadoExameWhereInput
    orderBy?: ResultadoExameOrderByWithAggregationInput | ResultadoExameOrderByWithAggregationInput[]
    by: ResultadoExameScalarFieldEnum[] | ResultadoExameScalarFieldEnum
    having?: ResultadoExameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResultadoExameCountAggregateInputType | true
    _avg?: ResultadoExameAvgAggregateInputType
    _sum?: ResultadoExameSumAggregateInputType
    _min?: ResultadoExameMinAggregateInputType
    _max?: ResultadoExameMaxAggregateInputType
  }

  export type ResultadoExameGroupByOutputType = {
    id: number
    pedidoExameId: number
    parametroId: number
    valor: string | null
    observacao: string | null
    alterado: boolean
    createdAt: Date
    updatedAt: Date
    _count: ResultadoExameCountAggregateOutputType | null
    _avg: ResultadoExameAvgAggregateOutputType | null
    _sum: ResultadoExameSumAggregateOutputType | null
    _min: ResultadoExameMinAggregateOutputType | null
    _max: ResultadoExameMaxAggregateOutputType | null
  }

  type GetResultadoExameGroupByPayload<T extends ResultadoExameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResultadoExameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResultadoExameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResultadoExameGroupByOutputType[P]>
            : GetScalarType<T[P], ResultadoExameGroupByOutputType[P]>
        }
      >
    >


  export type ResultadoExameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoExameId?: boolean
    parametroId?: boolean
    valor?: boolean
    observacao?: boolean
    alterado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pedidoExame?: boolean | PedidoExameDefaultArgs<ExtArgs>
    parametro?: boolean | ParametroExameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultadoExame"]>

  export type ResultadoExameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoExameId?: boolean
    parametroId?: boolean
    valor?: boolean
    observacao?: boolean
    alterado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pedidoExame?: boolean | PedidoExameDefaultArgs<ExtArgs>
    parametro?: boolean | ParametroExameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultadoExame"]>

  export type ResultadoExameSelectScalar = {
    id?: boolean
    pedidoExameId?: boolean
    parametroId?: boolean
    valor?: boolean
    observacao?: boolean
    alterado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResultadoExameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidoExame?: boolean | PedidoExameDefaultArgs<ExtArgs>
    parametro?: boolean | ParametroExameDefaultArgs<ExtArgs>
  }
  export type ResultadoExameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedidoExame?: boolean | PedidoExameDefaultArgs<ExtArgs>
    parametro?: boolean | ParametroExameDefaultArgs<ExtArgs>
  }

  export type $ResultadoExamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResultadoExame"
    objects: {
      pedidoExame: Prisma.$PedidoExamePayload<ExtArgs>
      parametro: Prisma.$ParametroExamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pedidoExameId: number
      parametroId: number
      valor: string | null
      observacao: string | null
      alterado: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resultadoExame"]>
    composites: {}
  }

  type ResultadoExameGetPayload<S extends boolean | null | undefined | ResultadoExameDefaultArgs> = $Result.GetResult<Prisma.$ResultadoExamePayload, S>

  type ResultadoExameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResultadoExameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResultadoExameCountAggregateInputType | true
    }

  export interface ResultadoExameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResultadoExame'], meta: { name: 'ResultadoExame' } }
    /**
     * Find zero or one ResultadoExame that matches the filter.
     * @param {ResultadoExameFindUniqueArgs} args - Arguments to find a ResultadoExame
     * @example
     * // Get one ResultadoExame
     * const resultadoExame = await prisma.resultadoExame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResultadoExameFindUniqueArgs>(args: SelectSubset<T, ResultadoExameFindUniqueArgs<ExtArgs>>): Prisma__ResultadoExameClient<$Result.GetResult<Prisma.$ResultadoExamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResultadoExame that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResultadoExameFindUniqueOrThrowArgs} args - Arguments to find a ResultadoExame
     * @example
     * // Get one ResultadoExame
     * const resultadoExame = await prisma.resultadoExame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResultadoExameFindUniqueOrThrowArgs>(args: SelectSubset<T, ResultadoExameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResultadoExameClient<$Result.GetResult<Prisma.$ResultadoExamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResultadoExame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultadoExameFindFirstArgs} args - Arguments to find a ResultadoExame
     * @example
     * // Get one ResultadoExame
     * const resultadoExame = await prisma.resultadoExame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResultadoExameFindFirstArgs>(args?: SelectSubset<T, ResultadoExameFindFirstArgs<ExtArgs>>): Prisma__ResultadoExameClient<$Result.GetResult<Prisma.$ResultadoExamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResultadoExame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultadoExameFindFirstOrThrowArgs} args - Arguments to find a ResultadoExame
     * @example
     * // Get one ResultadoExame
     * const resultadoExame = await prisma.resultadoExame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResultadoExameFindFirstOrThrowArgs>(args?: SelectSubset<T, ResultadoExameFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResultadoExameClient<$Result.GetResult<Prisma.$ResultadoExamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResultadoExames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultadoExameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResultadoExames
     * const resultadoExames = await prisma.resultadoExame.findMany()
     * 
     * // Get first 10 ResultadoExames
     * const resultadoExames = await prisma.resultadoExame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resultadoExameWithIdOnly = await prisma.resultadoExame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResultadoExameFindManyArgs>(args?: SelectSubset<T, ResultadoExameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultadoExamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResultadoExame.
     * @param {ResultadoExameCreateArgs} args - Arguments to create a ResultadoExame.
     * @example
     * // Create one ResultadoExame
     * const ResultadoExame = await prisma.resultadoExame.create({
     *   data: {
     *     // ... data to create a ResultadoExame
     *   }
     * })
     * 
     */
    create<T extends ResultadoExameCreateArgs>(args: SelectSubset<T, ResultadoExameCreateArgs<ExtArgs>>): Prisma__ResultadoExameClient<$Result.GetResult<Prisma.$ResultadoExamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResultadoExames.
     * @param {ResultadoExameCreateManyArgs} args - Arguments to create many ResultadoExames.
     * @example
     * // Create many ResultadoExames
     * const resultadoExame = await prisma.resultadoExame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResultadoExameCreateManyArgs>(args?: SelectSubset<T, ResultadoExameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResultadoExames and returns the data saved in the database.
     * @param {ResultadoExameCreateManyAndReturnArgs} args - Arguments to create many ResultadoExames.
     * @example
     * // Create many ResultadoExames
     * const resultadoExame = await prisma.resultadoExame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResultadoExames and only return the `id`
     * const resultadoExameWithIdOnly = await prisma.resultadoExame.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResultadoExameCreateManyAndReturnArgs>(args?: SelectSubset<T, ResultadoExameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultadoExamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ResultadoExame.
     * @param {ResultadoExameDeleteArgs} args - Arguments to delete one ResultadoExame.
     * @example
     * // Delete one ResultadoExame
     * const ResultadoExame = await prisma.resultadoExame.delete({
     *   where: {
     *     // ... filter to delete one ResultadoExame
     *   }
     * })
     * 
     */
    delete<T extends ResultadoExameDeleteArgs>(args: SelectSubset<T, ResultadoExameDeleteArgs<ExtArgs>>): Prisma__ResultadoExameClient<$Result.GetResult<Prisma.$ResultadoExamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResultadoExame.
     * @param {ResultadoExameUpdateArgs} args - Arguments to update one ResultadoExame.
     * @example
     * // Update one ResultadoExame
     * const resultadoExame = await prisma.resultadoExame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResultadoExameUpdateArgs>(args: SelectSubset<T, ResultadoExameUpdateArgs<ExtArgs>>): Prisma__ResultadoExameClient<$Result.GetResult<Prisma.$ResultadoExamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResultadoExames.
     * @param {ResultadoExameDeleteManyArgs} args - Arguments to filter ResultadoExames to delete.
     * @example
     * // Delete a few ResultadoExames
     * const { count } = await prisma.resultadoExame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResultadoExameDeleteManyArgs>(args?: SelectSubset<T, ResultadoExameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResultadoExames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultadoExameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResultadoExames
     * const resultadoExame = await prisma.resultadoExame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResultadoExameUpdateManyArgs>(args: SelectSubset<T, ResultadoExameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResultadoExame.
     * @param {ResultadoExameUpsertArgs} args - Arguments to update or create a ResultadoExame.
     * @example
     * // Update or create a ResultadoExame
     * const resultadoExame = await prisma.resultadoExame.upsert({
     *   create: {
     *     // ... data to create a ResultadoExame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResultadoExame we want to update
     *   }
     * })
     */
    upsert<T extends ResultadoExameUpsertArgs>(args: SelectSubset<T, ResultadoExameUpsertArgs<ExtArgs>>): Prisma__ResultadoExameClient<$Result.GetResult<Prisma.$ResultadoExamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResultadoExames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultadoExameCountArgs} args - Arguments to filter ResultadoExames to count.
     * @example
     * // Count the number of ResultadoExames
     * const count = await prisma.resultadoExame.count({
     *   where: {
     *     // ... the filter for the ResultadoExames we want to count
     *   }
     * })
    **/
    count<T extends ResultadoExameCountArgs>(
      args?: Subset<T, ResultadoExameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResultadoExameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResultadoExame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultadoExameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResultadoExameAggregateArgs>(args: Subset<T, ResultadoExameAggregateArgs>): Prisma.PrismaPromise<GetResultadoExameAggregateType<T>>

    /**
     * Group by ResultadoExame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultadoExameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResultadoExameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResultadoExameGroupByArgs['orderBy'] }
        : { orderBy?: ResultadoExameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResultadoExameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResultadoExameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResultadoExame model
   */
  readonly fields: ResultadoExameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResultadoExame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResultadoExameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedidoExame<T extends PedidoExameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoExameDefaultArgs<ExtArgs>>): Prisma__PedidoExameClient<$Result.GetResult<Prisma.$PedidoExamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parametro<T extends ParametroExameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParametroExameDefaultArgs<ExtArgs>>): Prisma__ParametroExameClient<$Result.GetResult<Prisma.$ParametroExamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResultadoExame model
   */ 
  interface ResultadoExameFieldRefs {
    readonly id: FieldRef<"ResultadoExame", 'Int'>
    readonly pedidoExameId: FieldRef<"ResultadoExame", 'Int'>
    readonly parametroId: FieldRef<"ResultadoExame", 'Int'>
    readonly valor: FieldRef<"ResultadoExame", 'String'>
    readonly observacao: FieldRef<"ResultadoExame", 'String'>
    readonly alterado: FieldRef<"ResultadoExame", 'Boolean'>
    readonly createdAt: FieldRef<"ResultadoExame", 'DateTime'>
    readonly updatedAt: FieldRef<"ResultadoExame", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResultadoExame findUnique
   */
  export type ResultadoExameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameInclude<ExtArgs> | null
    /**
     * Filter, which ResultadoExame to fetch.
     */
    where: ResultadoExameWhereUniqueInput
  }

  /**
   * ResultadoExame findUniqueOrThrow
   */
  export type ResultadoExameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameInclude<ExtArgs> | null
    /**
     * Filter, which ResultadoExame to fetch.
     */
    where: ResultadoExameWhereUniqueInput
  }

  /**
   * ResultadoExame findFirst
   */
  export type ResultadoExameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameInclude<ExtArgs> | null
    /**
     * Filter, which ResultadoExame to fetch.
     */
    where?: ResultadoExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultadoExames to fetch.
     */
    orderBy?: ResultadoExameOrderByWithRelationInput | ResultadoExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultadoExames.
     */
    cursor?: ResultadoExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultadoExames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultadoExames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultadoExames.
     */
    distinct?: ResultadoExameScalarFieldEnum | ResultadoExameScalarFieldEnum[]
  }

  /**
   * ResultadoExame findFirstOrThrow
   */
  export type ResultadoExameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameInclude<ExtArgs> | null
    /**
     * Filter, which ResultadoExame to fetch.
     */
    where?: ResultadoExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultadoExames to fetch.
     */
    orderBy?: ResultadoExameOrderByWithRelationInput | ResultadoExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultadoExames.
     */
    cursor?: ResultadoExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultadoExames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultadoExames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultadoExames.
     */
    distinct?: ResultadoExameScalarFieldEnum | ResultadoExameScalarFieldEnum[]
  }

  /**
   * ResultadoExame findMany
   */
  export type ResultadoExameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameInclude<ExtArgs> | null
    /**
     * Filter, which ResultadoExames to fetch.
     */
    where?: ResultadoExameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultadoExames to fetch.
     */
    orderBy?: ResultadoExameOrderByWithRelationInput | ResultadoExameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResultadoExames.
     */
    cursor?: ResultadoExameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultadoExames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultadoExames.
     */
    skip?: number
    distinct?: ResultadoExameScalarFieldEnum | ResultadoExameScalarFieldEnum[]
  }

  /**
   * ResultadoExame create
   */
  export type ResultadoExameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameInclude<ExtArgs> | null
    /**
     * The data needed to create a ResultadoExame.
     */
    data: XOR<ResultadoExameCreateInput, ResultadoExameUncheckedCreateInput>
  }

  /**
   * ResultadoExame createMany
   */
  export type ResultadoExameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResultadoExames.
     */
    data: ResultadoExameCreateManyInput | ResultadoExameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResultadoExame createManyAndReturn
   */
  export type ResultadoExameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ResultadoExames.
     */
    data: ResultadoExameCreateManyInput | ResultadoExameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResultadoExame update
   */
  export type ResultadoExameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameInclude<ExtArgs> | null
    /**
     * The data needed to update a ResultadoExame.
     */
    data: XOR<ResultadoExameUpdateInput, ResultadoExameUncheckedUpdateInput>
    /**
     * Choose, which ResultadoExame to update.
     */
    where: ResultadoExameWhereUniqueInput
  }

  /**
   * ResultadoExame updateMany
   */
  export type ResultadoExameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResultadoExames.
     */
    data: XOR<ResultadoExameUpdateManyMutationInput, ResultadoExameUncheckedUpdateManyInput>
    /**
     * Filter which ResultadoExames to update
     */
    where?: ResultadoExameWhereInput
  }

  /**
   * ResultadoExame upsert
   */
  export type ResultadoExameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameInclude<ExtArgs> | null
    /**
     * The filter to search for the ResultadoExame to update in case it exists.
     */
    where: ResultadoExameWhereUniqueInput
    /**
     * In case the ResultadoExame found by the `where` argument doesn't exist, create a new ResultadoExame with this data.
     */
    create: XOR<ResultadoExameCreateInput, ResultadoExameUncheckedCreateInput>
    /**
     * In case the ResultadoExame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResultadoExameUpdateInput, ResultadoExameUncheckedUpdateInput>
  }

  /**
   * ResultadoExame delete
   */
  export type ResultadoExameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameInclude<ExtArgs> | null
    /**
     * Filter which ResultadoExame to delete.
     */
    where: ResultadoExameWhereUniqueInput
  }

  /**
   * ResultadoExame deleteMany
   */
  export type ResultadoExameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultadoExames to delete
     */
    where?: ResultadoExameWhereInput
  }

  /**
   * ResultadoExame without action
   */
  export type ResultadoExameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultadoExame
     */
    select?: ResultadoExameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultadoExameInclude<ExtArgs> | null
  }


  /**
   * Model Laudo
   */

  export type AggregateLaudo = {
    _count: LaudoCountAggregateOutputType | null
    _avg: LaudoAvgAggregateOutputType | null
    _sum: LaudoSumAggregateOutputType | null
    _min: LaudoMinAggregateOutputType | null
    _max: LaudoMaxAggregateOutputType | null
  }

  export type LaudoAvgAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    profissionalId: number | null
    usuarioId: number | null
  }

  export type LaudoSumAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    profissionalId: number | null
    usuarioId: number | null
  }

  export type LaudoMinAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    profissionalId: number | null
    usuarioId: number | null
    conteudo: string | null
    observacoes: string | null
    dataLiberacao: Date | null
    assinado: boolean | null
    enviado: boolean | null
    dataEnvio: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaudoMaxAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    profissionalId: number | null
    usuarioId: number | null
    conteudo: string | null
    observacoes: string | null
    dataLiberacao: Date | null
    assinado: boolean | null
    enviado: boolean | null
    dataEnvio: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaudoCountAggregateOutputType = {
    id: number
    pedidoId: number
    profissionalId: number
    usuarioId: number
    conteudo: number
    observacoes: number
    dataLiberacao: number
    assinado: number
    enviado: number
    dataEnvio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaudoAvgAggregateInputType = {
    id?: true
    pedidoId?: true
    profissionalId?: true
    usuarioId?: true
  }

  export type LaudoSumAggregateInputType = {
    id?: true
    pedidoId?: true
    profissionalId?: true
    usuarioId?: true
  }

  export type LaudoMinAggregateInputType = {
    id?: true
    pedidoId?: true
    profissionalId?: true
    usuarioId?: true
    conteudo?: true
    observacoes?: true
    dataLiberacao?: true
    assinado?: true
    enviado?: true
    dataEnvio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaudoMaxAggregateInputType = {
    id?: true
    pedidoId?: true
    profissionalId?: true
    usuarioId?: true
    conteudo?: true
    observacoes?: true
    dataLiberacao?: true
    assinado?: true
    enviado?: true
    dataEnvio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaudoCountAggregateInputType = {
    id?: true
    pedidoId?: true
    profissionalId?: true
    usuarioId?: true
    conteudo?: true
    observacoes?: true
    dataLiberacao?: true
    assinado?: true
    enviado?: true
    dataEnvio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaudoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Laudo to aggregate.
     */
    where?: LaudoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Laudos to fetch.
     */
    orderBy?: LaudoOrderByWithRelationInput | LaudoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaudoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Laudos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Laudos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Laudos
    **/
    _count?: true | LaudoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaudoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaudoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaudoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaudoMaxAggregateInputType
  }

  export type GetLaudoAggregateType<T extends LaudoAggregateArgs> = {
        [P in keyof T & keyof AggregateLaudo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaudo[P]>
      : GetScalarType<T[P], AggregateLaudo[P]>
  }




  export type LaudoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaudoWhereInput
    orderBy?: LaudoOrderByWithAggregationInput | LaudoOrderByWithAggregationInput[]
    by: LaudoScalarFieldEnum[] | LaudoScalarFieldEnum
    having?: LaudoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaudoCountAggregateInputType | true
    _avg?: LaudoAvgAggregateInputType
    _sum?: LaudoSumAggregateInputType
    _min?: LaudoMinAggregateInputType
    _max?: LaudoMaxAggregateInputType
  }

  export type LaudoGroupByOutputType = {
    id: number
    pedidoId: number
    profissionalId: number | null
    usuarioId: number | null
    conteudo: string
    observacoes: string | null
    dataLiberacao: Date | null
    assinado: boolean
    enviado: boolean
    dataEnvio: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LaudoCountAggregateOutputType | null
    _avg: LaudoAvgAggregateOutputType | null
    _sum: LaudoSumAggregateOutputType | null
    _min: LaudoMinAggregateOutputType | null
    _max: LaudoMaxAggregateOutputType | null
  }

  type GetLaudoGroupByPayload<T extends LaudoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaudoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaudoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaudoGroupByOutputType[P]>
            : GetScalarType<T[P], LaudoGroupByOutputType[P]>
        }
      >
    >


  export type LaudoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    profissionalId?: boolean
    usuarioId?: boolean
    conteudo?: boolean
    observacoes?: boolean
    dataLiberacao?: boolean
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    profissional?: boolean | Laudo$profissionalArgs<ExtArgs>
    usuario?: boolean | Laudo$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["laudo"]>

  export type LaudoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    profissionalId?: boolean
    usuarioId?: boolean
    conteudo?: boolean
    observacoes?: boolean
    dataLiberacao?: boolean
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    profissional?: boolean | Laudo$profissionalArgs<ExtArgs>
    usuario?: boolean | Laudo$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["laudo"]>

  export type LaudoSelectScalar = {
    id?: boolean
    pedidoId?: boolean
    profissionalId?: boolean
    usuarioId?: boolean
    conteudo?: boolean
    observacoes?: boolean
    dataLiberacao?: boolean
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LaudoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    profissional?: boolean | Laudo$profissionalArgs<ExtArgs>
    usuario?: boolean | Laudo$usuarioArgs<ExtArgs>
  }
  export type LaudoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | PedidoDefaultArgs<ExtArgs>
    profissional?: boolean | Laudo$profissionalArgs<ExtArgs>
    usuario?: boolean | Laudo$usuarioArgs<ExtArgs>
  }

  export type $LaudoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Laudo"
    objects: {
      pedido: Prisma.$PedidoPayload<ExtArgs>
      profissional: Prisma.$ProfissionalPayload<ExtArgs> | null
      usuario: Prisma.$UsuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pedidoId: number
      profissionalId: number | null
      usuarioId: number | null
      conteudo: string
      observacoes: string | null
      dataLiberacao: Date | null
      assinado: boolean
      enviado: boolean
      dataEnvio: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["laudo"]>
    composites: {}
  }

  type LaudoGetPayload<S extends boolean | null | undefined | LaudoDefaultArgs> = $Result.GetResult<Prisma.$LaudoPayload, S>

  type LaudoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LaudoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LaudoCountAggregateInputType | true
    }

  export interface LaudoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Laudo'], meta: { name: 'Laudo' } }
    /**
     * Find zero or one Laudo that matches the filter.
     * @param {LaudoFindUniqueArgs} args - Arguments to find a Laudo
     * @example
     * // Get one Laudo
     * const laudo = await prisma.laudo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaudoFindUniqueArgs>(args: SelectSubset<T, LaudoFindUniqueArgs<ExtArgs>>): Prisma__LaudoClient<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Laudo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LaudoFindUniqueOrThrowArgs} args - Arguments to find a Laudo
     * @example
     * // Get one Laudo
     * const laudo = await prisma.laudo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaudoFindUniqueOrThrowArgs>(args: SelectSubset<T, LaudoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaudoClient<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Laudo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaudoFindFirstArgs} args - Arguments to find a Laudo
     * @example
     * // Get one Laudo
     * const laudo = await prisma.laudo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaudoFindFirstArgs>(args?: SelectSubset<T, LaudoFindFirstArgs<ExtArgs>>): Prisma__LaudoClient<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Laudo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaudoFindFirstOrThrowArgs} args - Arguments to find a Laudo
     * @example
     * // Get one Laudo
     * const laudo = await prisma.laudo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaudoFindFirstOrThrowArgs>(args?: SelectSubset<T, LaudoFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaudoClient<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Laudos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaudoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Laudos
     * const laudos = await prisma.laudo.findMany()
     * 
     * // Get first 10 Laudos
     * const laudos = await prisma.laudo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laudoWithIdOnly = await prisma.laudo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaudoFindManyArgs>(args?: SelectSubset<T, LaudoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Laudo.
     * @param {LaudoCreateArgs} args - Arguments to create a Laudo.
     * @example
     * // Create one Laudo
     * const Laudo = await prisma.laudo.create({
     *   data: {
     *     // ... data to create a Laudo
     *   }
     * })
     * 
     */
    create<T extends LaudoCreateArgs>(args: SelectSubset<T, LaudoCreateArgs<ExtArgs>>): Prisma__LaudoClient<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Laudos.
     * @param {LaudoCreateManyArgs} args - Arguments to create many Laudos.
     * @example
     * // Create many Laudos
     * const laudo = await prisma.laudo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaudoCreateManyArgs>(args?: SelectSubset<T, LaudoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Laudos and returns the data saved in the database.
     * @param {LaudoCreateManyAndReturnArgs} args - Arguments to create many Laudos.
     * @example
     * // Create many Laudos
     * const laudo = await prisma.laudo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Laudos and only return the `id`
     * const laudoWithIdOnly = await prisma.laudo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LaudoCreateManyAndReturnArgs>(args?: SelectSubset<T, LaudoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Laudo.
     * @param {LaudoDeleteArgs} args - Arguments to delete one Laudo.
     * @example
     * // Delete one Laudo
     * const Laudo = await prisma.laudo.delete({
     *   where: {
     *     // ... filter to delete one Laudo
     *   }
     * })
     * 
     */
    delete<T extends LaudoDeleteArgs>(args: SelectSubset<T, LaudoDeleteArgs<ExtArgs>>): Prisma__LaudoClient<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Laudo.
     * @param {LaudoUpdateArgs} args - Arguments to update one Laudo.
     * @example
     * // Update one Laudo
     * const laudo = await prisma.laudo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaudoUpdateArgs>(args: SelectSubset<T, LaudoUpdateArgs<ExtArgs>>): Prisma__LaudoClient<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Laudos.
     * @param {LaudoDeleteManyArgs} args - Arguments to filter Laudos to delete.
     * @example
     * // Delete a few Laudos
     * const { count } = await prisma.laudo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaudoDeleteManyArgs>(args?: SelectSubset<T, LaudoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Laudos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaudoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Laudos
     * const laudo = await prisma.laudo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaudoUpdateManyArgs>(args: SelectSubset<T, LaudoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Laudo.
     * @param {LaudoUpsertArgs} args - Arguments to update or create a Laudo.
     * @example
     * // Update or create a Laudo
     * const laudo = await prisma.laudo.upsert({
     *   create: {
     *     // ... data to create a Laudo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Laudo we want to update
     *   }
     * })
     */
    upsert<T extends LaudoUpsertArgs>(args: SelectSubset<T, LaudoUpsertArgs<ExtArgs>>): Prisma__LaudoClient<$Result.GetResult<Prisma.$LaudoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Laudos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaudoCountArgs} args - Arguments to filter Laudos to count.
     * @example
     * // Count the number of Laudos
     * const count = await prisma.laudo.count({
     *   where: {
     *     // ... the filter for the Laudos we want to count
     *   }
     * })
    **/
    count<T extends LaudoCountArgs>(
      args?: Subset<T, LaudoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaudoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Laudo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaudoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaudoAggregateArgs>(args: Subset<T, LaudoAggregateArgs>): Prisma.PrismaPromise<GetLaudoAggregateType<T>>

    /**
     * Group by Laudo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaudoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaudoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaudoGroupByArgs['orderBy'] }
        : { orderBy?: LaudoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaudoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaudoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Laudo model
   */
  readonly fields: LaudoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Laudo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaudoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedido<T extends PedidoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PedidoDefaultArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profissional<T extends Laudo$profissionalArgs<ExtArgs> = {}>(args?: Subset<T, Laudo$profissionalArgs<ExtArgs>>): Prisma__ProfissionalClient<$Result.GetResult<Prisma.$ProfissionalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    usuario<T extends Laudo$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, Laudo$usuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Laudo model
   */ 
  interface LaudoFieldRefs {
    readonly id: FieldRef<"Laudo", 'Int'>
    readonly pedidoId: FieldRef<"Laudo", 'Int'>
    readonly profissionalId: FieldRef<"Laudo", 'Int'>
    readonly usuarioId: FieldRef<"Laudo", 'Int'>
    readonly conteudo: FieldRef<"Laudo", 'String'>
    readonly observacoes: FieldRef<"Laudo", 'String'>
    readonly dataLiberacao: FieldRef<"Laudo", 'DateTime'>
    readonly assinado: FieldRef<"Laudo", 'Boolean'>
    readonly enviado: FieldRef<"Laudo", 'Boolean'>
    readonly dataEnvio: FieldRef<"Laudo", 'DateTime'>
    readonly createdAt: FieldRef<"Laudo", 'DateTime'>
    readonly updatedAt: FieldRef<"Laudo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Laudo findUnique
   */
  export type LaudoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
    /**
     * Filter, which Laudo to fetch.
     */
    where: LaudoWhereUniqueInput
  }

  /**
   * Laudo findUniqueOrThrow
   */
  export type LaudoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
    /**
     * Filter, which Laudo to fetch.
     */
    where: LaudoWhereUniqueInput
  }

  /**
   * Laudo findFirst
   */
  export type LaudoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
    /**
     * Filter, which Laudo to fetch.
     */
    where?: LaudoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Laudos to fetch.
     */
    orderBy?: LaudoOrderByWithRelationInput | LaudoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Laudos.
     */
    cursor?: LaudoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Laudos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Laudos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Laudos.
     */
    distinct?: LaudoScalarFieldEnum | LaudoScalarFieldEnum[]
  }

  /**
   * Laudo findFirstOrThrow
   */
  export type LaudoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
    /**
     * Filter, which Laudo to fetch.
     */
    where?: LaudoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Laudos to fetch.
     */
    orderBy?: LaudoOrderByWithRelationInput | LaudoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Laudos.
     */
    cursor?: LaudoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Laudos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Laudos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Laudos.
     */
    distinct?: LaudoScalarFieldEnum | LaudoScalarFieldEnum[]
  }

  /**
   * Laudo findMany
   */
  export type LaudoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
    /**
     * Filter, which Laudos to fetch.
     */
    where?: LaudoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Laudos to fetch.
     */
    orderBy?: LaudoOrderByWithRelationInput | LaudoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Laudos.
     */
    cursor?: LaudoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Laudos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Laudos.
     */
    skip?: number
    distinct?: LaudoScalarFieldEnum | LaudoScalarFieldEnum[]
  }

  /**
   * Laudo create
   */
  export type LaudoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
    /**
     * The data needed to create a Laudo.
     */
    data: XOR<LaudoCreateInput, LaudoUncheckedCreateInput>
  }

  /**
   * Laudo createMany
   */
  export type LaudoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Laudos.
     */
    data: LaudoCreateManyInput | LaudoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Laudo createManyAndReturn
   */
  export type LaudoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Laudos.
     */
    data: LaudoCreateManyInput | LaudoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Laudo update
   */
  export type LaudoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
    /**
     * The data needed to update a Laudo.
     */
    data: XOR<LaudoUpdateInput, LaudoUncheckedUpdateInput>
    /**
     * Choose, which Laudo to update.
     */
    where: LaudoWhereUniqueInput
  }

  /**
   * Laudo updateMany
   */
  export type LaudoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Laudos.
     */
    data: XOR<LaudoUpdateManyMutationInput, LaudoUncheckedUpdateManyInput>
    /**
     * Filter which Laudos to update
     */
    where?: LaudoWhereInput
  }

  /**
   * Laudo upsert
   */
  export type LaudoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
    /**
     * The filter to search for the Laudo to update in case it exists.
     */
    where: LaudoWhereUniqueInput
    /**
     * In case the Laudo found by the `where` argument doesn't exist, create a new Laudo with this data.
     */
    create: XOR<LaudoCreateInput, LaudoUncheckedCreateInput>
    /**
     * In case the Laudo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaudoUpdateInput, LaudoUncheckedUpdateInput>
  }

  /**
   * Laudo delete
   */
  export type LaudoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
    /**
     * Filter which Laudo to delete.
     */
    where: LaudoWhereUniqueInput
  }

  /**
   * Laudo deleteMany
   */
  export type LaudoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Laudos to delete
     */
    where?: LaudoWhereInput
  }

  /**
   * Laudo.profissional
   */
  export type Laudo$profissionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profissional
     */
    select?: ProfissionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfissionalInclude<ExtArgs> | null
    where?: ProfissionalWhereInput
  }

  /**
   * Laudo.usuario
   */
  export type Laudo$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * Laudo without action
   */
  export type LaudoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laudo
     */
    select?: LaudoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaudoInclude<ExtArgs> | null
  }


  /**
   * Model Banco
   */

  export type AggregateBanco = {
    _count: BancoCountAggregateOutputType | null
    _avg: BancoAvgAggregateOutputType | null
    _sum: BancoSumAggregateOutputType | null
    _min: BancoMinAggregateOutputType | null
    _max: BancoMaxAggregateOutputType | null
  }

  export type BancoAvgAggregateOutputType = {
    id: number | null
  }

  export type BancoSumAggregateOutputType = {
    id: number | null
  }

  export type BancoMinAggregateOutputType = {
    id: number | null
    codigo: string | null
    nome: string | null
    agencia: string | null
    nomeAgencia: string | null
    conta: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BancoMaxAggregateOutputType = {
    id: number | null
    codigo: string | null
    nome: string | null
    agencia: string | null
    nomeAgencia: string | null
    conta: string | null
    ativo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BancoCountAggregateOutputType = {
    id: number
    codigo: number
    nome: number
    agencia: number
    nomeAgencia: number
    conta: number
    ativo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BancoAvgAggregateInputType = {
    id?: true
  }

  export type BancoSumAggregateInputType = {
    id?: true
  }

  export type BancoMinAggregateInputType = {
    id?: true
    codigo?: true
    nome?: true
    agencia?: true
    nomeAgencia?: true
    conta?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BancoMaxAggregateInputType = {
    id?: true
    codigo?: true
    nome?: true
    agencia?: true
    nomeAgencia?: true
    conta?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BancoCountAggregateInputType = {
    id?: true
    codigo?: true
    nome?: true
    agencia?: true
    nomeAgencia?: true
    conta?: true
    ativo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BancoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banco to aggregate.
     */
    where?: BancoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bancos to fetch.
     */
    orderBy?: BancoOrderByWithRelationInput | BancoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BancoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bancos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bancos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bancos
    **/
    _count?: true | BancoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BancoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BancoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BancoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BancoMaxAggregateInputType
  }

  export type GetBancoAggregateType<T extends BancoAggregateArgs> = {
        [P in keyof T & keyof AggregateBanco]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanco[P]>
      : GetScalarType<T[P], AggregateBanco[P]>
  }




  export type BancoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BancoWhereInput
    orderBy?: BancoOrderByWithAggregationInput | BancoOrderByWithAggregationInput[]
    by: BancoScalarFieldEnum[] | BancoScalarFieldEnum
    having?: BancoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BancoCountAggregateInputType | true
    _avg?: BancoAvgAggregateInputType
    _sum?: BancoSumAggregateInputType
    _min?: BancoMinAggregateInputType
    _max?: BancoMaxAggregateInputType
  }

  export type BancoGroupByOutputType = {
    id: number
    codigo: string | null
    nome: string
    agencia: string | null
    nomeAgencia: string | null
    conta: string | null
    ativo: boolean
    createdAt: Date
    updatedAt: Date
    _count: BancoCountAggregateOutputType | null
    _avg: BancoAvgAggregateOutputType | null
    _sum: BancoSumAggregateOutputType | null
    _min: BancoMinAggregateOutputType | null
    _max: BancoMaxAggregateOutputType | null
  }

  type GetBancoGroupByPayload<T extends BancoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BancoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BancoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BancoGroupByOutputType[P]>
            : GetScalarType<T[P], BancoGroupByOutputType[P]>
        }
      >
    >


  export type BancoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nome?: boolean
    agencia?: boolean
    nomeAgencia?: boolean
    conta?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contas?: boolean | Banco$contasArgs<ExtArgs>
    _count?: boolean | BancoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["banco"]>

  export type BancoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nome?: boolean
    agencia?: boolean
    nomeAgencia?: boolean
    conta?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banco"]>

  export type BancoSelectScalar = {
    id?: boolean
    codigo?: boolean
    nome?: boolean
    agencia?: boolean
    nomeAgencia?: boolean
    conta?: boolean
    ativo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BancoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contas?: boolean | Banco$contasArgs<ExtArgs>
    _count?: boolean | BancoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BancoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BancoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banco"
    objects: {
      contas: Prisma.$ContaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigo: string | null
      nome: string
      agencia: string | null
      nomeAgencia: string | null
      conta: string | null
      ativo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["banco"]>
    composites: {}
  }

  type BancoGetPayload<S extends boolean | null | undefined | BancoDefaultArgs> = $Result.GetResult<Prisma.$BancoPayload, S>

  type BancoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BancoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BancoCountAggregateInputType | true
    }

  export interface BancoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banco'], meta: { name: 'Banco' } }
    /**
     * Find zero or one Banco that matches the filter.
     * @param {BancoFindUniqueArgs} args - Arguments to find a Banco
     * @example
     * // Get one Banco
     * const banco = await prisma.banco.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BancoFindUniqueArgs>(args: SelectSubset<T, BancoFindUniqueArgs<ExtArgs>>): Prisma__BancoClient<$Result.GetResult<Prisma.$BancoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Banco that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BancoFindUniqueOrThrowArgs} args - Arguments to find a Banco
     * @example
     * // Get one Banco
     * const banco = await prisma.banco.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BancoFindUniqueOrThrowArgs>(args: SelectSubset<T, BancoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BancoClient<$Result.GetResult<Prisma.$BancoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Banco that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BancoFindFirstArgs} args - Arguments to find a Banco
     * @example
     * // Get one Banco
     * const banco = await prisma.banco.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BancoFindFirstArgs>(args?: SelectSubset<T, BancoFindFirstArgs<ExtArgs>>): Prisma__BancoClient<$Result.GetResult<Prisma.$BancoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Banco that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BancoFindFirstOrThrowArgs} args - Arguments to find a Banco
     * @example
     * // Get one Banco
     * const banco = await prisma.banco.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BancoFindFirstOrThrowArgs>(args?: SelectSubset<T, BancoFindFirstOrThrowArgs<ExtArgs>>): Prisma__BancoClient<$Result.GetResult<Prisma.$BancoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bancos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BancoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bancos
     * const bancos = await prisma.banco.findMany()
     * 
     * // Get first 10 Bancos
     * const bancos = await prisma.banco.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bancoWithIdOnly = await prisma.banco.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BancoFindManyArgs>(args?: SelectSubset<T, BancoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BancoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Banco.
     * @param {BancoCreateArgs} args - Arguments to create a Banco.
     * @example
     * // Create one Banco
     * const Banco = await prisma.banco.create({
     *   data: {
     *     // ... data to create a Banco
     *   }
     * })
     * 
     */
    create<T extends BancoCreateArgs>(args: SelectSubset<T, BancoCreateArgs<ExtArgs>>): Prisma__BancoClient<$Result.GetResult<Prisma.$BancoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bancos.
     * @param {BancoCreateManyArgs} args - Arguments to create many Bancos.
     * @example
     * // Create many Bancos
     * const banco = await prisma.banco.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BancoCreateManyArgs>(args?: SelectSubset<T, BancoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bancos and returns the data saved in the database.
     * @param {BancoCreateManyAndReturnArgs} args - Arguments to create many Bancos.
     * @example
     * // Create many Bancos
     * const banco = await prisma.banco.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bancos and only return the `id`
     * const bancoWithIdOnly = await prisma.banco.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BancoCreateManyAndReturnArgs>(args?: SelectSubset<T, BancoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BancoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Banco.
     * @param {BancoDeleteArgs} args - Arguments to delete one Banco.
     * @example
     * // Delete one Banco
     * const Banco = await prisma.banco.delete({
     *   where: {
     *     // ... filter to delete one Banco
     *   }
     * })
     * 
     */
    delete<T extends BancoDeleteArgs>(args: SelectSubset<T, BancoDeleteArgs<ExtArgs>>): Prisma__BancoClient<$Result.GetResult<Prisma.$BancoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Banco.
     * @param {BancoUpdateArgs} args - Arguments to update one Banco.
     * @example
     * // Update one Banco
     * const banco = await prisma.banco.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BancoUpdateArgs>(args: SelectSubset<T, BancoUpdateArgs<ExtArgs>>): Prisma__BancoClient<$Result.GetResult<Prisma.$BancoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bancos.
     * @param {BancoDeleteManyArgs} args - Arguments to filter Bancos to delete.
     * @example
     * // Delete a few Bancos
     * const { count } = await prisma.banco.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BancoDeleteManyArgs>(args?: SelectSubset<T, BancoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bancos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BancoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bancos
     * const banco = await prisma.banco.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BancoUpdateManyArgs>(args: SelectSubset<T, BancoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banco.
     * @param {BancoUpsertArgs} args - Arguments to update or create a Banco.
     * @example
     * // Update or create a Banco
     * const banco = await prisma.banco.upsert({
     *   create: {
     *     // ... data to create a Banco
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banco we want to update
     *   }
     * })
     */
    upsert<T extends BancoUpsertArgs>(args: SelectSubset<T, BancoUpsertArgs<ExtArgs>>): Prisma__BancoClient<$Result.GetResult<Prisma.$BancoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bancos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BancoCountArgs} args - Arguments to filter Bancos to count.
     * @example
     * // Count the number of Bancos
     * const count = await prisma.banco.count({
     *   where: {
     *     // ... the filter for the Bancos we want to count
     *   }
     * })
    **/
    count<T extends BancoCountArgs>(
      args?: Subset<T, BancoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BancoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BancoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BancoAggregateArgs>(args: Subset<T, BancoAggregateArgs>): Prisma.PrismaPromise<GetBancoAggregateType<T>>

    /**
     * Group by Banco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BancoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BancoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BancoGroupByArgs['orderBy'] }
        : { orderBy?: BancoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BancoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBancoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banco model
   */
  readonly fields: BancoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banco.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BancoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contas<T extends Banco$contasArgs<ExtArgs> = {}>(args?: Subset<T, Banco$contasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banco model
   */ 
  interface BancoFieldRefs {
    readonly id: FieldRef<"Banco", 'Int'>
    readonly codigo: FieldRef<"Banco", 'String'>
    readonly nome: FieldRef<"Banco", 'String'>
    readonly agencia: FieldRef<"Banco", 'String'>
    readonly nomeAgencia: FieldRef<"Banco", 'String'>
    readonly conta: FieldRef<"Banco", 'String'>
    readonly ativo: FieldRef<"Banco", 'Boolean'>
    readonly createdAt: FieldRef<"Banco", 'DateTime'>
    readonly updatedAt: FieldRef<"Banco", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Banco findUnique
   */
  export type BancoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banco
     */
    select?: BancoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BancoInclude<ExtArgs> | null
    /**
     * Filter, which Banco to fetch.
     */
    where: BancoWhereUniqueInput
  }

  /**
   * Banco findUniqueOrThrow
   */
  export type BancoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banco
     */
    select?: BancoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BancoInclude<ExtArgs> | null
    /**
     * Filter, which Banco to fetch.
     */
    where: BancoWhereUniqueInput
  }

  /**
   * Banco findFirst
   */
  export type BancoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banco
     */
    select?: BancoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BancoInclude<ExtArgs> | null
    /**
     * Filter, which Banco to fetch.
     */
    where?: BancoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bancos to fetch.
     */
    orderBy?: BancoOrderByWithRelationInput | BancoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bancos.
     */
    cursor?: BancoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bancos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bancos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bancos.
     */
    distinct?: BancoScalarFieldEnum | BancoScalarFieldEnum[]
  }

  /**
   * Banco findFirstOrThrow
   */
  export type BancoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banco
     */
    select?: BancoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BancoInclude<ExtArgs> | null
    /**
     * Filter, which Banco to fetch.
     */
    where?: BancoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bancos to fetch.
     */
    orderBy?: BancoOrderByWithRelationInput | BancoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bancos.
     */
    cursor?: BancoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bancos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bancos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bancos.
     */
    distinct?: BancoScalarFieldEnum | BancoScalarFieldEnum[]
  }

  /**
   * Banco findMany
   */
  export type BancoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banco
     */
    select?: BancoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BancoInclude<ExtArgs> | null
    /**
     * Filter, which Bancos to fetch.
     */
    where?: BancoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bancos to fetch.
     */
    orderBy?: BancoOrderByWithRelationInput | BancoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bancos.
     */
    cursor?: BancoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bancos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bancos.
     */
    skip?: number
    distinct?: BancoScalarFieldEnum | BancoScalarFieldEnum[]
  }

  /**
   * Banco create
   */
  export type BancoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banco
     */
    select?: BancoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BancoInclude<ExtArgs> | null
    /**
     * The data needed to create a Banco.
     */
    data: XOR<BancoCreateInput, BancoUncheckedCreateInput>
  }

  /**
   * Banco createMany
   */
  export type BancoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bancos.
     */
    data: BancoCreateManyInput | BancoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banco createManyAndReturn
   */
  export type BancoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banco
     */
    select?: BancoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bancos.
     */
    data: BancoCreateManyInput | BancoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banco update
   */
  export type BancoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banco
     */
    select?: BancoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BancoInclude<ExtArgs> | null
    /**
     * The data needed to update a Banco.
     */
    data: XOR<BancoUpdateInput, BancoUncheckedUpdateInput>
    /**
     * Choose, which Banco to update.
     */
    where: BancoWhereUniqueInput
  }

  /**
   * Banco updateMany
   */
  export type BancoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bancos.
     */
    data: XOR<BancoUpdateManyMutationInput, BancoUncheckedUpdateManyInput>
    /**
     * Filter which Bancos to update
     */
    where?: BancoWhereInput
  }

  /**
   * Banco upsert
   */
  export type BancoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banco
     */
    select?: BancoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BancoInclude<ExtArgs> | null
    /**
     * The filter to search for the Banco to update in case it exists.
     */
    where: BancoWhereUniqueInput
    /**
     * In case the Banco found by the `where` argument doesn't exist, create a new Banco with this data.
     */
    create: XOR<BancoCreateInput, BancoUncheckedCreateInput>
    /**
     * In case the Banco was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BancoUpdateInput, BancoUncheckedUpdateInput>
  }

  /**
   * Banco delete
   */
  export type BancoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banco
     */
    select?: BancoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BancoInclude<ExtArgs> | null
    /**
     * Filter which Banco to delete.
     */
    where: BancoWhereUniqueInput
  }

  /**
   * Banco deleteMany
   */
  export type BancoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bancos to delete
     */
    where?: BancoWhereInput
  }

  /**
   * Banco.contas
   */
  export type Banco$contasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    where?: ContaWhereInput
    orderBy?: ContaOrderByWithRelationInput | ContaOrderByWithRelationInput[]
    cursor?: ContaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContaScalarFieldEnum | ContaScalarFieldEnum[]
  }

  /**
   * Banco without action
   */
  export type BancoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banco
     */
    select?: BancoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BancoInclude<ExtArgs> | null
  }


  /**
   * Model Conta
   */

  export type AggregateConta = {
    _count: ContaCountAggregateOutputType | null
    _avg: ContaAvgAggregateOutputType | null
    _sum: ContaSumAggregateOutputType | null
    _min: ContaMinAggregateOutputType | null
    _max: ContaMaxAggregateOutputType | null
  }

  export type ContaAvgAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    bancoId: number | null
    valor: Decimal | null
  }

  export type ContaSumAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    bancoId: number | null
    valor: Decimal | null
  }

  export type ContaMinAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    bancoId: number | null
    tipo: $Enums.TipoConta | null
    descricao: string | null
    valor: Decimal | null
    dataVencimento: Date | null
    dataPagamento: Date | null
    status: $Enums.StatusConta | null
    observacoes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContaMaxAggregateOutputType = {
    id: number | null
    pedidoId: number | null
    bancoId: number | null
    tipo: $Enums.TipoConta | null
    descricao: string | null
    valor: Decimal | null
    dataVencimento: Date | null
    dataPagamento: Date | null
    status: $Enums.StatusConta | null
    observacoes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContaCountAggregateOutputType = {
    id: number
    pedidoId: number
    bancoId: number
    tipo: number
    descricao: number
    valor: number
    dataVencimento: number
    dataPagamento: number
    status: number
    observacoes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContaAvgAggregateInputType = {
    id?: true
    pedidoId?: true
    bancoId?: true
    valor?: true
  }

  export type ContaSumAggregateInputType = {
    id?: true
    pedidoId?: true
    bancoId?: true
    valor?: true
  }

  export type ContaMinAggregateInputType = {
    id?: true
    pedidoId?: true
    bancoId?: true
    tipo?: true
    descricao?: true
    valor?: true
    dataVencimento?: true
    dataPagamento?: true
    status?: true
    observacoes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContaMaxAggregateInputType = {
    id?: true
    pedidoId?: true
    bancoId?: true
    tipo?: true
    descricao?: true
    valor?: true
    dataVencimento?: true
    dataPagamento?: true
    status?: true
    observacoes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContaCountAggregateInputType = {
    id?: true
    pedidoId?: true
    bancoId?: true
    tipo?: true
    descricao?: true
    valor?: true
    dataVencimento?: true
    dataPagamento?: true
    status?: true
    observacoes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conta to aggregate.
     */
    where?: ContaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contas to fetch.
     */
    orderBy?: ContaOrderByWithRelationInput | ContaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contas
    **/
    _count?: true | ContaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContaMaxAggregateInputType
  }

  export type GetContaAggregateType<T extends ContaAggregateArgs> = {
        [P in keyof T & keyof AggregateConta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConta[P]>
      : GetScalarType<T[P], AggregateConta[P]>
  }




  export type ContaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContaWhereInput
    orderBy?: ContaOrderByWithAggregationInput | ContaOrderByWithAggregationInput[]
    by: ContaScalarFieldEnum[] | ContaScalarFieldEnum
    having?: ContaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContaCountAggregateInputType | true
    _avg?: ContaAvgAggregateInputType
    _sum?: ContaSumAggregateInputType
    _min?: ContaMinAggregateInputType
    _max?: ContaMaxAggregateInputType
  }

  export type ContaGroupByOutputType = {
    id: number
    pedidoId: number | null
    bancoId: number | null
    tipo: $Enums.TipoConta
    descricao: string
    valor: Decimal
    dataVencimento: Date
    dataPagamento: Date | null
    status: $Enums.StatusConta
    observacoes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContaCountAggregateOutputType | null
    _avg: ContaAvgAggregateOutputType | null
    _sum: ContaSumAggregateOutputType | null
    _min: ContaMinAggregateOutputType | null
    _max: ContaMaxAggregateOutputType | null
  }

  type GetContaGroupByPayload<T extends ContaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContaGroupByOutputType[P]>
            : GetScalarType<T[P], ContaGroupByOutputType[P]>
        }
      >
    >


  export type ContaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    bancoId?: boolean
    tipo?: boolean
    descricao?: boolean
    valor?: boolean
    dataVencimento?: boolean
    dataPagamento?: boolean
    status?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pedido?: boolean | Conta$pedidoArgs<ExtArgs>
    banco?: boolean | Conta$bancoArgs<ExtArgs>
  }, ExtArgs["result"]["conta"]>

  export type ContaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pedidoId?: boolean
    bancoId?: boolean
    tipo?: boolean
    descricao?: boolean
    valor?: boolean
    dataVencimento?: boolean
    dataPagamento?: boolean
    status?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pedido?: boolean | Conta$pedidoArgs<ExtArgs>
    banco?: boolean | Conta$bancoArgs<ExtArgs>
  }, ExtArgs["result"]["conta"]>

  export type ContaSelectScalar = {
    id?: boolean
    pedidoId?: boolean
    bancoId?: boolean
    tipo?: boolean
    descricao?: boolean
    valor?: boolean
    dataVencimento?: boolean
    dataPagamento?: boolean
    status?: boolean
    observacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | Conta$pedidoArgs<ExtArgs>
    banco?: boolean | Conta$bancoArgs<ExtArgs>
  }
  export type ContaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pedido?: boolean | Conta$pedidoArgs<ExtArgs>
    banco?: boolean | Conta$bancoArgs<ExtArgs>
  }

  export type $ContaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conta"
    objects: {
      pedido: Prisma.$PedidoPayload<ExtArgs> | null
      banco: Prisma.$BancoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pedidoId: number | null
      bancoId: number | null
      tipo: $Enums.TipoConta
      descricao: string
      valor: Prisma.Decimal
      dataVencimento: Date
      dataPagamento: Date | null
      status: $Enums.StatusConta
      observacoes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conta"]>
    composites: {}
  }

  type ContaGetPayload<S extends boolean | null | undefined | ContaDefaultArgs> = $Result.GetResult<Prisma.$ContaPayload, S>

  type ContaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContaCountAggregateInputType | true
    }

  export interface ContaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conta'], meta: { name: 'Conta' } }
    /**
     * Find zero or one Conta that matches the filter.
     * @param {ContaFindUniqueArgs} args - Arguments to find a Conta
     * @example
     * // Get one Conta
     * const conta = await prisma.conta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContaFindUniqueArgs>(args: SelectSubset<T, ContaFindUniqueArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContaFindUniqueOrThrowArgs} args - Arguments to find a Conta
     * @example
     * // Get one Conta
     * const conta = await prisma.conta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContaFindUniqueOrThrowArgs>(args: SelectSubset<T, ContaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaFindFirstArgs} args - Arguments to find a Conta
     * @example
     * // Get one Conta
     * const conta = await prisma.conta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContaFindFirstArgs>(args?: SelectSubset<T, ContaFindFirstArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaFindFirstOrThrowArgs} args - Arguments to find a Conta
     * @example
     * // Get one Conta
     * const conta = await prisma.conta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContaFindFirstOrThrowArgs>(args?: SelectSubset<T, ContaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contas
     * const contas = await prisma.conta.findMany()
     * 
     * // Get first 10 Contas
     * const contas = await prisma.conta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contaWithIdOnly = await prisma.conta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContaFindManyArgs>(args?: SelectSubset<T, ContaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conta.
     * @param {ContaCreateArgs} args - Arguments to create a Conta.
     * @example
     * // Create one Conta
     * const Conta = await prisma.conta.create({
     *   data: {
     *     // ... data to create a Conta
     *   }
     * })
     * 
     */
    create<T extends ContaCreateArgs>(args: SelectSubset<T, ContaCreateArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contas.
     * @param {ContaCreateManyArgs} args - Arguments to create many Contas.
     * @example
     * // Create many Contas
     * const conta = await prisma.conta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContaCreateManyArgs>(args?: SelectSubset<T, ContaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contas and returns the data saved in the database.
     * @param {ContaCreateManyAndReturnArgs} args - Arguments to create many Contas.
     * @example
     * // Create many Contas
     * const conta = await prisma.conta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contas and only return the `id`
     * const contaWithIdOnly = await prisma.conta.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContaCreateManyAndReturnArgs>(args?: SelectSubset<T, ContaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conta.
     * @param {ContaDeleteArgs} args - Arguments to delete one Conta.
     * @example
     * // Delete one Conta
     * const Conta = await prisma.conta.delete({
     *   where: {
     *     // ... filter to delete one Conta
     *   }
     * })
     * 
     */
    delete<T extends ContaDeleteArgs>(args: SelectSubset<T, ContaDeleteArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conta.
     * @param {ContaUpdateArgs} args - Arguments to update one Conta.
     * @example
     * // Update one Conta
     * const conta = await prisma.conta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContaUpdateArgs>(args: SelectSubset<T, ContaUpdateArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contas.
     * @param {ContaDeleteManyArgs} args - Arguments to filter Contas to delete.
     * @example
     * // Delete a few Contas
     * const { count } = await prisma.conta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContaDeleteManyArgs>(args?: SelectSubset<T, ContaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contas
     * const conta = await prisma.conta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContaUpdateManyArgs>(args: SelectSubset<T, ContaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conta.
     * @param {ContaUpsertArgs} args - Arguments to update or create a Conta.
     * @example
     * // Update or create a Conta
     * const conta = await prisma.conta.upsert({
     *   create: {
     *     // ... data to create a Conta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conta we want to update
     *   }
     * })
     */
    upsert<T extends ContaUpsertArgs>(args: SelectSubset<T, ContaUpsertArgs<ExtArgs>>): Prisma__ContaClient<$Result.GetResult<Prisma.$ContaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaCountArgs} args - Arguments to filter Contas to count.
     * @example
     * // Count the number of Contas
     * const count = await prisma.conta.count({
     *   where: {
     *     // ... the filter for the Contas we want to count
     *   }
     * })
    **/
    count<T extends ContaCountArgs>(
      args?: Subset<T, ContaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContaAggregateArgs>(args: Subset<T, ContaAggregateArgs>): Prisma.PrismaPromise<GetContaAggregateType<T>>

    /**
     * Group by Conta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContaGroupByArgs['orderBy'] }
        : { orderBy?: ContaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conta model
   */
  readonly fields: ContaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pedido<T extends Conta$pedidoArgs<ExtArgs> = {}>(args?: Subset<T, Conta$pedidoArgs<ExtArgs>>): Prisma__PedidoClient<$Result.GetResult<Prisma.$PedidoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    banco<T extends Conta$bancoArgs<ExtArgs> = {}>(args?: Subset<T, Conta$bancoArgs<ExtArgs>>): Prisma__BancoClient<$Result.GetResult<Prisma.$BancoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conta model
   */ 
  interface ContaFieldRefs {
    readonly id: FieldRef<"Conta", 'Int'>
    readonly pedidoId: FieldRef<"Conta", 'Int'>
    readonly bancoId: FieldRef<"Conta", 'Int'>
    readonly tipo: FieldRef<"Conta", 'TipoConta'>
    readonly descricao: FieldRef<"Conta", 'String'>
    readonly valor: FieldRef<"Conta", 'Decimal'>
    readonly dataVencimento: FieldRef<"Conta", 'DateTime'>
    readonly dataPagamento: FieldRef<"Conta", 'DateTime'>
    readonly status: FieldRef<"Conta", 'StatusConta'>
    readonly observacoes: FieldRef<"Conta", 'String'>
    readonly createdAt: FieldRef<"Conta", 'DateTime'>
    readonly updatedAt: FieldRef<"Conta", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conta findUnique
   */
  export type ContaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * Filter, which Conta to fetch.
     */
    where: ContaWhereUniqueInput
  }

  /**
   * Conta findUniqueOrThrow
   */
  export type ContaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * Filter, which Conta to fetch.
     */
    where: ContaWhereUniqueInput
  }

  /**
   * Conta findFirst
   */
  export type ContaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * Filter, which Conta to fetch.
     */
    where?: ContaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contas to fetch.
     */
    orderBy?: ContaOrderByWithRelationInput | ContaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contas.
     */
    cursor?: ContaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contas.
     */
    distinct?: ContaScalarFieldEnum | ContaScalarFieldEnum[]
  }

  /**
   * Conta findFirstOrThrow
   */
  export type ContaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * Filter, which Conta to fetch.
     */
    where?: ContaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contas to fetch.
     */
    orderBy?: ContaOrderByWithRelationInput | ContaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contas.
     */
    cursor?: ContaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contas.
     */
    distinct?: ContaScalarFieldEnum | ContaScalarFieldEnum[]
  }

  /**
   * Conta findMany
   */
  export type ContaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * Filter, which Contas to fetch.
     */
    where?: ContaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contas to fetch.
     */
    orderBy?: ContaOrderByWithRelationInput | ContaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contas.
     */
    cursor?: ContaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contas.
     */
    skip?: number
    distinct?: ContaScalarFieldEnum | ContaScalarFieldEnum[]
  }

  /**
   * Conta create
   */
  export type ContaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * The data needed to create a Conta.
     */
    data: XOR<ContaCreateInput, ContaUncheckedCreateInput>
  }

  /**
   * Conta createMany
   */
  export type ContaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contas.
     */
    data: ContaCreateManyInput | ContaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conta createManyAndReturn
   */
  export type ContaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contas.
     */
    data: ContaCreateManyInput | ContaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conta update
   */
  export type ContaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * The data needed to update a Conta.
     */
    data: XOR<ContaUpdateInput, ContaUncheckedUpdateInput>
    /**
     * Choose, which Conta to update.
     */
    where: ContaWhereUniqueInput
  }

  /**
   * Conta updateMany
   */
  export type ContaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contas.
     */
    data: XOR<ContaUpdateManyMutationInput, ContaUncheckedUpdateManyInput>
    /**
     * Filter which Contas to update
     */
    where?: ContaWhereInput
  }

  /**
   * Conta upsert
   */
  export type ContaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * The filter to search for the Conta to update in case it exists.
     */
    where: ContaWhereUniqueInput
    /**
     * In case the Conta found by the `where` argument doesn't exist, create a new Conta with this data.
     */
    create: XOR<ContaCreateInput, ContaUncheckedCreateInput>
    /**
     * In case the Conta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContaUpdateInput, ContaUncheckedUpdateInput>
  }

  /**
   * Conta delete
   */
  export type ContaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
    /**
     * Filter which Conta to delete.
     */
    where: ContaWhereUniqueInput
  }

  /**
   * Conta deleteMany
   */
  export type ContaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contas to delete
     */
    where?: ContaWhereInput
  }

  /**
   * Conta.pedido
   */
  export type Conta$pedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pedido
     */
    select?: PedidoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoInclude<ExtArgs> | null
    where?: PedidoWhereInput
  }

  /**
   * Conta.banco
   */
  export type Conta$bancoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banco
     */
    select?: BancoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BancoInclude<ExtArgs> | null
    where?: BancoWhereInput
  }

  /**
   * Conta without action
   */
  export type ContaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conta
     */
    select?: ContaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContaInclude<ExtArgs> | null
  }


  /**
   * Model LogSistema
   */

  export type AggregateLogSistema = {
    _count: LogSistemaCountAggregateOutputType | null
    _avg: LogSistemaAvgAggregateOutputType | null
    _sum: LogSistemaSumAggregateOutputType | null
    _min: LogSistemaMinAggregateOutputType | null
    _max: LogSistemaMaxAggregateOutputType | null
  }

  export type LogSistemaAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    registroId: number | null
  }

  export type LogSistemaSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    registroId: number | null
  }

  export type LogSistemaMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    acao: string | null
    tabela: string | null
    registroId: number | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type LogSistemaMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    acao: string | null
    tabela: string | null
    registroId: number | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type LogSistemaCountAggregateOutputType = {
    id: number
    usuarioId: number
    acao: number
    tabela: number
    registroId: number
    dadosAntigos: number
    dadosNovos: number
    ip: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type LogSistemaAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    registroId?: true
  }

  export type LogSistemaSumAggregateInputType = {
    id?: true
    usuarioId?: true
    registroId?: true
  }

  export type LogSistemaMinAggregateInputType = {
    id?: true
    usuarioId?: true
    acao?: true
    tabela?: true
    registroId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type LogSistemaMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    acao?: true
    tabela?: true
    registroId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type LogSistemaCountAggregateInputType = {
    id?: true
    usuarioId?: true
    acao?: true
    tabela?: true
    registroId?: true
    dadosAntigos?: true
    dadosNovos?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type LogSistemaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogSistema to aggregate.
     */
    where?: LogSistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSistemas to fetch.
     */
    orderBy?: LogSistemaOrderByWithRelationInput | LogSistemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogSistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSistemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSistemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogSistemas
    **/
    _count?: true | LogSistemaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogSistemaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSistemaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogSistemaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogSistemaMaxAggregateInputType
  }

  export type GetLogSistemaAggregateType<T extends LogSistemaAggregateArgs> = {
        [P in keyof T & keyof AggregateLogSistema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogSistema[P]>
      : GetScalarType<T[P], AggregateLogSistema[P]>
  }




  export type LogSistemaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogSistemaWhereInput
    orderBy?: LogSistemaOrderByWithAggregationInput | LogSistemaOrderByWithAggregationInput[]
    by: LogSistemaScalarFieldEnum[] | LogSistemaScalarFieldEnum
    having?: LogSistemaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogSistemaCountAggregateInputType | true
    _avg?: LogSistemaAvgAggregateInputType
    _sum?: LogSistemaSumAggregateInputType
    _min?: LogSistemaMinAggregateInputType
    _max?: LogSistemaMaxAggregateInputType
  }

  export type LogSistemaGroupByOutputType = {
    id: number
    usuarioId: number | null
    acao: string
    tabela: string | null
    registroId: number | null
    dadosAntigos: JsonValue | null
    dadosNovos: JsonValue | null
    ip: string | null
    userAgent: string | null
    createdAt: Date
    _count: LogSistemaCountAggregateOutputType | null
    _avg: LogSistemaAvgAggregateOutputType | null
    _sum: LogSistemaSumAggregateOutputType | null
    _min: LogSistemaMinAggregateOutputType | null
    _max: LogSistemaMaxAggregateOutputType | null
  }

  type GetLogSistemaGroupByPayload<T extends LogSistemaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogSistemaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogSistemaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogSistemaGroupByOutputType[P]>
            : GetScalarType<T[P], LogSistemaGroupByOutputType[P]>
        }
      >
    >


  export type LogSistemaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    acao?: boolean
    tabela?: boolean
    registroId?: boolean
    dadosAntigos?: boolean
    dadosNovos?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["logSistema"]>

  export type LogSistemaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    acao?: boolean
    tabela?: boolean
    registroId?: boolean
    dadosAntigos?: boolean
    dadosNovos?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["logSistema"]>

  export type LogSistemaSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    acao?: boolean
    tabela?: boolean
    registroId?: boolean
    dadosAntigos?: boolean
    dadosNovos?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }


  export type $LogSistemaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogSistema"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number | null
      acao: string
      tabela: string | null
      registroId: number | null
      dadosAntigos: Prisma.JsonValue | null
      dadosNovos: Prisma.JsonValue | null
      ip: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["logSistema"]>
    composites: {}
  }

  type LogSistemaGetPayload<S extends boolean | null | undefined | LogSistemaDefaultArgs> = $Result.GetResult<Prisma.$LogSistemaPayload, S>

  type LogSistemaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogSistemaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogSistemaCountAggregateInputType | true
    }

  export interface LogSistemaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogSistema'], meta: { name: 'LogSistema' } }
    /**
     * Find zero or one LogSistema that matches the filter.
     * @param {LogSistemaFindUniqueArgs} args - Arguments to find a LogSistema
     * @example
     * // Get one LogSistema
     * const logSistema = await prisma.logSistema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogSistemaFindUniqueArgs>(args: SelectSubset<T, LogSistemaFindUniqueArgs<ExtArgs>>): Prisma__LogSistemaClient<$Result.GetResult<Prisma.$LogSistemaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogSistema that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogSistemaFindUniqueOrThrowArgs} args - Arguments to find a LogSistema
     * @example
     * // Get one LogSistema
     * const logSistema = await prisma.logSistema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogSistemaFindUniqueOrThrowArgs>(args: SelectSubset<T, LogSistemaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogSistemaClient<$Result.GetResult<Prisma.$LogSistemaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogSistema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSistemaFindFirstArgs} args - Arguments to find a LogSistema
     * @example
     * // Get one LogSistema
     * const logSistema = await prisma.logSistema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogSistemaFindFirstArgs>(args?: SelectSubset<T, LogSistemaFindFirstArgs<ExtArgs>>): Prisma__LogSistemaClient<$Result.GetResult<Prisma.$LogSistemaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogSistema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSistemaFindFirstOrThrowArgs} args - Arguments to find a LogSistema
     * @example
     * // Get one LogSistema
     * const logSistema = await prisma.logSistema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogSistemaFindFirstOrThrowArgs>(args?: SelectSubset<T, LogSistemaFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogSistemaClient<$Result.GetResult<Prisma.$LogSistemaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogSistemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSistemaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogSistemas
     * const logSistemas = await prisma.logSistema.findMany()
     * 
     * // Get first 10 LogSistemas
     * const logSistemas = await prisma.logSistema.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logSistemaWithIdOnly = await prisma.logSistema.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogSistemaFindManyArgs>(args?: SelectSubset<T, LogSistemaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogSistemaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogSistema.
     * @param {LogSistemaCreateArgs} args - Arguments to create a LogSistema.
     * @example
     * // Create one LogSistema
     * const LogSistema = await prisma.logSistema.create({
     *   data: {
     *     // ... data to create a LogSistema
     *   }
     * })
     * 
     */
    create<T extends LogSistemaCreateArgs>(args: SelectSubset<T, LogSistemaCreateArgs<ExtArgs>>): Prisma__LogSistemaClient<$Result.GetResult<Prisma.$LogSistemaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogSistemas.
     * @param {LogSistemaCreateManyArgs} args - Arguments to create many LogSistemas.
     * @example
     * // Create many LogSistemas
     * const logSistema = await prisma.logSistema.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogSistemaCreateManyArgs>(args?: SelectSubset<T, LogSistemaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LogSistemas and returns the data saved in the database.
     * @param {LogSistemaCreateManyAndReturnArgs} args - Arguments to create many LogSistemas.
     * @example
     * // Create many LogSistemas
     * const logSistema = await prisma.logSistema.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LogSistemas and only return the `id`
     * const logSistemaWithIdOnly = await prisma.logSistema.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogSistemaCreateManyAndReturnArgs>(args?: SelectSubset<T, LogSistemaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogSistemaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LogSistema.
     * @param {LogSistemaDeleteArgs} args - Arguments to delete one LogSistema.
     * @example
     * // Delete one LogSistema
     * const LogSistema = await prisma.logSistema.delete({
     *   where: {
     *     // ... filter to delete one LogSistema
     *   }
     * })
     * 
     */
    delete<T extends LogSistemaDeleteArgs>(args: SelectSubset<T, LogSistemaDeleteArgs<ExtArgs>>): Prisma__LogSistemaClient<$Result.GetResult<Prisma.$LogSistemaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogSistema.
     * @param {LogSistemaUpdateArgs} args - Arguments to update one LogSistema.
     * @example
     * // Update one LogSistema
     * const logSistema = await prisma.logSistema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogSistemaUpdateArgs>(args: SelectSubset<T, LogSistemaUpdateArgs<ExtArgs>>): Prisma__LogSistemaClient<$Result.GetResult<Prisma.$LogSistemaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogSistemas.
     * @param {LogSistemaDeleteManyArgs} args - Arguments to filter LogSistemas to delete.
     * @example
     * // Delete a few LogSistemas
     * const { count } = await prisma.logSistema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogSistemaDeleteManyArgs>(args?: SelectSubset<T, LogSistemaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogSistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSistemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogSistemas
     * const logSistema = await prisma.logSistema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogSistemaUpdateManyArgs>(args: SelectSubset<T, LogSistemaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogSistema.
     * @param {LogSistemaUpsertArgs} args - Arguments to update or create a LogSistema.
     * @example
     * // Update or create a LogSistema
     * const logSistema = await prisma.logSistema.upsert({
     *   create: {
     *     // ... data to create a LogSistema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogSistema we want to update
     *   }
     * })
     */
    upsert<T extends LogSistemaUpsertArgs>(args: SelectSubset<T, LogSistemaUpsertArgs<ExtArgs>>): Prisma__LogSistemaClient<$Result.GetResult<Prisma.$LogSistemaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogSistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSistemaCountArgs} args - Arguments to filter LogSistemas to count.
     * @example
     * // Count the number of LogSistemas
     * const count = await prisma.logSistema.count({
     *   where: {
     *     // ... the filter for the LogSistemas we want to count
     *   }
     * })
    **/
    count<T extends LogSistemaCountArgs>(
      args?: Subset<T, LogSistemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogSistemaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogSistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSistemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogSistemaAggregateArgs>(args: Subset<T, LogSistemaAggregateArgs>): Prisma.PrismaPromise<GetLogSistemaAggregateType<T>>

    /**
     * Group by LogSistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogSistemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogSistemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogSistemaGroupByArgs['orderBy'] }
        : { orderBy?: LogSistemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogSistemaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogSistemaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogSistema model
   */
  readonly fields: LogSistemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogSistema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogSistemaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogSistema model
   */ 
  interface LogSistemaFieldRefs {
    readonly id: FieldRef<"LogSistema", 'Int'>
    readonly usuarioId: FieldRef<"LogSistema", 'Int'>
    readonly acao: FieldRef<"LogSistema", 'String'>
    readonly tabela: FieldRef<"LogSistema", 'String'>
    readonly registroId: FieldRef<"LogSistema", 'Int'>
    readonly dadosAntigos: FieldRef<"LogSistema", 'Json'>
    readonly dadosNovos: FieldRef<"LogSistema", 'Json'>
    readonly ip: FieldRef<"LogSistema", 'String'>
    readonly userAgent: FieldRef<"LogSistema", 'String'>
    readonly createdAt: FieldRef<"LogSistema", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LogSistema findUnique
   */
  export type LogSistemaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSistema
     */
    select?: LogSistemaSelect<ExtArgs> | null
    /**
     * Filter, which LogSistema to fetch.
     */
    where: LogSistemaWhereUniqueInput
  }

  /**
   * LogSistema findUniqueOrThrow
   */
  export type LogSistemaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSistema
     */
    select?: LogSistemaSelect<ExtArgs> | null
    /**
     * Filter, which LogSistema to fetch.
     */
    where: LogSistemaWhereUniqueInput
  }

  /**
   * LogSistema findFirst
   */
  export type LogSistemaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSistema
     */
    select?: LogSistemaSelect<ExtArgs> | null
    /**
     * Filter, which LogSistema to fetch.
     */
    where?: LogSistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSistemas to fetch.
     */
    orderBy?: LogSistemaOrderByWithRelationInput | LogSistemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogSistemas.
     */
    cursor?: LogSistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSistemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSistemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogSistemas.
     */
    distinct?: LogSistemaScalarFieldEnum | LogSistemaScalarFieldEnum[]
  }

  /**
   * LogSistema findFirstOrThrow
   */
  export type LogSistemaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSistema
     */
    select?: LogSistemaSelect<ExtArgs> | null
    /**
     * Filter, which LogSistema to fetch.
     */
    where?: LogSistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSistemas to fetch.
     */
    orderBy?: LogSistemaOrderByWithRelationInput | LogSistemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogSistemas.
     */
    cursor?: LogSistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSistemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSistemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogSistemas.
     */
    distinct?: LogSistemaScalarFieldEnum | LogSistemaScalarFieldEnum[]
  }

  /**
   * LogSistema findMany
   */
  export type LogSistemaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSistema
     */
    select?: LogSistemaSelect<ExtArgs> | null
    /**
     * Filter, which LogSistemas to fetch.
     */
    where?: LogSistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogSistemas to fetch.
     */
    orderBy?: LogSistemaOrderByWithRelationInput | LogSistemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogSistemas.
     */
    cursor?: LogSistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogSistemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogSistemas.
     */
    skip?: number
    distinct?: LogSistemaScalarFieldEnum | LogSistemaScalarFieldEnum[]
  }

  /**
   * LogSistema create
   */
  export type LogSistemaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSistema
     */
    select?: LogSistemaSelect<ExtArgs> | null
    /**
     * The data needed to create a LogSistema.
     */
    data: XOR<LogSistemaCreateInput, LogSistemaUncheckedCreateInput>
  }

  /**
   * LogSistema createMany
   */
  export type LogSistemaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogSistemas.
     */
    data: LogSistemaCreateManyInput | LogSistemaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogSistema createManyAndReturn
   */
  export type LogSistemaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSistema
     */
    select?: LogSistemaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LogSistemas.
     */
    data: LogSistemaCreateManyInput | LogSistemaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogSistema update
   */
  export type LogSistemaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSistema
     */
    select?: LogSistemaSelect<ExtArgs> | null
    /**
     * The data needed to update a LogSistema.
     */
    data: XOR<LogSistemaUpdateInput, LogSistemaUncheckedUpdateInput>
    /**
     * Choose, which LogSistema to update.
     */
    where: LogSistemaWhereUniqueInput
  }

  /**
   * LogSistema updateMany
   */
  export type LogSistemaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogSistemas.
     */
    data: XOR<LogSistemaUpdateManyMutationInput, LogSistemaUncheckedUpdateManyInput>
    /**
     * Filter which LogSistemas to update
     */
    where?: LogSistemaWhereInput
  }

  /**
   * LogSistema upsert
   */
  export type LogSistemaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSistema
     */
    select?: LogSistemaSelect<ExtArgs> | null
    /**
     * The filter to search for the LogSistema to update in case it exists.
     */
    where: LogSistemaWhereUniqueInput
    /**
     * In case the LogSistema found by the `where` argument doesn't exist, create a new LogSistema with this data.
     */
    create: XOR<LogSistemaCreateInput, LogSistemaUncheckedCreateInput>
    /**
     * In case the LogSistema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogSistemaUpdateInput, LogSistemaUncheckedUpdateInput>
  }

  /**
   * LogSistema delete
   */
  export type LogSistemaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSistema
     */
    select?: LogSistemaSelect<ExtArgs> | null
    /**
     * Filter which LogSistema to delete.
     */
    where: LogSistemaWhereUniqueInput
  }

  /**
   * LogSistema deleteMany
   */
  export type LogSistemaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogSistemas to delete
     */
    where?: LogSistemaWhereInput
  }

  /**
   * LogSistema without action
   */
  export type LogSistemaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogSistema
     */
    select?: LogSistemaSelect<ExtArgs> | null
  }


  /**
   * Model ConfiguracaoSistema
   */

  export type AggregateConfiguracaoSistema = {
    _count: ConfiguracaoSistemaCountAggregateOutputType | null
    _avg: ConfiguracaoSistemaAvgAggregateOutputType | null
    _sum: ConfiguracaoSistemaSumAggregateOutputType | null
    _min: ConfiguracaoSistemaMinAggregateOutputType | null
    _max: ConfiguracaoSistemaMaxAggregateOutputType | null
  }

  export type ConfiguracaoSistemaAvgAggregateOutputType = {
    id: number | null
  }

  export type ConfiguracaoSistemaSumAggregateOutputType = {
    id: number | null
  }

  export type ConfiguracaoSistemaMinAggregateOutputType = {
    id: number | null
    chave: string | null
    valor: string | null
    descricao: string | null
    tipo: $Enums.TipoConfiguracao | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfiguracaoSistemaMaxAggregateOutputType = {
    id: number | null
    chave: string | null
    valor: string | null
    descricao: string | null
    tipo: $Enums.TipoConfiguracao | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfiguracaoSistemaCountAggregateOutputType = {
    id: number
    chave: number
    valor: number
    descricao: number
    tipo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfiguracaoSistemaAvgAggregateInputType = {
    id?: true
  }

  export type ConfiguracaoSistemaSumAggregateInputType = {
    id?: true
  }

  export type ConfiguracaoSistemaMinAggregateInputType = {
    id?: true
    chave?: true
    valor?: true
    descricao?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfiguracaoSistemaMaxAggregateInputType = {
    id?: true
    chave?: true
    valor?: true
    descricao?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfiguracaoSistemaCountAggregateInputType = {
    id?: true
    chave?: true
    valor?: true
    descricao?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfiguracaoSistemaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfiguracaoSistema to aggregate.
     */
    where?: ConfiguracaoSistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracaoSistemas to fetch.
     */
    orderBy?: ConfiguracaoSistemaOrderByWithRelationInput | ConfiguracaoSistemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfiguracaoSistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracaoSistemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracaoSistemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfiguracaoSistemas
    **/
    _count?: true | ConfiguracaoSistemaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfiguracaoSistemaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfiguracaoSistemaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfiguracaoSistemaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfiguracaoSistemaMaxAggregateInputType
  }

  export type GetConfiguracaoSistemaAggregateType<T extends ConfiguracaoSistemaAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguracaoSistema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguracaoSistema[P]>
      : GetScalarType<T[P], AggregateConfiguracaoSistema[P]>
  }




  export type ConfiguracaoSistemaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfiguracaoSistemaWhereInput
    orderBy?: ConfiguracaoSistemaOrderByWithAggregationInput | ConfiguracaoSistemaOrderByWithAggregationInput[]
    by: ConfiguracaoSistemaScalarFieldEnum[] | ConfiguracaoSistemaScalarFieldEnum
    having?: ConfiguracaoSistemaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfiguracaoSistemaCountAggregateInputType | true
    _avg?: ConfiguracaoSistemaAvgAggregateInputType
    _sum?: ConfiguracaoSistemaSumAggregateInputType
    _min?: ConfiguracaoSistemaMinAggregateInputType
    _max?: ConfiguracaoSistemaMaxAggregateInputType
  }

  export type ConfiguracaoSistemaGroupByOutputType = {
    id: number
    chave: string
    valor: string
    descricao: string | null
    tipo: $Enums.TipoConfiguracao
    createdAt: Date
    updatedAt: Date
    _count: ConfiguracaoSistemaCountAggregateOutputType | null
    _avg: ConfiguracaoSistemaAvgAggregateOutputType | null
    _sum: ConfiguracaoSistemaSumAggregateOutputType | null
    _min: ConfiguracaoSistemaMinAggregateOutputType | null
    _max: ConfiguracaoSistemaMaxAggregateOutputType | null
  }

  type GetConfiguracaoSistemaGroupByPayload<T extends ConfiguracaoSistemaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfiguracaoSistemaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfiguracaoSistemaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfiguracaoSistemaGroupByOutputType[P]>
            : GetScalarType<T[P], ConfiguracaoSistemaGroupByOutputType[P]>
        }
      >
    >


  export type ConfiguracaoSistemaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chave?: boolean
    valor?: boolean
    descricao?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configuracaoSistema"]>

  export type ConfiguracaoSistemaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chave?: boolean
    valor?: boolean
    descricao?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configuracaoSistema"]>

  export type ConfiguracaoSistemaSelectScalar = {
    id?: boolean
    chave?: boolean
    valor?: boolean
    descricao?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ConfiguracaoSistemaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfiguracaoSistema"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chave: string
      valor: string
      descricao: string | null
      tipo: $Enums.TipoConfiguracao
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configuracaoSistema"]>
    composites: {}
  }

  type ConfiguracaoSistemaGetPayload<S extends boolean | null | undefined | ConfiguracaoSistemaDefaultArgs> = $Result.GetResult<Prisma.$ConfiguracaoSistemaPayload, S>

  type ConfiguracaoSistemaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfiguracaoSistemaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfiguracaoSistemaCountAggregateInputType | true
    }

  export interface ConfiguracaoSistemaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfiguracaoSistema'], meta: { name: 'ConfiguracaoSistema' } }
    /**
     * Find zero or one ConfiguracaoSistema that matches the filter.
     * @param {ConfiguracaoSistemaFindUniqueArgs} args - Arguments to find a ConfiguracaoSistema
     * @example
     * // Get one ConfiguracaoSistema
     * const configuracaoSistema = await prisma.configuracaoSistema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfiguracaoSistemaFindUniqueArgs>(args: SelectSubset<T, ConfiguracaoSistemaFindUniqueArgs<ExtArgs>>): Prisma__ConfiguracaoSistemaClient<$Result.GetResult<Prisma.$ConfiguracaoSistemaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConfiguracaoSistema that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConfiguracaoSistemaFindUniqueOrThrowArgs} args - Arguments to find a ConfiguracaoSistema
     * @example
     * // Get one ConfiguracaoSistema
     * const configuracaoSistema = await prisma.configuracaoSistema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfiguracaoSistemaFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfiguracaoSistemaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfiguracaoSistemaClient<$Result.GetResult<Prisma.$ConfiguracaoSistemaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConfiguracaoSistema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoSistemaFindFirstArgs} args - Arguments to find a ConfiguracaoSistema
     * @example
     * // Get one ConfiguracaoSistema
     * const configuracaoSistema = await prisma.configuracaoSistema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfiguracaoSistemaFindFirstArgs>(args?: SelectSubset<T, ConfiguracaoSistemaFindFirstArgs<ExtArgs>>): Prisma__ConfiguracaoSistemaClient<$Result.GetResult<Prisma.$ConfiguracaoSistemaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConfiguracaoSistema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoSistemaFindFirstOrThrowArgs} args - Arguments to find a ConfiguracaoSistema
     * @example
     * // Get one ConfiguracaoSistema
     * const configuracaoSistema = await prisma.configuracaoSistema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfiguracaoSistemaFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfiguracaoSistemaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfiguracaoSistemaClient<$Result.GetResult<Prisma.$ConfiguracaoSistemaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConfiguracaoSistemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoSistemaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfiguracaoSistemas
     * const configuracaoSistemas = await prisma.configuracaoSistema.findMany()
     * 
     * // Get first 10 ConfiguracaoSistemas
     * const configuracaoSistemas = await prisma.configuracaoSistema.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configuracaoSistemaWithIdOnly = await prisma.configuracaoSistema.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfiguracaoSistemaFindManyArgs>(args?: SelectSubset<T, ConfiguracaoSistemaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracaoSistemaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConfiguracaoSistema.
     * @param {ConfiguracaoSistemaCreateArgs} args - Arguments to create a ConfiguracaoSistema.
     * @example
     * // Create one ConfiguracaoSistema
     * const ConfiguracaoSistema = await prisma.configuracaoSistema.create({
     *   data: {
     *     // ... data to create a ConfiguracaoSistema
     *   }
     * })
     * 
     */
    create<T extends ConfiguracaoSistemaCreateArgs>(args: SelectSubset<T, ConfiguracaoSistemaCreateArgs<ExtArgs>>): Prisma__ConfiguracaoSistemaClient<$Result.GetResult<Prisma.$ConfiguracaoSistemaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConfiguracaoSistemas.
     * @param {ConfiguracaoSistemaCreateManyArgs} args - Arguments to create many ConfiguracaoSistemas.
     * @example
     * // Create many ConfiguracaoSistemas
     * const configuracaoSistema = await prisma.configuracaoSistema.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfiguracaoSistemaCreateManyArgs>(args?: SelectSubset<T, ConfiguracaoSistemaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfiguracaoSistemas and returns the data saved in the database.
     * @param {ConfiguracaoSistemaCreateManyAndReturnArgs} args - Arguments to create many ConfiguracaoSistemas.
     * @example
     * // Create many ConfiguracaoSistemas
     * const configuracaoSistema = await prisma.configuracaoSistema.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfiguracaoSistemas and only return the `id`
     * const configuracaoSistemaWithIdOnly = await prisma.configuracaoSistema.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfiguracaoSistemaCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfiguracaoSistemaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracaoSistemaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConfiguracaoSistema.
     * @param {ConfiguracaoSistemaDeleteArgs} args - Arguments to delete one ConfiguracaoSistema.
     * @example
     * // Delete one ConfiguracaoSistema
     * const ConfiguracaoSistema = await prisma.configuracaoSistema.delete({
     *   where: {
     *     // ... filter to delete one ConfiguracaoSistema
     *   }
     * })
     * 
     */
    delete<T extends ConfiguracaoSistemaDeleteArgs>(args: SelectSubset<T, ConfiguracaoSistemaDeleteArgs<ExtArgs>>): Prisma__ConfiguracaoSistemaClient<$Result.GetResult<Prisma.$ConfiguracaoSistemaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConfiguracaoSistema.
     * @param {ConfiguracaoSistemaUpdateArgs} args - Arguments to update one ConfiguracaoSistema.
     * @example
     * // Update one ConfiguracaoSistema
     * const configuracaoSistema = await prisma.configuracaoSistema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfiguracaoSistemaUpdateArgs>(args: SelectSubset<T, ConfiguracaoSistemaUpdateArgs<ExtArgs>>): Prisma__ConfiguracaoSistemaClient<$Result.GetResult<Prisma.$ConfiguracaoSistemaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConfiguracaoSistemas.
     * @param {ConfiguracaoSistemaDeleteManyArgs} args - Arguments to filter ConfiguracaoSistemas to delete.
     * @example
     * // Delete a few ConfiguracaoSistemas
     * const { count } = await prisma.configuracaoSistema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfiguracaoSistemaDeleteManyArgs>(args?: SelectSubset<T, ConfiguracaoSistemaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfiguracaoSistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoSistemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfiguracaoSistemas
     * const configuracaoSistema = await prisma.configuracaoSistema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfiguracaoSistemaUpdateManyArgs>(args: SelectSubset<T, ConfiguracaoSistemaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfiguracaoSistema.
     * @param {ConfiguracaoSistemaUpsertArgs} args - Arguments to update or create a ConfiguracaoSistema.
     * @example
     * // Update or create a ConfiguracaoSistema
     * const configuracaoSistema = await prisma.configuracaoSistema.upsert({
     *   create: {
     *     // ... data to create a ConfiguracaoSistema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfiguracaoSistema we want to update
     *   }
     * })
     */
    upsert<T extends ConfiguracaoSistemaUpsertArgs>(args: SelectSubset<T, ConfiguracaoSistemaUpsertArgs<ExtArgs>>): Prisma__ConfiguracaoSistemaClient<$Result.GetResult<Prisma.$ConfiguracaoSistemaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConfiguracaoSistemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoSistemaCountArgs} args - Arguments to filter ConfiguracaoSistemas to count.
     * @example
     * // Count the number of ConfiguracaoSistemas
     * const count = await prisma.configuracaoSistema.count({
     *   where: {
     *     // ... the filter for the ConfiguracaoSistemas we want to count
     *   }
     * })
    **/
    count<T extends ConfiguracaoSistemaCountArgs>(
      args?: Subset<T, ConfiguracaoSistemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfiguracaoSistemaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfiguracaoSistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoSistemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfiguracaoSistemaAggregateArgs>(args: Subset<T, ConfiguracaoSistemaAggregateArgs>): Prisma.PrismaPromise<GetConfiguracaoSistemaAggregateType<T>>

    /**
     * Group by ConfiguracaoSistema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracaoSistemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfiguracaoSistemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfiguracaoSistemaGroupByArgs['orderBy'] }
        : { orderBy?: ConfiguracaoSistemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfiguracaoSistemaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfiguracaoSistemaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfiguracaoSistema model
   */
  readonly fields: ConfiguracaoSistemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfiguracaoSistema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfiguracaoSistemaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfiguracaoSistema model
   */ 
  interface ConfiguracaoSistemaFieldRefs {
    readonly id: FieldRef<"ConfiguracaoSistema", 'Int'>
    readonly chave: FieldRef<"ConfiguracaoSistema", 'String'>
    readonly valor: FieldRef<"ConfiguracaoSistema", 'String'>
    readonly descricao: FieldRef<"ConfiguracaoSistema", 'String'>
    readonly tipo: FieldRef<"ConfiguracaoSistema", 'TipoConfiguracao'>
    readonly createdAt: FieldRef<"ConfiguracaoSistema", 'DateTime'>
    readonly updatedAt: FieldRef<"ConfiguracaoSistema", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConfiguracaoSistema findUnique
   */
  export type ConfiguracaoSistemaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoSistema
     */
    select?: ConfiguracaoSistemaSelect<ExtArgs> | null
    /**
     * Filter, which ConfiguracaoSistema to fetch.
     */
    where: ConfiguracaoSistemaWhereUniqueInput
  }

  /**
   * ConfiguracaoSistema findUniqueOrThrow
   */
  export type ConfiguracaoSistemaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoSistema
     */
    select?: ConfiguracaoSistemaSelect<ExtArgs> | null
    /**
     * Filter, which ConfiguracaoSistema to fetch.
     */
    where: ConfiguracaoSistemaWhereUniqueInput
  }

  /**
   * ConfiguracaoSistema findFirst
   */
  export type ConfiguracaoSistemaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoSistema
     */
    select?: ConfiguracaoSistemaSelect<ExtArgs> | null
    /**
     * Filter, which ConfiguracaoSistema to fetch.
     */
    where?: ConfiguracaoSistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracaoSistemas to fetch.
     */
    orderBy?: ConfiguracaoSistemaOrderByWithRelationInput | ConfiguracaoSistemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfiguracaoSistemas.
     */
    cursor?: ConfiguracaoSistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracaoSistemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracaoSistemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfiguracaoSistemas.
     */
    distinct?: ConfiguracaoSistemaScalarFieldEnum | ConfiguracaoSistemaScalarFieldEnum[]
  }

  /**
   * ConfiguracaoSistema findFirstOrThrow
   */
  export type ConfiguracaoSistemaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoSistema
     */
    select?: ConfiguracaoSistemaSelect<ExtArgs> | null
    /**
     * Filter, which ConfiguracaoSistema to fetch.
     */
    where?: ConfiguracaoSistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracaoSistemas to fetch.
     */
    orderBy?: ConfiguracaoSistemaOrderByWithRelationInput | ConfiguracaoSistemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfiguracaoSistemas.
     */
    cursor?: ConfiguracaoSistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracaoSistemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracaoSistemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfiguracaoSistemas.
     */
    distinct?: ConfiguracaoSistemaScalarFieldEnum | ConfiguracaoSistemaScalarFieldEnum[]
  }

  /**
   * ConfiguracaoSistema findMany
   */
  export type ConfiguracaoSistemaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoSistema
     */
    select?: ConfiguracaoSistemaSelect<ExtArgs> | null
    /**
     * Filter, which ConfiguracaoSistemas to fetch.
     */
    where?: ConfiguracaoSistemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfiguracaoSistemas to fetch.
     */
    orderBy?: ConfiguracaoSistemaOrderByWithRelationInput | ConfiguracaoSistemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfiguracaoSistemas.
     */
    cursor?: ConfiguracaoSistemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfiguracaoSistemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfiguracaoSistemas.
     */
    skip?: number
    distinct?: ConfiguracaoSistemaScalarFieldEnum | ConfiguracaoSistemaScalarFieldEnum[]
  }

  /**
   * ConfiguracaoSistema create
   */
  export type ConfiguracaoSistemaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoSistema
     */
    select?: ConfiguracaoSistemaSelect<ExtArgs> | null
    /**
     * The data needed to create a ConfiguracaoSistema.
     */
    data: XOR<ConfiguracaoSistemaCreateInput, ConfiguracaoSistemaUncheckedCreateInput>
  }

  /**
   * ConfiguracaoSistema createMany
   */
  export type ConfiguracaoSistemaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfiguracaoSistemas.
     */
    data: ConfiguracaoSistemaCreateManyInput | ConfiguracaoSistemaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfiguracaoSistema createManyAndReturn
   */
  export type ConfiguracaoSistemaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoSistema
     */
    select?: ConfiguracaoSistemaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConfiguracaoSistemas.
     */
    data: ConfiguracaoSistemaCreateManyInput | ConfiguracaoSistemaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfiguracaoSistema update
   */
  export type ConfiguracaoSistemaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoSistema
     */
    select?: ConfiguracaoSistemaSelect<ExtArgs> | null
    /**
     * The data needed to update a ConfiguracaoSistema.
     */
    data: XOR<ConfiguracaoSistemaUpdateInput, ConfiguracaoSistemaUncheckedUpdateInput>
    /**
     * Choose, which ConfiguracaoSistema to update.
     */
    where: ConfiguracaoSistemaWhereUniqueInput
  }

  /**
   * ConfiguracaoSistema updateMany
   */
  export type ConfiguracaoSistemaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfiguracaoSistemas.
     */
    data: XOR<ConfiguracaoSistemaUpdateManyMutationInput, ConfiguracaoSistemaUncheckedUpdateManyInput>
    /**
     * Filter which ConfiguracaoSistemas to update
     */
    where?: ConfiguracaoSistemaWhereInput
  }

  /**
   * ConfiguracaoSistema upsert
   */
  export type ConfiguracaoSistemaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoSistema
     */
    select?: ConfiguracaoSistemaSelect<ExtArgs> | null
    /**
     * The filter to search for the ConfiguracaoSistema to update in case it exists.
     */
    where: ConfiguracaoSistemaWhereUniqueInput
    /**
     * In case the ConfiguracaoSistema found by the `where` argument doesn't exist, create a new ConfiguracaoSistema with this data.
     */
    create: XOR<ConfiguracaoSistemaCreateInput, ConfiguracaoSistemaUncheckedCreateInput>
    /**
     * In case the ConfiguracaoSistema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfiguracaoSistemaUpdateInput, ConfiguracaoSistemaUncheckedUpdateInput>
  }

  /**
   * ConfiguracaoSistema delete
   */
  export type ConfiguracaoSistemaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoSistema
     */
    select?: ConfiguracaoSistemaSelect<ExtArgs> | null
    /**
     * Filter which ConfiguracaoSistema to delete.
     */
    where: ConfiguracaoSistemaWhereUniqueInput
  }

  /**
   * ConfiguracaoSistema deleteMany
   */
  export type ConfiguracaoSistemaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfiguracaoSistemas to delete
     */
    where?: ConfiguracaoSistemaWhereInput
  }

  /**
   * ConfiguracaoSistema without action
   */
  export type ConfiguracaoSistemaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfiguracaoSistema
     */
    select?: ConfiguracaoSistemaSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EmpresaScalarFieldEnum: {
    id: 'id',
    razaoSocial: 'razaoSocial',
    nomeFantasia: 'nomeFantasia',
    cnpj: 'cnpj',
    inscricaoEstadual: 'inscricaoEstadual',
    endereco: 'endereco',
    cidade: 'cidade',
    uf: 'uf',
    cep: 'cep',
    telefone: 'telefone',
    email: 'email',
    logo: 'logo',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmpresaScalarFieldEnum = (typeof EmpresaScalarFieldEnum)[keyof typeof EmpresaScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    perfil: 'perfil',
    ativo: 'ativo',
    ultimoLogin: 'ultimoLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const ConselhoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    sigla: 'sigla',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConselhoScalarFieldEnum = (typeof ConselhoScalarFieldEnum)[keyof typeof ConselhoScalarFieldEnum]


  export const ProfissionalScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    documento: 'documento',
    registro: 'registro',
    conselhoId: 'conselhoId',
    telefone: 'telefone',
    email: 'email',
    endereco: 'endereco',
    cidade: 'cidade',
    uf: 'uf',
    cep: 'cep',
    tipo: 'tipo',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfissionalScalarFieldEnum = (typeof ProfissionalScalarFieldEnum)[keyof typeof ProfissionalScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    endereco: 'endereco',
    numero: 'numero',
    complemento: 'complemento',
    bairro: 'bairro',
    cep: 'cep',
    cidade: 'cidade',
    uf: 'uf',
    telefone: 'telefone',
    fax: 'fax',
    celular: 'celular',
    email: 'email',
    cpfCnpj: 'cpfCnpj',
    contato: 'contato',
    dataCadastro: 'dataCadastro',
    restricao: 'restricao',
    dataAtualizacao: 'dataAtualizacao',
    ativo: 'ativo',
    codVetResp: 'codVetResp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const EspecieScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EspecieScalarFieldEnum = (typeof EspecieScalarFieldEnum)[keyof typeof EspecieScalarFieldEnum]


  export const AnimalScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    especieId: 'especieId',
    raca: 'raca',
    sexo: 'sexo',
    idade: 'idade',
    peso: 'peso',
    cor: 'cor',
    clienteId: 'clienteId',
    observacoes: 'observacoes',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnimalScalarFieldEnum = (typeof AnimalScalarFieldEnum)[keyof typeof AnimalScalarFieldEnum]


  export const ExameScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    nome: 'nome',
    descricao: 'descricao',
    metodologia: 'metodologia',
    material: 'material',
    valor: 'valor',
    tempoResultado: 'tempoResultado',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExameScalarFieldEnum = (typeof ExameScalarFieldEnum)[keyof typeof ExameScalarFieldEnum]


  export const ParametroExameScalarFieldEnum: {
    id: 'id',
    exameId: 'exameId',
    nome: 'nome',
    unidade: 'unidade',
    valorReferencia: 'valorReferencia',
    ordem: 'ordem',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParametroExameScalarFieldEnum = (typeof ParametroExameScalarFieldEnum)[keyof typeof ParametroExameScalarFieldEnum]


  export const PedidoScalarFieldEnum: {
    id: 'id',
    numero: 'numero',
    clienteId: 'clienteId',
    animalId: 'animalId',
    profissionalId: 'profissionalId',
    usuarioId: 'usuarioId',
    dataColeta: 'dataColeta',
    observacoes: 'observacoes',
    status: 'status',
    valorTotal: 'valorTotal',
    desconto: 'desconto',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PedidoScalarFieldEnum = (typeof PedidoScalarFieldEnum)[keyof typeof PedidoScalarFieldEnum]


  export const PedidoExameScalarFieldEnum: {
    id: 'id',
    pedidoId: 'pedidoId',
    exameId: 'exameId',
    valor: 'valor',
    status: 'status',
    observacoes: 'observacoes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PedidoExameScalarFieldEnum = (typeof PedidoExameScalarFieldEnum)[keyof typeof PedidoExameScalarFieldEnum]


  export const ResultadoExameScalarFieldEnum: {
    id: 'id',
    pedidoExameId: 'pedidoExameId',
    parametroId: 'parametroId',
    valor: 'valor',
    observacao: 'observacao',
    alterado: 'alterado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResultadoExameScalarFieldEnum = (typeof ResultadoExameScalarFieldEnum)[keyof typeof ResultadoExameScalarFieldEnum]


  export const LaudoScalarFieldEnum: {
    id: 'id',
    pedidoId: 'pedidoId',
    profissionalId: 'profissionalId',
    usuarioId: 'usuarioId',
    conteudo: 'conteudo',
    observacoes: 'observacoes',
    dataLiberacao: 'dataLiberacao',
    assinado: 'assinado',
    enviado: 'enviado',
    dataEnvio: 'dataEnvio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaudoScalarFieldEnum = (typeof LaudoScalarFieldEnum)[keyof typeof LaudoScalarFieldEnum]


  export const BancoScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    nome: 'nome',
    agencia: 'agencia',
    nomeAgencia: 'nomeAgencia',
    conta: 'conta',
    ativo: 'ativo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BancoScalarFieldEnum = (typeof BancoScalarFieldEnum)[keyof typeof BancoScalarFieldEnum]


  export const ContaScalarFieldEnum: {
    id: 'id',
    pedidoId: 'pedidoId',
    bancoId: 'bancoId',
    tipo: 'tipo',
    descricao: 'descricao',
    valor: 'valor',
    dataVencimento: 'dataVencimento',
    dataPagamento: 'dataPagamento',
    status: 'status',
    observacoes: 'observacoes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContaScalarFieldEnum = (typeof ContaScalarFieldEnum)[keyof typeof ContaScalarFieldEnum]


  export const LogSistemaScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    acao: 'acao',
    tabela: 'tabela',
    registroId: 'registroId',
    dadosAntigos: 'dadosAntigos',
    dadosNovos: 'dadosNovos',
    ip: 'ip',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type LogSistemaScalarFieldEnum = (typeof LogSistemaScalarFieldEnum)[keyof typeof LogSistemaScalarFieldEnum]


  export const ConfiguracaoSistemaScalarFieldEnum: {
    id: 'id',
    chave: 'chave',
    valor: 'valor',
    descricao: 'descricao',
    tipo: 'tipo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfiguracaoSistemaScalarFieldEnum = (typeof ConfiguracaoSistemaScalarFieldEnum)[keyof typeof ConfiguracaoSistemaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PerfilUsuario'
   */
  export type EnumPerfilUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerfilUsuario'>
    


  /**
   * Reference to a field of type 'PerfilUsuario[]'
   */
  export type ListEnumPerfilUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerfilUsuario[]'>
    


  /**
   * Reference to a field of type 'TipoProfissional'
   */
  export type EnumTipoProfissionalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoProfissional'>
    


  /**
   * Reference to a field of type 'TipoProfissional[]'
   */
  export type ListEnumTipoProfissionalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoProfissional[]'>
    


  /**
   * Reference to a field of type 'SexoAnimal'
   */
  export type EnumSexoAnimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SexoAnimal'>
    


  /**
   * Reference to a field of type 'SexoAnimal[]'
   */
  export type ListEnumSexoAnimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SexoAnimal[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'StatusPedido'
   */
  export type EnumStatusPedidoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusPedido'>
    


  /**
   * Reference to a field of type 'StatusPedido[]'
   */
  export type ListEnumStatusPedidoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusPedido[]'>
    


  /**
   * Reference to a field of type 'StatusExame'
   */
  export type EnumStatusExameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusExame'>
    


  /**
   * Reference to a field of type 'StatusExame[]'
   */
  export type ListEnumStatusExameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusExame[]'>
    


  /**
   * Reference to a field of type 'TipoConta'
   */
  export type EnumTipoContaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoConta'>
    


  /**
   * Reference to a field of type 'TipoConta[]'
   */
  export type ListEnumTipoContaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoConta[]'>
    


  /**
   * Reference to a field of type 'StatusConta'
   */
  export type EnumStatusContaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusConta'>
    


  /**
   * Reference to a field of type 'StatusConta[]'
   */
  export type ListEnumStatusContaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusConta[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'TipoConfiguracao'
   */
  export type EnumTipoConfiguracaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoConfiguracao'>
    


  /**
   * Reference to a field of type 'TipoConfiguracao[]'
   */
  export type ListEnumTipoConfiguracaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoConfiguracao[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type EmpresaWhereInput = {
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    id?: IntFilter<"Empresa"> | number
    razaoSocial?: StringFilter<"Empresa"> | string
    nomeFantasia?: StringNullableFilter<"Empresa"> | string | null
    cnpj?: StringNullableFilter<"Empresa"> | string | null
    inscricaoEstadual?: StringNullableFilter<"Empresa"> | string | null
    endereco?: StringNullableFilter<"Empresa"> | string | null
    cidade?: StringNullableFilter<"Empresa"> | string | null
    uf?: StringNullableFilter<"Empresa"> | string | null
    cep?: StringNullableFilter<"Empresa"> | string | null
    telefone?: StringNullableFilter<"Empresa"> | string | null
    email?: StringNullableFilter<"Empresa"> | string | null
    logo?: StringNullableFilter<"Empresa"> | string | null
    ativo?: BoolFilter<"Empresa"> | boolean
    createdAt?: DateTimeFilter<"Empresa"> | Date | string
    updatedAt?: DateTimeFilter<"Empresa"> | Date | string
  }

  export type EmpresaOrderByWithRelationInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrderInput | SortOrder
    cnpj?: SortOrderInput | SortOrder
    inscricaoEstadual?: SortOrderInput | SortOrder
    endereco?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    uf?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpresaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cnpj?: string
    AND?: EmpresaWhereInput | EmpresaWhereInput[]
    OR?: EmpresaWhereInput[]
    NOT?: EmpresaWhereInput | EmpresaWhereInput[]
    razaoSocial?: StringFilter<"Empresa"> | string
    nomeFantasia?: StringNullableFilter<"Empresa"> | string | null
    inscricaoEstadual?: StringNullableFilter<"Empresa"> | string | null
    endereco?: StringNullableFilter<"Empresa"> | string | null
    cidade?: StringNullableFilter<"Empresa"> | string | null
    uf?: StringNullableFilter<"Empresa"> | string | null
    cep?: StringNullableFilter<"Empresa"> | string | null
    telefone?: StringNullableFilter<"Empresa"> | string | null
    email?: StringNullableFilter<"Empresa"> | string | null
    logo?: StringNullableFilter<"Empresa"> | string | null
    ativo?: BoolFilter<"Empresa"> | boolean
    createdAt?: DateTimeFilter<"Empresa"> | Date | string
    updatedAt?: DateTimeFilter<"Empresa"> | Date | string
  }, "id" | "cnpj">

  export type EmpresaOrderByWithAggregationInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrderInput | SortOrder
    cnpj?: SortOrderInput | SortOrder
    inscricaoEstadual?: SortOrderInput | SortOrder
    endereco?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    uf?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmpresaCountOrderByAggregateInput
    _avg?: EmpresaAvgOrderByAggregateInput
    _max?: EmpresaMaxOrderByAggregateInput
    _min?: EmpresaMinOrderByAggregateInput
    _sum?: EmpresaSumOrderByAggregateInput
  }

  export type EmpresaScalarWhereWithAggregatesInput = {
    AND?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    OR?: EmpresaScalarWhereWithAggregatesInput[]
    NOT?: EmpresaScalarWhereWithAggregatesInput | EmpresaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Empresa"> | number
    razaoSocial?: StringWithAggregatesFilter<"Empresa"> | string
    nomeFantasia?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    cnpj?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    inscricaoEstadual?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    endereco?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    cidade?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    uf?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    cep?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    telefone?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    email?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Empresa"> | string | null
    ativo?: BoolWithAggregatesFilter<"Empresa"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Empresa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Empresa"> | Date | string
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nome?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    perfil?: EnumPerfilUsuarioFilter<"Usuario"> | $Enums.PerfilUsuario
    ativo?: BoolFilter<"Usuario"> | boolean
    ultimoLogin?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    pedidosCriados?: PedidoListRelationFilter
    laudosLiberados?: LaudoListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
    ultimoLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pedidosCriados?: PedidoOrderByRelationAggregateInput
    laudosLiberados?: LaudoOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nome?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    perfil?: EnumPerfilUsuarioFilter<"Usuario"> | $Enums.PerfilUsuario
    ativo?: BoolFilter<"Usuario"> | boolean
    ultimoLogin?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    pedidosCriados?: PedidoListRelationFilter
    laudosLiberados?: LaudoListRelationFilter
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
    ultimoLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    nome?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    senha?: StringWithAggregatesFilter<"Usuario"> | string
    perfil?: EnumPerfilUsuarioWithAggregatesFilter<"Usuario"> | $Enums.PerfilUsuario
    ativo?: BoolWithAggregatesFilter<"Usuario"> | boolean
    ultimoLogin?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type ConselhoWhereInput = {
    AND?: ConselhoWhereInput | ConselhoWhereInput[]
    OR?: ConselhoWhereInput[]
    NOT?: ConselhoWhereInput | ConselhoWhereInput[]
    id?: IntFilter<"Conselho"> | number
    nome?: StringFilter<"Conselho"> | string
    sigla?: StringFilter<"Conselho"> | string
    ativo?: BoolFilter<"Conselho"> | boolean
    createdAt?: DateTimeFilter<"Conselho"> | Date | string
    updatedAt?: DateTimeFilter<"Conselho"> | Date | string
    profissionais?: ProfissionalListRelationFilter
  }

  export type ConselhoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profissionais?: ProfissionalOrderByRelationAggregateInput
  }

  export type ConselhoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sigla?: string
    AND?: ConselhoWhereInput | ConselhoWhereInput[]
    OR?: ConselhoWhereInput[]
    NOT?: ConselhoWhereInput | ConselhoWhereInput[]
    nome?: StringFilter<"Conselho"> | string
    ativo?: BoolFilter<"Conselho"> | boolean
    createdAt?: DateTimeFilter<"Conselho"> | Date | string
    updatedAt?: DateTimeFilter<"Conselho"> | Date | string
    profissionais?: ProfissionalListRelationFilter
  }, "id" | "sigla">

  export type ConselhoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConselhoCountOrderByAggregateInput
    _avg?: ConselhoAvgOrderByAggregateInput
    _max?: ConselhoMaxOrderByAggregateInput
    _min?: ConselhoMinOrderByAggregateInput
    _sum?: ConselhoSumOrderByAggregateInput
  }

  export type ConselhoScalarWhereWithAggregatesInput = {
    AND?: ConselhoScalarWhereWithAggregatesInput | ConselhoScalarWhereWithAggregatesInput[]
    OR?: ConselhoScalarWhereWithAggregatesInput[]
    NOT?: ConselhoScalarWhereWithAggregatesInput | ConselhoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Conselho"> | number
    nome?: StringWithAggregatesFilter<"Conselho"> | string
    sigla?: StringWithAggregatesFilter<"Conselho"> | string
    ativo?: BoolWithAggregatesFilter<"Conselho"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Conselho"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conselho"> | Date | string
  }

  export type ProfissionalWhereInput = {
    AND?: ProfissionalWhereInput | ProfissionalWhereInput[]
    OR?: ProfissionalWhereInput[]
    NOT?: ProfissionalWhereInput | ProfissionalWhereInput[]
    id?: IntFilter<"Profissional"> | number
    nome?: StringFilter<"Profissional"> | string
    documento?: StringNullableFilter<"Profissional"> | string | null
    registro?: StringNullableFilter<"Profissional"> | string | null
    conselhoId?: IntNullableFilter<"Profissional"> | number | null
    telefone?: StringNullableFilter<"Profissional"> | string | null
    email?: StringNullableFilter<"Profissional"> | string | null
    endereco?: StringNullableFilter<"Profissional"> | string | null
    cidade?: StringNullableFilter<"Profissional"> | string | null
    uf?: StringNullableFilter<"Profissional"> | string | null
    cep?: StringNullableFilter<"Profissional"> | string | null
    tipo?: EnumTipoProfissionalFilter<"Profissional"> | $Enums.TipoProfissional
    ativo?: BoolFilter<"Profissional"> | boolean
    createdAt?: DateTimeFilter<"Profissional"> | Date | string
    updatedAt?: DateTimeFilter<"Profissional"> | Date | string
    conselho?: XOR<ConselhoNullableRelationFilter, ConselhoWhereInput> | null
    pedidosSolicitados?: PedidoListRelationFilter
    laudosAssinados?: LaudoListRelationFilter
    clientesResponsavel?: ClienteListRelationFilter
  }

  export type ProfissionalOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrderInput | SortOrder
    registro?: SortOrderInput | SortOrder
    conselhoId?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    endereco?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    uf?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    tipo?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conselho?: ConselhoOrderByWithRelationInput
    pedidosSolicitados?: PedidoOrderByRelationAggregateInput
    laudosAssinados?: LaudoOrderByRelationAggregateInput
    clientesResponsavel?: ClienteOrderByRelationAggregateInput
  }

  export type ProfissionalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProfissionalWhereInput | ProfissionalWhereInput[]
    OR?: ProfissionalWhereInput[]
    NOT?: ProfissionalWhereInput | ProfissionalWhereInput[]
    nome?: StringFilter<"Profissional"> | string
    documento?: StringNullableFilter<"Profissional"> | string | null
    registro?: StringNullableFilter<"Profissional"> | string | null
    conselhoId?: IntNullableFilter<"Profissional"> | number | null
    telefone?: StringNullableFilter<"Profissional"> | string | null
    email?: StringNullableFilter<"Profissional"> | string | null
    endereco?: StringNullableFilter<"Profissional"> | string | null
    cidade?: StringNullableFilter<"Profissional"> | string | null
    uf?: StringNullableFilter<"Profissional"> | string | null
    cep?: StringNullableFilter<"Profissional"> | string | null
    tipo?: EnumTipoProfissionalFilter<"Profissional"> | $Enums.TipoProfissional
    ativo?: BoolFilter<"Profissional"> | boolean
    createdAt?: DateTimeFilter<"Profissional"> | Date | string
    updatedAt?: DateTimeFilter<"Profissional"> | Date | string
    conselho?: XOR<ConselhoNullableRelationFilter, ConselhoWhereInput> | null
    pedidosSolicitados?: PedidoListRelationFilter
    laudosAssinados?: LaudoListRelationFilter
    clientesResponsavel?: ClienteListRelationFilter
  }, "id">

  export type ProfissionalOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrderInput | SortOrder
    registro?: SortOrderInput | SortOrder
    conselhoId?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    endereco?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    uf?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    tipo?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfissionalCountOrderByAggregateInput
    _avg?: ProfissionalAvgOrderByAggregateInput
    _max?: ProfissionalMaxOrderByAggregateInput
    _min?: ProfissionalMinOrderByAggregateInput
    _sum?: ProfissionalSumOrderByAggregateInput
  }

  export type ProfissionalScalarWhereWithAggregatesInput = {
    AND?: ProfissionalScalarWhereWithAggregatesInput | ProfissionalScalarWhereWithAggregatesInput[]
    OR?: ProfissionalScalarWhereWithAggregatesInput[]
    NOT?: ProfissionalScalarWhereWithAggregatesInput | ProfissionalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Profissional"> | number
    nome?: StringWithAggregatesFilter<"Profissional"> | string
    documento?: StringNullableWithAggregatesFilter<"Profissional"> | string | null
    registro?: StringNullableWithAggregatesFilter<"Profissional"> | string | null
    conselhoId?: IntNullableWithAggregatesFilter<"Profissional"> | number | null
    telefone?: StringNullableWithAggregatesFilter<"Profissional"> | string | null
    email?: StringNullableWithAggregatesFilter<"Profissional"> | string | null
    endereco?: StringNullableWithAggregatesFilter<"Profissional"> | string | null
    cidade?: StringNullableWithAggregatesFilter<"Profissional"> | string | null
    uf?: StringNullableWithAggregatesFilter<"Profissional"> | string | null
    cep?: StringNullableWithAggregatesFilter<"Profissional"> | string | null
    tipo?: EnumTipoProfissionalWithAggregatesFilter<"Profissional"> | $Enums.TipoProfissional
    ativo?: BoolWithAggregatesFilter<"Profissional"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Profissional"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profissional"> | Date | string
  }

  export type ClienteWhereInput = {
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    id?: IntFilter<"Cliente"> | number
    nome?: StringFilter<"Cliente"> | string
    endereco?: StringNullableFilter<"Cliente"> | string | null
    numero?: StringNullableFilter<"Cliente"> | string | null
    complemento?: StringNullableFilter<"Cliente"> | string | null
    bairro?: StringNullableFilter<"Cliente"> | string | null
    cep?: StringNullableFilter<"Cliente"> | string | null
    cidade?: StringNullableFilter<"Cliente"> | string | null
    uf?: StringNullableFilter<"Cliente"> | string | null
    telefone?: StringNullableFilter<"Cliente"> | string | null
    fax?: StringNullableFilter<"Cliente"> | string | null
    celular?: StringNullableFilter<"Cliente"> | string | null
    email?: StringNullableFilter<"Cliente"> | string | null
    cpfCnpj?: StringNullableFilter<"Cliente"> | string | null
    contato?: StringNullableFilter<"Cliente"> | string | null
    dataCadastro?: DateTimeFilter<"Cliente"> | Date | string
    restricao?: StringNullableFilter<"Cliente"> | string | null
    dataAtualizacao?: DateTimeNullableFilter<"Cliente"> | Date | string | null
    ativo?: StringFilter<"Cliente"> | string
    codVetResp?: IntNullableFilter<"Cliente"> | number | null
    createdAt?: DateTimeFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeFilter<"Cliente"> | Date | string
    animais?: AnimalListRelationFilter
    pedidos?: PedidoListRelationFilter
    veterinarioResp?: XOR<ProfissionalNullableRelationFilter, ProfissionalWhereInput> | null
  }

  export type ClienteOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    endereco?: SortOrderInput | SortOrder
    numero?: SortOrderInput | SortOrder
    complemento?: SortOrderInput | SortOrder
    bairro?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    uf?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    cpfCnpj?: SortOrderInput | SortOrder
    contato?: SortOrderInput | SortOrder
    dataCadastro?: SortOrder
    restricao?: SortOrderInput | SortOrder
    dataAtualizacao?: SortOrderInput | SortOrder
    ativo?: SortOrder
    codVetResp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    animais?: AnimalOrderByRelationAggregateInput
    pedidos?: PedidoOrderByRelationAggregateInput
    veterinarioResp?: ProfissionalOrderByWithRelationInput
  }

  export type ClienteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    nome?: StringFilter<"Cliente"> | string
    endereco?: StringNullableFilter<"Cliente"> | string | null
    numero?: StringNullableFilter<"Cliente"> | string | null
    complemento?: StringNullableFilter<"Cliente"> | string | null
    bairro?: StringNullableFilter<"Cliente"> | string | null
    cep?: StringNullableFilter<"Cliente"> | string | null
    cidade?: StringNullableFilter<"Cliente"> | string | null
    uf?: StringNullableFilter<"Cliente"> | string | null
    telefone?: StringNullableFilter<"Cliente"> | string | null
    fax?: StringNullableFilter<"Cliente"> | string | null
    celular?: StringNullableFilter<"Cliente"> | string | null
    email?: StringNullableFilter<"Cliente"> | string | null
    cpfCnpj?: StringNullableFilter<"Cliente"> | string | null
    contato?: StringNullableFilter<"Cliente"> | string | null
    dataCadastro?: DateTimeFilter<"Cliente"> | Date | string
    restricao?: StringNullableFilter<"Cliente"> | string | null
    dataAtualizacao?: DateTimeNullableFilter<"Cliente"> | Date | string | null
    ativo?: StringFilter<"Cliente"> | string
    codVetResp?: IntNullableFilter<"Cliente"> | number | null
    createdAt?: DateTimeFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeFilter<"Cliente"> | Date | string
    animais?: AnimalListRelationFilter
    pedidos?: PedidoListRelationFilter
    veterinarioResp?: XOR<ProfissionalNullableRelationFilter, ProfissionalWhereInput> | null
  }, "id">

  export type ClienteOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    endereco?: SortOrderInput | SortOrder
    numero?: SortOrderInput | SortOrder
    complemento?: SortOrderInput | SortOrder
    bairro?: SortOrderInput | SortOrder
    cep?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    uf?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    fax?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    cpfCnpj?: SortOrderInput | SortOrder
    contato?: SortOrderInput | SortOrder
    dataCadastro?: SortOrder
    restricao?: SortOrderInput | SortOrder
    dataAtualizacao?: SortOrderInput | SortOrder
    ativo?: SortOrder
    codVetResp?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _avg?: ClienteAvgOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
    _sum?: ClienteSumOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    OR?: ClienteScalarWhereWithAggregatesInput[]
    NOT?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cliente"> | number
    nome?: StringWithAggregatesFilter<"Cliente"> | string
    endereco?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    numero?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    complemento?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    bairro?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    cep?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    cidade?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    uf?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    telefone?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    fax?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    celular?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    email?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    cpfCnpj?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    contato?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    dataCadastro?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
    restricao?: StringNullableWithAggregatesFilter<"Cliente"> | string | null
    dataAtualizacao?: DateTimeNullableWithAggregatesFilter<"Cliente"> | Date | string | null
    ativo?: StringWithAggregatesFilter<"Cliente"> | string
    codVetResp?: IntNullableWithAggregatesFilter<"Cliente"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cliente"> | Date | string
  }

  export type EspecieWhereInput = {
    AND?: EspecieWhereInput | EspecieWhereInput[]
    OR?: EspecieWhereInput[]
    NOT?: EspecieWhereInput | EspecieWhereInput[]
    id?: IntFilter<"Especie"> | number
    nome?: StringFilter<"Especie"> | string
    ativo?: BoolFilter<"Especie"> | boolean
    createdAt?: DateTimeFilter<"Especie"> | Date | string
    updatedAt?: DateTimeFilter<"Especie"> | Date | string
    animais?: AnimalListRelationFilter
  }

  export type EspecieOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    animais?: AnimalOrderByRelationAggregateInput
  }

  export type EspecieWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: EspecieWhereInput | EspecieWhereInput[]
    OR?: EspecieWhereInput[]
    NOT?: EspecieWhereInput | EspecieWhereInput[]
    ativo?: BoolFilter<"Especie"> | boolean
    createdAt?: DateTimeFilter<"Especie"> | Date | string
    updatedAt?: DateTimeFilter<"Especie"> | Date | string
    animais?: AnimalListRelationFilter
  }, "id" | "nome">

  export type EspecieOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EspecieCountOrderByAggregateInput
    _avg?: EspecieAvgOrderByAggregateInput
    _max?: EspecieMaxOrderByAggregateInput
    _min?: EspecieMinOrderByAggregateInput
    _sum?: EspecieSumOrderByAggregateInput
  }

  export type EspecieScalarWhereWithAggregatesInput = {
    AND?: EspecieScalarWhereWithAggregatesInput | EspecieScalarWhereWithAggregatesInput[]
    OR?: EspecieScalarWhereWithAggregatesInput[]
    NOT?: EspecieScalarWhereWithAggregatesInput | EspecieScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Especie"> | number
    nome?: StringWithAggregatesFilter<"Especie"> | string
    ativo?: BoolWithAggregatesFilter<"Especie"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Especie"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Especie"> | Date | string
  }

  export type AnimalWhereInput = {
    AND?: AnimalWhereInput | AnimalWhereInput[]
    OR?: AnimalWhereInput[]
    NOT?: AnimalWhereInput | AnimalWhereInput[]
    id?: IntFilter<"Animal"> | number
    nome?: StringFilter<"Animal"> | string
    especieId?: IntFilter<"Animal"> | number
    raca?: StringNullableFilter<"Animal"> | string | null
    sexo?: EnumSexoAnimalFilter<"Animal"> | $Enums.SexoAnimal
    idade?: StringNullableFilter<"Animal"> | string | null
    peso?: DecimalNullableFilter<"Animal"> | Decimal | DecimalJsLike | number | string | null
    cor?: StringNullableFilter<"Animal"> | string | null
    clienteId?: IntFilter<"Animal"> | number
    observacoes?: StringNullableFilter<"Animal"> | string | null
    ativo?: BoolFilter<"Animal"> | boolean
    createdAt?: DateTimeFilter<"Animal"> | Date | string
    updatedAt?: DateTimeFilter<"Animal"> | Date | string
    especie?: XOR<EspecieRelationFilter, EspecieWhereInput>
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    pedidos?: PedidoListRelationFilter
  }

  export type AnimalOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    especieId?: SortOrder
    raca?: SortOrderInput | SortOrder
    sexo?: SortOrder
    idade?: SortOrderInput | SortOrder
    peso?: SortOrderInput | SortOrder
    cor?: SortOrderInput | SortOrder
    clienteId?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    especie?: EspecieOrderByWithRelationInput
    cliente?: ClienteOrderByWithRelationInput
    pedidos?: PedidoOrderByRelationAggregateInput
  }

  export type AnimalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnimalWhereInput | AnimalWhereInput[]
    OR?: AnimalWhereInput[]
    NOT?: AnimalWhereInput | AnimalWhereInput[]
    nome?: StringFilter<"Animal"> | string
    especieId?: IntFilter<"Animal"> | number
    raca?: StringNullableFilter<"Animal"> | string | null
    sexo?: EnumSexoAnimalFilter<"Animal"> | $Enums.SexoAnimal
    idade?: StringNullableFilter<"Animal"> | string | null
    peso?: DecimalNullableFilter<"Animal"> | Decimal | DecimalJsLike | number | string | null
    cor?: StringNullableFilter<"Animal"> | string | null
    clienteId?: IntFilter<"Animal"> | number
    observacoes?: StringNullableFilter<"Animal"> | string | null
    ativo?: BoolFilter<"Animal"> | boolean
    createdAt?: DateTimeFilter<"Animal"> | Date | string
    updatedAt?: DateTimeFilter<"Animal"> | Date | string
    especie?: XOR<EspecieRelationFilter, EspecieWhereInput>
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    pedidos?: PedidoListRelationFilter
  }, "id">

  export type AnimalOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    especieId?: SortOrder
    raca?: SortOrderInput | SortOrder
    sexo?: SortOrder
    idade?: SortOrderInput | SortOrder
    peso?: SortOrderInput | SortOrder
    cor?: SortOrderInput | SortOrder
    clienteId?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnimalCountOrderByAggregateInput
    _avg?: AnimalAvgOrderByAggregateInput
    _max?: AnimalMaxOrderByAggregateInput
    _min?: AnimalMinOrderByAggregateInput
    _sum?: AnimalSumOrderByAggregateInput
  }

  export type AnimalScalarWhereWithAggregatesInput = {
    AND?: AnimalScalarWhereWithAggregatesInput | AnimalScalarWhereWithAggregatesInput[]
    OR?: AnimalScalarWhereWithAggregatesInput[]
    NOT?: AnimalScalarWhereWithAggregatesInput | AnimalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Animal"> | number
    nome?: StringWithAggregatesFilter<"Animal"> | string
    especieId?: IntWithAggregatesFilter<"Animal"> | number
    raca?: StringNullableWithAggregatesFilter<"Animal"> | string | null
    sexo?: EnumSexoAnimalWithAggregatesFilter<"Animal"> | $Enums.SexoAnimal
    idade?: StringNullableWithAggregatesFilter<"Animal"> | string | null
    peso?: DecimalNullableWithAggregatesFilter<"Animal"> | Decimal | DecimalJsLike | number | string | null
    cor?: StringNullableWithAggregatesFilter<"Animal"> | string | null
    clienteId?: IntWithAggregatesFilter<"Animal"> | number
    observacoes?: StringNullableWithAggregatesFilter<"Animal"> | string | null
    ativo?: BoolWithAggregatesFilter<"Animal"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Animal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Animal"> | Date | string
  }

  export type ExameWhereInput = {
    AND?: ExameWhereInput | ExameWhereInput[]
    OR?: ExameWhereInput[]
    NOT?: ExameWhereInput | ExameWhereInput[]
    id?: IntFilter<"Exame"> | number
    codigo?: StringFilter<"Exame"> | string
    nome?: StringFilter<"Exame"> | string
    descricao?: StringNullableFilter<"Exame"> | string | null
    metodologia?: StringNullableFilter<"Exame"> | string | null
    material?: StringNullableFilter<"Exame"> | string | null
    valor?: DecimalNullableFilter<"Exame"> | Decimal | DecimalJsLike | number | string | null
    tempoResultado?: IntNullableFilter<"Exame"> | number | null
    ativo?: BoolFilter<"Exame"> | boolean
    createdAt?: DateTimeFilter<"Exame"> | Date | string
    updatedAt?: DateTimeFilter<"Exame"> | Date | string
    parametros?: ParametroExameListRelationFilter
    pedidoExames?: PedidoExameListRelationFilter
  }

  export type ExameOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    metodologia?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    valor?: SortOrderInput | SortOrder
    tempoResultado?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parametros?: ParametroExameOrderByRelationAggregateInput
    pedidoExames?: PedidoExameOrderByRelationAggregateInput
  }

  export type ExameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigo?: string
    AND?: ExameWhereInput | ExameWhereInput[]
    OR?: ExameWhereInput[]
    NOT?: ExameWhereInput | ExameWhereInput[]
    nome?: StringFilter<"Exame"> | string
    descricao?: StringNullableFilter<"Exame"> | string | null
    metodologia?: StringNullableFilter<"Exame"> | string | null
    material?: StringNullableFilter<"Exame"> | string | null
    valor?: DecimalNullableFilter<"Exame"> | Decimal | DecimalJsLike | number | string | null
    tempoResultado?: IntNullableFilter<"Exame"> | number | null
    ativo?: BoolFilter<"Exame"> | boolean
    createdAt?: DateTimeFilter<"Exame"> | Date | string
    updatedAt?: DateTimeFilter<"Exame"> | Date | string
    parametros?: ParametroExameListRelationFilter
    pedidoExames?: PedidoExameListRelationFilter
  }, "id" | "codigo">

  export type ExameOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    metodologia?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    valor?: SortOrderInput | SortOrder
    tempoResultado?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExameCountOrderByAggregateInput
    _avg?: ExameAvgOrderByAggregateInput
    _max?: ExameMaxOrderByAggregateInput
    _min?: ExameMinOrderByAggregateInput
    _sum?: ExameSumOrderByAggregateInput
  }

  export type ExameScalarWhereWithAggregatesInput = {
    AND?: ExameScalarWhereWithAggregatesInput | ExameScalarWhereWithAggregatesInput[]
    OR?: ExameScalarWhereWithAggregatesInput[]
    NOT?: ExameScalarWhereWithAggregatesInput | ExameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Exame"> | number
    codigo?: StringWithAggregatesFilter<"Exame"> | string
    nome?: StringWithAggregatesFilter<"Exame"> | string
    descricao?: StringNullableWithAggregatesFilter<"Exame"> | string | null
    metodologia?: StringNullableWithAggregatesFilter<"Exame"> | string | null
    material?: StringNullableWithAggregatesFilter<"Exame"> | string | null
    valor?: DecimalNullableWithAggregatesFilter<"Exame"> | Decimal | DecimalJsLike | number | string | null
    tempoResultado?: IntNullableWithAggregatesFilter<"Exame"> | number | null
    ativo?: BoolWithAggregatesFilter<"Exame"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Exame"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exame"> | Date | string
  }

  export type ParametroExameWhereInput = {
    AND?: ParametroExameWhereInput | ParametroExameWhereInput[]
    OR?: ParametroExameWhereInput[]
    NOT?: ParametroExameWhereInput | ParametroExameWhereInput[]
    id?: IntFilter<"ParametroExame"> | number
    exameId?: IntFilter<"ParametroExame"> | number
    nome?: StringFilter<"ParametroExame"> | string
    unidade?: StringNullableFilter<"ParametroExame"> | string | null
    valorReferencia?: StringNullableFilter<"ParametroExame"> | string | null
    ordem?: IntFilter<"ParametroExame"> | number
    ativo?: BoolFilter<"ParametroExame"> | boolean
    createdAt?: DateTimeFilter<"ParametroExame"> | Date | string
    updatedAt?: DateTimeFilter<"ParametroExame"> | Date | string
    exame?: XOR<ExameRelationFilter, ExameWhereInput>
    resultados?: ResultadoExameListRelationFilter
  }

  export type ParametroExameOrderByWithRelationInput = {
    id?: SortOrder
    exameId?: SortOrder
    nome?: SortOrder
    unidade?: SortOrderInput | SortOrder
    valorReferencia?: SortOrderInput | SortOrder
    ordem?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exame?: ExameOrderByWithRelationInput
    resultados?: ResultadoExameOrderByRelationAggregateInput
  }

  export type ParametroExameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParametroExameWhereInput | ParametroExameWhereInput[]
    OR?: ParametroExameWhereInput[]
    NOT?: ParametroExameWhereInput | ParametroExameWhereInput[]
    exameId?: IntFilter<"ParametroExame"> | number
    nome?: StringFilter<"ParametroExame"> | string
    unidade?: StringNullableFilter<"ParametroExame"> | string | null
    valorReferencia?: StringNullableFilter<"ParametroExame"> | string | null
    ordem?: IntFilter<"ParametroExame"> | number
    ativo?: BoolFilter<"ParametroExame"> | boolean
    createdAt?: DateTimeFilter<"ParametroExame"> | Date | string
    updatedAt?: DateTimeFilter<"ParametroExame"> | Date | string
    exame?: XOR<ExameRelationFilter, ExameWhereInput>
    resultados?: ResultadoExameListRelationFilter
  }, "id">

  export type ParametroExameOrderByWithAggregationInput = {
    id?: SortOrder
    exameId?: SortOrder
    nome?: SortOrder
    unidade?: SortOrderInput | SortOrder
    valorReferencia?: SortOrderInput | SortOrder
    ordem?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParametroExameCountOrderByAggregateInput
    _avg?: ParametroExameAvgOrderByAggregateInput
    _max?: ParametroExameMaxOrderByAggregateInput
    _min?: ParametroExameMinOrderByAggregateInput
    _sum?: ParametroExameSumOrderByAggregateInput
  }

  export type ParametroExameScalarWhereWithAggregatesInput = {
    AND?: ParametroExameScalarWhereWithAggregatesInput | ParametroExameScalarWhereWithAggregatesInput[]
    OR?: ParametroExameScalarWhereWithAggregatesInput[]
    NOT?: ParametroExameScalarWhereWithAggregatesInput | ParametroExameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParametroExame"> | number
    exameId?: IntWithAggregatesFilter<"ParametroExame"> | number
    nome?: StringWithAggregatesFilter<"ParametroExame"> | string
    unidade?: StringNullableWithAggregatesFilter<"ParametroExame"> | string | null
    valorReferencia?: StringNullableWithAggregatesFilter<"ParametroExame"> | string | null
    ordem?: IntWithAggregatesFilter<"ParametroExame"> | number
    ativo?: BoolWithAggregatesFilter<"ParametroExame"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ParametroExame"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ParametroExame"> | Date | string
  }

  export type PedidoWhereInput = {
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    id?: IntFilter<"Pedido"> | number
    numero?: StringFilter<"Pedido"> | string
    clienteId?: IntFilter<"Pedido"> | number
    animalId?: IntFilter<"Pedido"> | number
    profissionalId?: IntNullableFilter<"Pedido"> | number | null
    usuarioId?: IntFilter<"Pedido"> | number
    dataColeta?: DateTimeFilter<"Pedido"> | Date | string
    observacoes?: StringNullableFilter<"Pedido"> | string | null
    status?: EnumStatusPedidoFilter<"Pedido"> | $Enums.StatusPedido
    valorTotal?: DecimalNullableFilter<"Pedido"> | Decimal | DecimalJsLike | number | string | null
    desconto?: DecimalNullableFilter<"Pedido"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Pedido"> | Date | string
    updatedAt?: DateTimeFilter<"Pedido"> | Date | string
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    animal?: XOR<AnimalRelationFilter, AnimalWhereInput>
    profissional?: XOR<ProfissionalNullableRelationFilter, ProfissionalWhereInput> | null
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    exames?: PedidoExameListRelationFilter
    laudos?: LaudoListRelationFilter
    contas?: ContaListRelationFilter
  }

  export type PedidoOrderByWithRelationInput = {
    id?: SortOrder
    numero?: SortOrder
    clienteId?: SortOrder
    animalId?: SortOrder
    profissionalId?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    dataColeta?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    status?: SortOrder
    valorTotal?: SortOrderInput | SortOrder
    desconto?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cliente?: ClienteOrderByWithRelationInput
    animal?: AnimalOrderByWithRelationInput
    profissional?: ProfissionalOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
    exames?: PedidoExameOrderByRelationAggregateInput
    laudos?: LaudoOrderByRelationAggregateInput
    contas?: ContaOrderByRelationAggregateInput
  }

  export type PedidoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    numero?: string
    AND?: PedidoWhereInput | PedidoWhereInput[]
    OR?: PedidoWhereInput[]
    NOT?: PedidoWhereInput | PedidoWhereInput[]
    clienteId?: IntFilter<"Pedido"> | number
    animalId?: IntFilter<"Pedido"> | number
    profissionalId?: IntNullableFilter<"Pedido"> | number | null
    usuarioId?: IntFilter<"Pedido"> | number
    dataColeta?: DateTimeFilter<"Pedido"> | Date | string
    observacoes?: StringNullableFilter<"Pedido"> | string | null
    status?: EnumStatusPedidoFilter<"Pedido"> | $Enums.StatusPedido
    valorTotal?: DecimalNullableFilter<"Pedido"> | Decimal | DecimalJsLike | number | string | null
    desconto?: DecimalNullableFilter<"Pedido"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Pedido"> | Date | string
    updatedAt?: DateTimeFilter<"Pedido"> | Date | string
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    animal?: XOR<AnimalRelationFilter, AnimalWhereInput>
    profissional?: XOR<ProfissionalNullableRelationFilter, ProfissionalWhereInput> | null
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    exames?: PedidoExameListRelationFilter
    laudos?: LaudoListRelationFilter
    contas?: ContaListRelationFilter
  }, "id" | "numero">

  export type PedidoOrderByWithAggregationInput = {
    id?: SortOrder
    numero?: SortOrder
    clienteId?: SortOrder
    animalId?: SortOrder
    profissionalId?: SortOrderInput | SortOrder
    usuarioId?: SortOrder
    dataColeta?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    status?: SortOrder
    valorTotal?: SortOrderInput | SortOrder
    desconto?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PedidoCountOrderByAggregateInput
    _avg?: PedidoAvgOrderByAggregateInput
    _max?: PedidoMaxOrderByAggregateInput
    _min?: PedidoMinOrderByAggregateInput
    _sum?: PedidoSumOrderByAggregateInput
  }

  export type PedidoScalarWhereWithAggregatesInput = {
    AND?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    OR?: PedidoScalarWhereWithAggregatesInput[]
    NOT?: PedidoScalarWhereWithAggregatesInput | PedidoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pedido"> | number
    numero?: StringWithAggregatesFilter<"Pedido"> | string
    clienteId?: IntWithAggregatesFilter<"Pedido"> | number
    animalId?: IntWithAggregatesFilter<"Pedido"> | number
    profissionalId?: IntNullableWithAggregatesFilter<"Pedido"> | number | null
    usuarioId?: IntWithAggregatesFilter<"Pedido"> | number
    dataColeta?: DateTimeWithAggregatesFilter<"Pedido"> | Date | string
    observacoes?: StringNullableWithAggregatesFilter<"Pedido"> | string | null
    status?: EnumStatusPedidoWithAggregatesFilter<"Pedido"> | $Enums.StatusPedido
    valorTotal?: DecimalNullableWithAggregatesFilter<"Pedido"> | Decimal | DecimalJsLike | number | string | null
    desconto?: DecimalNullableWithAggregatesFilter<"Pedido"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Pedido"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pedido"> | Date | string
  }

  export type PedidoExameWhereInput = {
    AND?: PedidoExameWhereInput | PedidoExameWhereInput[]
    OR?: PedidoExameWhereInput[]
    NOT?: PedidoExameWhereInput | PedidoExameWhereInput[]
    id?: IntFilter<"PedidoExame"> | number
    pedidoId?: IntFilter<"PedidoExame"> | number
    exameId?: IntFilter<"PedidoExame"> | number
    valor?: DecimalNullableFilter<"PedidoExame"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFilter<"PedidoExame"> | $Enums.StatusExame
    observacoes?: StringNullableFilter<"PedidoExame"> | string | null
    createdAt?: DateTimeFilter<"PedidoExame"> | Date | string
    updatedAt?: DateTimeFilter<"PedidoExame"> | Date | string
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
    exame?: XOR<ExameRelationFilter, ExameWhereInput>
    resultados?: ResultadoExameListRelationFilter
  }

  export type PedidoExameOrderByWithRelationInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    exameId?: SortOrder
    valor?: SortOrderInput | SortOrder
    status?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pedido?: PedidoOrderByWithRelationInput
    exame?: ExameOrderByWithRelationInput
    resultados?: ResultadoExameOrderByRelationAggregateInput
  }

  export type PedidoExameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pedidoId_exameId?: PedidoExamePedidoIdExameIdCompoundUniqueInput
    AND?: PedidoExameWhereInput | PedidoExameWhereInput[]
    OR?: PedidoExameWhereInput[]
    NOT?: PedidoExameWhereInput | PedidoExameWhereInput[]
    pedidoId?: IntFilter<"PedidoExame"> | number
    exameId?: IntFilter<"PedidoExame"> | number
    valor?: DecimalNullableFilter<"PedidoExame"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFilter<"PedidoExame"> | $Enums.StatusExame
    observacoes?: StringNullableFilter<"PedidoExame"> | string | null
    createdAt?: DateTimeFilter<"PedidoExame"> | Date | string
    updatedAt?: DateTimeFilter<"PedidoExame"> | Date | string
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
    exame?: XOR<ExameRelationFilter, ExameWhereInput>
    resultados?: ResultadoExameListRelationFilter
  }, "id" | "pedidoId_exameId">

  export type PedidoExameOrderByWithAggregationInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    exameId?: SortOrder
    valor?: SortOrderInput | SortOrder
    status?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PedidoExameCountOrderByAggregateInput
    _avg?: PedidoExameAvgOrderByAggregateInput
    _max?: PedidoExameMaxOrderByAggregateInput
    _min?: PedidoExameMinOrderByAggregateInput
    _sum?: PedidoExameSumOrderByAggregateInput
  }

  export type PedidoExameScalarWhereWithAggregatesInput = {
    AND?: PedidoExameScalarWhereWithAggregatesInput | PedidoExameScalarWhereWithAggregatesInput[]
    OR?: PedidoExameScalarWhereWithAggregatesInput[]
    NOT?: PedidoExameScalarWhereWithAggregatesInput | PedidoExameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PedidoExame"> | number
    pedidoId?: IntWithAggregatesFilter<"PedidoExame"> | number
    exameId?: IntWithAggregatesFilter<"PedidoExame"> | number
    valor?: DecimalNullableWithAggregatesFilter<"PedidoExame"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameWithAggregatesFilter<"PedidoExame"> | $Enums.StatusExame
    observacoes?: StringNullableWithAggregatesFilter<"PedidoExame"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PedidoExame"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PedidoExame"> | Date | string
  }

  export type ResultadoExameWhereInput = {
    AND?: ResultadoExameWhereInput | ResultadoExameWhereInput[]
    OR?: ResultadoExameWhereInput[]
    NOT?: ResultadoExameWhereInput | ResultadoExameWhereInput[]
    id?: IntFilter<"ResultadoExame"> | number
    pedidoExameId?: IntFilter<"ResultadoExame"> | number
    parametroId?: IntFilter<"ResultadoExame"> | number
    valor?: StringNullableFilter<"ResultadoExame"> | string | null
    observacao?: StringNullableFilter<"ResultadoExame"> | string | null
    alterado?: BoolFilter<"ResultadoExame"> | boolean
    createdAt?: DateTimeFilter<"ResultadoExame"> | Date | string
    updatedAt?: DateTimeFilter<"ResultadoExame"> | Date | string
    pedidoExame?: XOR<PedidoExameRelationFilter, PedidoExameWhereInput>
    parametro?: XOR<ParametroExameRelationFilter, ParametroExameWhereInput>
  }

  export type ResultadoExameOrderByWithRelationInput = {
    id?: SortOrder
    pedidoExameId?: SortOrder
    parametroId?: SortOrder
    valor?: SortOrderInput | SortOrder
    observacao?: SortOrderInput | SortOrder
    alterado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pedidoExame?: PedidoExameOrderByWithRelationInput
    parametro?: ParametroExameOrderByWithRelationInput
  }

  export type ResultadoExameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pedidoExameId_parametroId?: ResultadoExamePedidoExameIdParametroIdCompoundUniqueInput
    AND?: ResultadoExameWhereInput | ResultadoExameWhereInput[]
    OR?: ResultadoExameWhereInput[]
    NOT?: ResultadoExameWhereInput | ResultadoExameWhereInput[]
    pedidoExameId?: IntFilter<"ResultadoExame"> | number
    parametroId?: IntFilter<"ResultadoExame"> | number
    valor?: StringNullableFilter<"ResultadoExame"> | string | null
    observacao?: StringNullableFilter<"ResultadoExame"> | string | null
    alterado?: BoolFilter<"ResultadoExame"> | boolean
    createdAt?: DateTimeFilter<"ResultadoExame"> | Date | string
    updatedAt?: DateTimeFilter<"ResultadoExame"> | Date | string
    pedidoExame?: XOR<PedidoExameRelationFilter, PedidoExameWhereInput>
    parametro?: XOR<ParametroExameRelationFilter, ParametroExameWhereInput>
  }, "id" | "pedidoExameId_parametroId">

  export type ResultadoExameOrderByWithAggregationInput = {
    id?: SortOrder
    pedidoExameId?: SortOrder
    parametroId?: SortOrder
    valor?: SortOrderInput | SortOrder
    observacao?: SortOrderInput | SortOrder
    alterado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResultadoExameCountOrderByAggregateInput
    _avg?: ResultadoExameAvgOrderByAggregateInput
    _max?: ResultadoExameMaxOrderByAggregateInput
    _min?: ResultadoExameMinOrderByAggregateInput
    _sum?: ResultadoExameSumOrderByAggregateInput
  }

  export type ResultadoExameScalarWhereWithAggregatesInput = {
    AND?: ResultadoExameScalarWhereWithAggregatesInput | ResultadoExameScalarWhereWithAggregatesInput[]
    OR?: ResultadoExameScalarWhereWithAggregatesInput[]
    NOT?: ResultadoExameScalarWhereWithAggregatesInput | ResultadoExameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ResultadoExame"> | number
    pedidoExameId?: IntWithAggregatesFilter<"ResultadoExame"> | number
    parametroId?: IntWithAggregatesFilter<"ResultadoExame"> | number
    valor?: StringNullableWithAggregatesFilter<"ResultadoExame"> | string | null
    observacao?: StringNullableWithAggregatesFilter<"ResultadoExame"> | string | null
    alterado?: BoolWithAggregatesFilter<"ResultadoExame"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ResultadoExame"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResultadoExame"> | Date | string
  }

  export type LaudoWhereInput = {
    AND?: LaudoWhereInput | LaudoWhereInput[]
    OR?: LaudoWhereInput[]
    NOT?: LaudoWhereInput | LaudoWhereInput[]
    id?: IntFilter<"Laudo"> | number
    pedidoId?: IntFilter<"Laudo"> | number
    profissionalId?: IntNullableFilter<"Laudo"> | number | null
    usuarioId?: IntNullableFilter<"Laudo"> | number | null
    conteudo?: StringFilter<"Laudo"> | string
    observacoes?: StringNullableFilter<"Laudo"> | string | null
    dataLiberacao?: DateTimeNullableFilter<"Laudo"> | Date | string | null
    assinado?: BoolFilter<"Laudo"> | boolean
    enviado?: BoolFilter<"Laudo"> | boolean
    dataEnvio?: DateTimeNullableFilter<"Laudo"> | Date | string | null
    createdAt?: DateTimeFilter<"Laudo"> | Date | string
    updatedAt?: DateTimeFilter<"Laudo"> | Date | string
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
    profissional?: XOR<ProfissionalNullableRelationFilter, ProfissionalWhereInput> | null
    usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }

  export type LaudoOrderByWithRelationInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    profissionalId?: SortOrderInput | SortOrder
    usuarioId?: SortOrderInput | SortOrder
    conteudo?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    dataLiberacao?: SortOrderInput | SortOrder
    assinado?: SortOrder
    enviado?: SortOrder
    dataEnvio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pedido?: PedidoOrderByWithRelationInput
    profissional?: ProfissionalOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type LaudoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LaudoWhereInput | LaudoWhereInput[]
    OR?: LaudoWhereInput[]
    NOT?: LaudoWhereInput | LaudoWhereInput[]
    pedidoId?: IntFilter<"Laudo"> | number
    profissionalId?: IntNullableFilter<"Laudo"> | number | null
    usuarioId?: IntNullableFilter<"Laudo"> | number | null
    conteudo?: StringFilter<"Laudo"> | string
    observacoes?: StringNullableFilter<"Laudo"> | string | null
    dataLiberacao?: DateTimeNullableFilter<"Laudo"> | Date | string | null
    assinado?: BoolFilter<"Laudo"> | boolean
    enviado?: BoolFilter<"Laudo"> | boolean
    dataEnvio?: DateTimeNullableFilter<"Laudo"> | Date | string | null
    createdAt?: DateTimeFilter<"Laudo"> | Date | string
    updatedAt?: DateTimeFilter<"Laudo"> | Date | string
    pedido?: XOR<PedidoRelationFilter, PedidoWhereInput>
    profissional?: XOR<ProfissionalNullableRelationFilter, ProfissionalWhereInput> | null
    usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }, "id">

  export type LaudoOrderByWithAggregationInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    profissionalId?: SortOrderInput | SortOrder
    usuarioId?: SortOrderInput | SortOrder
    conteudo?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    dataLiberacao?: SortOrderInput | SortOrder
    assinado?: SortOrder
    enviado?: SortOrder
    dataEnvio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaudoCountOrderByAggregateInput
    _avg?: LaudoAvgOrderByAggregateInput
    _max?: LaudoMaxOrderByAggregateInput
    _min?: LaudoMinOrderByAggregateInput
    _sum?: LaudoSumOrderByAggregateInput
  }

  export type LaudoScalarWhereWithAggregatesInput = {
    AND?: LaudoScalarWhereWithAggregatesInput | LaudoScalarWhereWithAggregatesInput[]
    OR?: LaudoScalarWhereWithAggregatesInput[]
    NOT?: LaudoScalarWhereWithAggregatesInput | LaudoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Laudo"> | number
    pedidoId?: IntWithAggregatesFilter<"Laudo"> | number
    profissionalId?: IntNullableWithAggregatesFilter<"Laudo"> | number | null
    usuarioId?: IntNullableWithAggregatesFilter<"Laudo"> | number | null
    conteudo?: StringWithAggregatesFilter<"Laudo"> | string
    observacoes?: StringNullableWithAggregatesFilter<"Laudo"> | string | null
    dataLiberacao?: DateTimeNullableWithAggregatesFilter<"Laudo"> | Date | string | null
    assinado?: BoolWithAggregatesFilter<"Laudo"> | boolean
    enviado?: BoolWithAggregatesFilter<"Laudo"> | boolean
    dataEnvio?: DateTimeNullableWithAggregatesFilter<"Laudo"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Laudo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Laudo"> | Date | string
  }

  export type BancoWhereInput = {
    AND?: BancoWhereInput | BancoWhereInput[]
    OR?: BancoWhereInput[]
    NOT?: BancoWhereInput | BancoWhereInput[]
    id?: IntFilter<"Banco"> | number
    codigo?: StringNullableFilter<"Banco"> | string | null
    nome?: StringFilter<"Banco"> | string
    agencia?: StringNullableFilter<"Banco"> | string | null
    nomeAgencia?: StringNullableFilter<"Banco"> | string | null
    conta?: StringNullableFilter<"Banco"> | string | null
    ativo?: BoolFilter<"Banco"> | boolean
    createdAt?: DateTimeFilter<"Banco"> | Date | string
    updatedAt?: DateTimeFilter<"Banco"> | Date | string
    contas?: ContaListRelationFilter
  }

  export type BancoOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrderInput | SortOrder
    nome?: SortOrder
    agencia?: SortOrderInput | SortOrder
    nomeAgencia?: SortOrderInput | SortOrder
    conta?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contas?: ContaOrderByRelationAggregateInput
  }

  export type BancoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BancoWhereInput | BancoWhereInput[]
    OR?: BancoWhereInput[]
    NOT?: BancoWhereInput | BancoWhereInput[]
    codigo?: StringNullableFilter<"Banco"> | string | null
    nome?: StringFilter<"Banco"> | string
    agencia?: StringNullableFilter<"Banco"> | string | null
    nomeAgencia?: StringNullableFilter<"Banco"> | string | null
    conta?: StringNullableFilter<"Banco"> | string | null
    ativo?: BoolFilter<"Banco"> | boolean
    createdAt?: DateTimeFilter<"Banco"> | Date | string
    updatedAt?: DateTimeFilter<"Banco"> | Date | string
    contas?: ContaListRelationFilter
  }, "id">

  export type BancoOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrderInput | SortOrder
    nome?: SortOrder
    agencia?: SortOrderInput | SortOrder
    nomeAgencia?: SortOrderInput | SortOrder
    conta?: SortOrderInput | SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BancoCountOrderByAggregateInput
    _avg?: BancoAvgOrderByAggregateInput
    _max?: BancoMaxOrderByAggregateInput
    _min?: BancoMinOrderByAggregateInput
    _sum?: BancoSumOrderByAggregateInput
  }

  export type BancoScalarWhereWithAggregatesInput = {
    AND?: BancoScalarWhereWithAggregatesInput | BancoScalarWhereWithAggregatesInput[]
    OR?: BancoScalarWhereWithAggregatesInput[]
    NOT?: BancoScalarWhereWithAggregatesInput | BancoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Banco"> | number
    codigo?: StringNullableWithAggregatesFilter<"Banco"> | string | null
    nome?: StringWithAggregatesFilter<"Banco"> | string
    agencia?: StringNullableWithAggregatesFilter<"Banco"> | string | null
    nomeAgencia?: StringNullableWithAggregatesFilter<"Banco"> | string | null
    conta?: StringNullableWithAggregatesFilter<"Banco"> | string | null
    ativo?: BoolWithAggregatesFilter<"Banco"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Banco"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Banco"> | Date | string
  }

  export type ContaWhereInput = {
    AND?: ContaWhereInput | ContaWhereInput[]
    OR?: ContaWhereInput[]
    NOT?: ContaWhereInput | ContaWhereInput[]
    id?: IntFilter<"Conta"> | number
    pedidoId?: IntNullableFilter<"Conta"> | number | null
    bancoId?: IntNullableFilter<"Conta"> | number | null
    tipo?: EnumTipoContaFilter<"Conta"> | $Enums.TipoConta
    descricao?: StringFilter<"Conta"> | string
    valor?: DecimalFilter<"Conta"> | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFilter<"Conta"> | Date | string
    dataPagamento?: DateTimeNullableFilter<"Conta"> | Date | string | null
    status?: EnumStatusContaFilter<"Conta"> | $Enums.StatusConta
    observacoes?: StringNullableFilter<"Conta"> | string | null
    createdAt?: DateTimeFilter<"Conta"> | Date | string
    updatedAt?: DateTimeFilter<"Conta"> | Date | string
    pedido?: XOR<PedidoNullableRelationFilter, PedidoWhereInput> | null
    banco?: XOR<BancoNullableRelationFilter, BancoWhereInput> | null
  }

  export type ContaOrderByWithRelationInput = {
    id?: SortOrder
    pedidoId?: SortOrderInput | SortOrder
    bancoId?: SortOrderInput | SortOrder
    tipo?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    dataVencimento?: SortOrder
    dataPagamento?: SortOrderInput | SortOrder
    status?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pedido?: PedidoOrderByWithRelationInput
    banco?: BancoOrderByWithRelationInput
  }

  export type ContaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContaWhereInput | ContaWhereInput[]
    OR?: ContaWhereInput[]
    NOT?: ContaWhereInput | ContaWhereInput[]
    pedidoId?: IntNullableFilter<"Conta"> | number | null
    bancoId?: IntNullableFilter<"Conta"> | number | null
    tipo?: EnumTipoContaFilter<"Conta"> | $Enums.TipoConta
    descricao?: StringFilter<"Conta"> | string
    valor?: DecimalFilter<"Conta"> | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFilter<"Conta"> | Date | string
    dataPagamento?: DateTimeNullableFilter<"Conta"> | Date | string | null
    status?: EnumStatusContaFilter<"Conta"> | $Enums.StatusConta
    observacoes?: StringNullableFilter<"Conta"> | string | null
    createdAt?: DateTimeFilter<"Conta"> | Date | string
    updatedAt?: DateTimeFilter<"Conta"> | Date | string
    pedido?: XOR<PedidoNullableRelationFilter, PedidoWhereInput> | null
    banco?: XOR<BancoNullableRelationFilter, BancoWhereInput> | null
  }, "id">

  export type ContaOrderByWithAggregationInput = {
    id?: SortOrder
    pedidoId?: SortOrderInput | SortOrder
    bancoId?: SortOrderInput | SortOrder
    tipo?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    dataVencimento?: SortOrder
    dataPagamento?: SortOrderInput | SortOrder
    status?: SortOrder
    observacoes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContaCountOrderByAggregateInput
    _avg?: ContaAvgOrderByAggregateInput
    _max?: ContaMaxOrderByAggregateInput
    _min?: ContaMinOrderByAggregateInput
    _sum?: ContaSumOrderByAggregateInput
  }

  export type ContaScalarWhereWithAggregatesInput = {
    AND?: ContaScalarWhereWithAggregatesInput | ContaScalarWhereWithAggregatesInput[]
    OR?: ContaScalarWhereWithAggregatesInput[]
    NOT?: ContaScalarWhereWithAggregatesInput | ContaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Conta"> | number
    pedidoId?: IntNullableWithAggregatesFilter<"Conta"> | number | null
    bancoId?: IntNullableWithAggregatesFilter<"Conta"> | number | null
    tipo?: EnumTipoContaWithAggregatesFilter<"Conta"> | $Enums.TipoConta
    descricao?: StringWithAggregatesFilter<"Conta"> | string
    valor?: DecimalWithAggregatesFilter<"Conta"> | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeWithAggregatesFilter<"Conta"> | Date | string
    dataPagamento?: DateTimeNullableWithAggregatesFilter<"Conta"> | Date | string | null
    status?: EnumStatusContaWithAggregatesFilter<"Conta"> | $Enums.StatusConta
    observacoes?: StringNullableWithAggregatesFilter<"Conta"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conta"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conta"> | Date | string
  }

  export type LogSistemaWhereInput = {
    AND?: LogSistemaWhereInput | LogSistemaWhereInput[]
    OR?: LogSistemaWhereInput[]
    NOT?: LogSistemaWhereInput | LogSistemaWhereInput[]
    id?: IntFilter<"LogSistema"> | number
    usuarioId?: IntNullableFilter<"LogSistema"> | number | null
    acao?: StringFilter<"LogSistema"> | string
    tabela?: StringNullableFilter<"LogSistema"> | string | null
    registroId?: IntNullableFilter<"LogSistema"> | number | null
    dadosAntigos?: JsonNullableFilter<"LogSistema">
    dadosNovos?: JsonNullableFilter<"LogSistema">
    ip?: StringNullableFilter<"LogSistema"> | string | null
    userAgent?: StringNullableFilter<"LogSistema"> | string | null
    createdAt?: DateTimeFilter<"LogSistema"> | Date | string
  }

  export type LogSistemaOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrderInput | SortOrder
    acao?: SortOrder
    tabela?: SortOrderInput | SortOrder
    registroId?: SortOrderInput | SortOrder
    dadosAntigos?: SortOrderInput | SortOrder
    dadosNovos?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type LogSistemaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogSistemaWhereInput | LogSistemaWhereInput[]
    OR?: LogSistemaWhereInput[]
    NOT?: LogSistemaWhereInput | LogSistemaWhereInput[]
    usuarioId?: IntNullableFilter<"LogSistema"> | number | null
    acao?: StringFilter<"LogSistema"> | string
    tabela?: StringNullableFilter<"LogSistema"> | string | null
    registroId?: IntNullableFilter<"LogSistema"> | number | null
    dadosAntigos?: JsonNullableFilter<"LogSistema">
    dadosNovos?: JsonNullableFilter<"LogSistema">
    ip?: StringNullableFilter<"LogSistema"> | string | null
    userAgent?: StringNullableFilter<"LogSistema"> | string | null
    createdAt?: DateTimeFilter<"LogSistema"> | Date | string
  }, "id">

  export type LogSistemaOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrderInput | SortOrder
    acao?: SortOrder
    tabela?: SortOrderInput | SortOrder
    registroId?: SortOrderInput | SortOrder
    dadosAntigos?: SortOrderInput | SortOrder
    dadosNovos?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LogSistemaCountOrderByAggregateInput
    _avg?: LogSistemaAvgOrderByAggregateInput
    _max?: LogSistemaMaxOrderByAggregateInput
    _min?: LogSistemaMinOrderByAggregateInput
    _sum?: LogSistemaSumOrderByAggregateInput
  }

  export type LogSistemaScalarWhereWithAggregatesInput = {
    AND?: LogSistemaScalarWhereWithAggregatesInput | LogSistemaScalarWhereWithAggregatesInput[]
    OR?: LogSistemaScalarWhereWithAggregatesInput[]
    NOT?: LogSistemaScalarWhereWithAggregatesInput | LogSistemaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LogSistema"> | number
    usuarioId?: IntNullableWithAggregatesFilter<"LogSistema"> | number | null
    acao?: StringWithAggregatesFilter<"LogSistema"> | string
    tabela?: StringNullableWithAggregatesFilter<"LogSistema"> | string | null
    registroId?: IntNullableWithAggregatesFilter<"LogSistema"> | number | null
    dadosAntigos?: JsonNullableWithAggregatesFilter<"LogSistema">
    dadosNovos?: JsonNullableWithAggregatesFilter<"LogSistema">
    ip?: StringNullableWithAggregatesFilter<"LogSistema"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"LogSistema"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LogSistema"> | Date | string
  }

  export type ConfiguracaoSistemaWhereInput = {
    AND?: ConfiguracaoSistemaWhereInput | ConfiguracaoSistemaWhereInput[]
    OR?: ConfiguracaoSistemaWhereInput[]
    NOT?: ConfiguracaoSistemaWhereInput | ConfiguracaoSistemaWhereInput[]
    id?: IntFilter<"ConfiguracaoSistema"> | number
    chave?: StringFilter<"ConfiguracaoSistema"> | string
    valor?: StringFilter<"ConfiguracaoSistema"> | string
    descricao?: StringNullableFilter<"ConfiguracaoSistema"> | string | null
    tipo?: EnumTipoConfiguracaoFilter<"ConfiguracaoSistema"> | $Enums.TipoConfiguracao
    createdAt?: DateTimeFilter<"ConfiguracaoSistema"> | Date | string
    updatedAt?: DateTimeFilter<"ConfiguracaoSistema"> | Date | string
  }

  export type ConfiguracaoSistemaOrderByWithRelationInput = {
    id?: SortOrder
    chave?: SortOrder
    valor?: SortOrder
    descricao?: SortOrderInput | SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracaoSistemaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    chave?: string
    AND?: ConfiguracaoSistemaWhereInput | ConfiguracaoSistemaWhereInput[]
    OR?: ConfiguracaoSistemaWhereInput[]
    NOT?: ConfiguracaoSistemaWhereInput | ConfiguracaoSistemaWhereInput[]
    valor?: StringFilter<"ConfiguracaoSistema"> | string
    descricao?: StringNullableFilter<"ConfiguracaoSistema"> | string | null
    tipo?: EnumTipoConfiguracaoFilter<"ConfiguracaoSistema"> | $Enums.TipoConfiguracao
    createdAt?: DateTimeFilter<"ConfiguracaoSistema"> | Date | string
    updatedAt?: DateTimeFilter<"ConfiguracaoSistema"> | Date | string
  }, "id" | "chave">

  export type ConfiguracaoSistemaOrderByWithAggregationInput = {
    id?: SortOrder
    chave?: SortOrder
    valor?: SortOrder
    descricao?: SortOrderInput | SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfiguracaoSistemaCountOrderByAggregateInput
    _avg?: ConfiguracaoSistemaAvgOrderByAggregateInput
    _max?: ConfiguracaoSistemaMaxOrderByAggregateInput
    _min?: ConfiguracaoSistemaMinOrderByAggregateInput
    _sum?: ConfiguracaoSistemaSumOrderByAggregateInput
  }

  export type ConfiguracaoSistemaScalarWhereWithAggregatesInput = {
    AND?: ConfiguracaoSistemaScalarWhereWithAggregatesInput | ConfiguracaoSistemaScalarWhereWithAggregatesInput[]
    OR?: ConfiguracaoSistemaScalarWhereWithAggregatesInput[]
    NOT?: ConfiguracaoSistemaScalarWhereWithAggregatesInput | ConfiguracaoSistemaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConfiguracaoSistema"> | number
    chave?: StringWithAggregatesFilter<"ConfiguracaoSistema"> | string
    valor?: StringWithAggregatesFilter<"ConfiguracaoSistema"> | string
    descricao?: StringNullableWithAggregatesFilter<"ConfiguracaoSistema"> | string | null
    tipo?: EnumTipoConfiguracaoWithAggregatesFilter<"ConfiguracaoSistema"> | $Enums.TipoConfiguracao
    createdAt?: DateTimeWithAggregatesFilter<"ConfiguracaoSistema"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConfiguracaoSistema"> | Date | string
  }

  export type EmpresaCreateInput = {
    razaoSocial: string
    nomeFantasia?: string | null
    cnpj?: string | null
    inscricaoEstadual?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    telefone?: string | null
    email?: string | null
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaUncheckedCreateInput = {
    id?: number
    razaoSocial: string
    nomeFantasia?: string | null
    cnpj?: string | null
    inscricaoEstadual?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    telefone?: string | null
    email?: string | null
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaUpdateInput = {
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaCreateManyInput = {
    id?: number
    razaoSocial: string
    nomeFantasia?: string | null
    cnpj?: string | null
    inscricaoEstadual?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    telefone?: string | null
    email?: string | null
    logo?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmpresaUpdateManyMutationInput = {
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmpresaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    razaoSocial?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: NullableStringFieldUpdateOperationsInput | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    inscricaoEstadual?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioCreateInput = {
    nome: string
    email: string
    senha: string
    perfil?: $Enums.PerfilUsuario
    ativo?: boolean
    ultimoLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidosCriados?: PedidoCreateNestedManyWithoutUsuarioInput
    laudosLiberados?: LaudoCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nome: string
    email: string
    senha: string
    perfil?: $Enums.PerfilUsuario
    ativo?: boolean
    ultimoLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidosCriados?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
    laudosLiberados?: LaudoUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: EnumPerfilUsuarioFieldUpdateOperationsInput | $Enums.PerfilUsuario
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidosCriados?: PedidoUpdateManyWithoutUsuarioNestedInput
    laudosLiberados?: LaudoUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: EnumPerfilUsuarioFieldUpdateOperationsInput | $Enums.PerfilUsuario
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidosCriados?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
    laudosLiberados?: LaudoUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nome: string
    email: string
    senha: string
    perfil?: $Enums.PerfilUsuario
    ativo?: boolean
    ultimoLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: EnumPerfilUsuarioFieldUpdateOperationsInput | $Enums.PerfilUsuario
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: EnumPerfilUsuarioFieldUpdateOperationsInput | $Enums.PerfilUsuario
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConselhoCreateInput = {
    nome: string
    sigla: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profissionais?: ProfissionalCreateNestedManyWithoutConselhoInput
  }

  export type ConselhoUncheckedCreateInput = {
    id?: number
    nome: string
    sigla: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profissionais?: ProfissionalUncheckedCreateNestedManyWithoutConselhoInput
  }

  export type ConselhoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profissionais?: ProfissionalUpdateManyWithoutConselhoNestedInput
  }

  export type ConselhoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profissionais?: ProfissionalUncheckedUpdateManyWithoutConselhoNestedInput
  }

  export type ConselhoCreateManyInput = {
    id?: number
    nome: string
    sigla: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConselhoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConselhoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfissionalCreateInput = {
    nome: string
    documento?: string | null
    registro?: string | null
    telefone?: string | null
    email?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    tipo: $Enums.TipoProfissional
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conselho?: ConselhoCreateNestedOneWithoutProfissionaisInput
    pedidosSolicitados?: PedidoCreateNestedManyWithoutProfissionalInput
    laudosAssinados?: LaudoCreateNestedManyWithoutProfissionalInput
    clientesResponsavel?: ClienteCreateNestedManyWithoutVeterinarioRespInput
  }

  export type ProfissionalUncheckedCreateInput = {
    id?: number
    nome: string
    documento?: string | null
    registro?: string | null
    conselhoId?: number | null
    telefone?: string | null
    email?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    tipo: $Enums.TipoProfissional
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidosSolicitados?: PedidoUncheckedCreateNestedManyWithoutProfissionalInput
    laudosAssinados?: LaudoUncheckedCreateNestedManyWithoutProfissionalInput
    clientesResponsavel?: ClienteUncheckedCreateNestedManyWithoutVeterinarioRespInput
  }

  export type ProfissionalUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conselho?: ConselhoUpdateOneWithoutProfissionaisNestedInput
    pedidosSolicitados?: PedidoUpdateManyWithoutProfissionalNestedInput
    laudosAssinados?: LaudoUpdateManyWithoutProfissionalNestedInput
    clientesResponsavel?: ClienteUpdateManyWithoutVeterinarioRespNestedInput
  }

  export type ProfissionalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    conselhoId?: NullableIntFieldUpdateOperationsInput | number | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidosSolicitados?: PedidoUncheckedUpdateManyWithoutProfissionalNestedInput
    laudosAssinados?: LaudoUncheckedUpdateManyWithoutProfissionalNestedInput
    clientesResponsavel?: ClienteUncheckedUpdateManyWithoutVeterinarioRespNestedInput
  }

  export type ProfissionalCreateManyInput = {
    id?: number
    nome: string
    documento?: string | null
    registro?: string | null
    conselhoId?: number | null
    telefone?: string | null
    email?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    tipo: $Enums.TipoProfissional
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfissionalUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfissionalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    conselhoId?: NullableIntFieldUpdateOperationsInput | number | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteCreateInput = {
    nome: string
    endereco?: string | null
    numero?: string | null
    complemento?: string | null
    bairro?: string | null
    cep?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    fax?: string | null
    celular?: string | null
    email?: string | null
    cpfCnpj?: string | null
    contato?: string | null
    dataCadastro?: Date | string
    restricao?: string | null
    dataAtualizacao?: Date | string | null
    ativo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    animais?: AnimalCreateNestedManyWithoutClienteInput
    pedidos?: PedidoCreateNestedManyWithoutClienteInput
    veterinarioResp?: ProfissionalCreateNestedOneWithoutClientesResponsavelInput
  }

  export type ClienteUncheckedCreateInput = {
    id?: number
    nome: string
    endereco?: string | null
    numero?: string | null
    complemento?: string | null
    bairro?: string | null
    cep?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    fax?: string | null
    celular?: string | null
    email?: string | null
    cpfCnpj?: string | null
    contato?: string | null
    dataCadastro?: Date | string
    restricao?: string | null
    dataAtualizacao?: Date | string | null
    ativo?: string
    codVetResp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    animais?: AnimalUncheckedCreateNestedManyWithoutClienteInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contato?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    restricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataAtualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animais?: AnimalUpdateManyWithoutClienteNestedInput
    pedidos?: PedidoUpdateManyWithoutClienteNestedInput
    veterinarioResp?: ProfissionalUpdateOneWithoutClientesResponsavelNestedInput
  }

  export type ClienteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contato?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    restricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataAtualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: StringFieldUpdateOperationsInput | string
    codVetResp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animais?: AnimalUncheckedUpdateManyWithoutClienteNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateManyInput = {
    id?: number
    nome: string
    endereco?: string | null
    numero?: string | null
    complemento?: string | null
    bairro?: string | null
    cep?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    fax?: string | null
    celular?: string | null
    email?: string | null
    cpfCnpj?: string | null
    contato?: string | null
    dataCadastro?: Date | string
    restricao?: string | null
    dataAtualizacao?: Date | string | null
    ativo?: string
    codVetResp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClienteUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contato?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    restricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataAtualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contato?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    restricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataAtualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: StringFieldUpdateOperationsInput | string
    codVetResp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EspecieCreateInput = {
    nome: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    animais?: AnimalCreateNestedManyWithoutEspecieInput
  }

  export type EspecieUncheckedCreateInput = {
    id?: number
    nome: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    animais?: AnimalUncheckedCreateNestedManyWithoutEspecieInput
  }

  export type EspecieUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animais?: AnimalUpdateManyWithoutEspecieNestedInput
  }

  export type EspecieUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animais?: AnimalUncheckedUpdateManyWithoutEspecieNestedInput
  }

  export type EspecieCreateManyInput = {
    id?: number
    nome: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EspecieUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EspecieUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimalCreateInput = {
    nome: string
    raca?: string | null
    sexo: $Enums.SexoAnimal
    idade?: string | null
    peso?: Decimal | DecimalJsLike | number | string | null
    cor?: string | null
    observacoes?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    especie: EspecieCreateNestedOneWithoutAnimaisInput
    cliente: ClienteCreateNestedOneWithoutAnimaisInput
    pedidos?: PedidoCreateNestedManyWithoutAnimalInput
  }

  export type AnimalUncheckedCreateInput = {
    id?: number
    nome: string
    especieId: number
    raca?: string | null
    sexo: $Enums.SexoAnimal
    idade?: string | null
    peso?: Decimal | DecimalJsLike | number | string | null
    cor?: string | null
    clienteId: number
    observacoes?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutAnimalInput
  }

  export type AnimalUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    raca?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoAnimalFieldUpdateOperationsInput | $Enums.SexoAnimal
    idade?: NullableStringFieldUpdateOperationsInput | string | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    especie?: EspecieUpdateOneRequiredWithoutAnimaisNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutAnimaisNestedInput
    pedidos?: PedidoUpdateManyWithoutAnimalNestedInput
  }

  export type AnimalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    especieId?: IntFieldUpdateOperationsInput | number
    raca?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoAnimalFieldUpdateOperationsInput | $Enums.SexoAnimal
    idade?: NullableStringFieldUpdateOperationsInput | string | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    clienteId?: IntFieldUpdateOperationsInput | number
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUncheckedUpdateManyWithoutAnimalNestedInput
  }

  export type AnimalCreateManyInput = {
    id?: number
    nome: string
    especieId: number
    raca?: string | null
    sexo: $Enums.SexoAnimal
    idade?: string | null
    peso?: Decimal | DecimalJsLike | number | string | null
    cor?: string | null
    clienteId: number
    observacoes?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnimalUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    raca?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoAnimalFieldUpdateOperationsInput | $Enums.SexoAnimal
    idade?: NullableStringFieldUpdateOperationsInput | string | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    especieId?: IntFieldUpdateOperationsInput | number
    raca?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoAnimalFieldUpdateOperationsInput | $Enums.SexoAnimal
    idade?: NullableStringFieldUpdateOperationsInput | string | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    clienteId?: IntFieldUpdateOperationsInput | number
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExameCreateInput = {
    codigo: string
    nome: string
    descricao?: string | null
    metodologia?: string | null
    material?: string | null
    valor?: Decimal | DecimalJsLike | number | string | null
    tempoResultado?: number | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parametros?: ParametroExameCreateNestedManyWithoutExameInput
    pedidoExames?: PedidoExameCreateNestedManyWithoutExameInput
  }

  export type ExameUncheckedCreateInput = {
    id?: number
    codigo: string
    nome: string
    descricao?: string | null
    metodologia?: string | null
    material?: string | null
    valor?: Decimal | DecimalJsLike | number | string | null
    tempoResultado?: number | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parametros?: ParametroExameUncheckedCreateNestedManyWithoutExameInput
    pedidoExames?: PedidoExameUncheckedCreateNestedManyWithoutExameInput
  }

  export type ExameUpdateInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempoResultado?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parametros?: ParametroExameUpdateManyWithoutExameNestedInput
    pedidoExames?: PedidoExameUpdateManyWithoutExameNestedInput
  }

  export type ExameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempoResultado?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parametros?: ParametroExameUncheckedUpdateManyWithoutExameNestedInput
    pedidoExames?: PedidoExameUncheckedUpdateManyWithoutExameNestedInput
  }

  export type ExameCreateManyInput = {
    id?: number
    codigo: string
    nome: string
    descricao?: string | null
    metodologia?: string | null
    material?: string | null
    valor?: Decimal | DecimalJsLike | number | string | null
    tempoResultado?: number | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExameUpdateManyMutationInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempoResultado?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempoResultado?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParametroExameCreateInput = {
    nome: string
    unidade?: string | null
    valorReferencia?: string | null
    ordem?: number
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exame: ExameCreateNestedOneWithoutParametrosInput
    resultados?: ResultadoExameCreateNestedManyWithoutParametroInput
  }

  export type ParametroExameUncheckedCreateInput = {
    id?: number
    exameId: number
    nome: string
    unidade?: string | null
    valorReferencia?: string | null
    ordem?: number
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resultados?: ResultadoExameUncheckedCreateNestedManyWithoutParametroInput
  }

  export type ParametroExameUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    valorReferencia?: NullableStringFieldUpdateOperationsInput | string | null
    ordem?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exame?: ExameUpdateOneRequiredWithoutParametrosNestedInput
    resultados?: ResultadoExameUpdateManyWithoutParametroNestedInput
  }

  export type ParametroExameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    exameId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    valorReferencia?: NullableStringFieldUpdateOperationsInput | string | null
    ordem?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultados?: ResultadoExameUncheckedUpdateManyWithoutParametroNestedInput
  }

  export type ParametroExameCreateManyInput = {
    id?: number
    exameId: number
    nome: string
    unidade?: string | null
    valorReferencia?: string | null
    ordem?: number
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParametroExameUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    valorReferencia?: NullableStringFieldUpdateOperationsInput | string | null
    ordem?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParametroExameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    exameId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    valorReferencia?: NullableStringFieldUpdateOperationsInput | string | null
    ordem?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateInput = {
    numero: string
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutPedidosInput
    animal: AnimalCreateNestedOneWithoutPedidosInput
    profissional?: ProfissionalCreateNestedOneWithoutPedidosSolicitadosInput
    usuario: UsuarioCreateNestedOneWithoutPedidosCriadosInput
    exames?: PedidoExameCreateNestedManyWithoutPedidoInput
    laudos?: LaudoCreateNestedManyWithoutPedidoInput
    contas?: ContaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateInput = {
    id?: number
    numero: string
    clienteId: number
    animalId: number
    profissionalId?: number | null
    usuarioId: number
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exames?: PedidoExameUncheckedCreateNestedManyWithoutPedidoInput
    laudos?: LaudoUncheckedCreateNestedManyWithoutPedidoInput
    contas?: ContaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUpdateInput = {
    numero?: StringFieldUpdateOperationsInput | string
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutPedidosNestedInput
    animal?: AnimalUpdateOneRequiredWithoutPedidosNestedInput
    profissional?: ProfissionalUpdateOneWithoutPedidosSolicitadosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosCriadosNestedInput
    exames?: PedidoExameUpdateManyWithoutPedidoNestedInput
    laudos?: LaudoUpdateManyWithoutPedidoNestedInput
    contas?: ContaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    clienteId?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: IntFieldUpdateOperationsInput | number
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exames?: PedidoExameUncheckedUpdateManyWithoutPedidoNestedInput
    laudos?: LaudoUncheckedUpdateManyWithoutPedidoNestedInput
    contas?: ContaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoCreateManyInput = {
    id?: number
    numero: string
    clienteId: number
    animalId: number
    profissionalId?: number | null
    usuarioId: number
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoUpdateManyMutationInput = {
    numero?: StringFieldUpdateOperationsInput | string
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    clienteId?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: IntFieldUpdateOperationsInput | number
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoExameCreateInput = {
    valor?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.StatusExame
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido: PedidoCreateNestedOneWithoutExamesInput
    exame: ExameCreateNestedOneWithoutPedidoExamesInput
    resultados?: ResultadoExameCreateNestedManyWithoutPedidoExameInput
  }

  export type PedidoExameUncheckedCreateInput = {
    id?: number
    pedidoId: number
    exameId: number
    valor?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.StatusExame
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resultados?: ResultadoExameUncheckedCreateNestedManyWithoutPedidoExameInput
  }

  export type PedidoExameUpdateInput = {
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFieldUpdateOperationsInput | $Enums.StatusExame
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutExamesNestedInput
    exame?: ExameUpdateOneRequiredWithoutPedidoExamesNestedInput
    resultados?: ResultadoExameUpdateManyWithoutPedidoExameNestedInput
  }

  export type PedidoExameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    exameId?: IntFieldUpdateOperationsInput | number
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFieldUpdateOperationsInput | $Enums.StatusExame
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultados?: ResultadoExameUncheckedUpdateManyWithoutPedidoExameNestedInput
  }

  export type PedidoExameCreateManyInput = {
    id?: number
    pedidoId: number
    exameId: number
    valor?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.StatusExame
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoExameUpdateManyMutationInput = {
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFieldUpdateOperationsInput | $Enums.StatusExame
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoExameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    exameId?: IntFieldUpdateOperationsInput | number
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFieldUpdateOperationsInput | $Enums.StatusExame
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultadoExameCreateInput = {
    valor?: string | null
    observacao?: string | null
    alterado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidoExame: PedidoExameCreateNestedOneWithoutResultadosInput
    parametro: ParametroExameCreateNestedOneWithoutResultadosInput
  }

  export type ResultadoExameUncheckedCreateInput = {
    id?: number
    pedidoExameId: number
    parametroId: number
    valor?: string | null
    observacao?: string | null
    alterado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultadoExameUpdateInput = {
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    alterado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidoExame?: PedidoExameUpdateOneRequiredWithoutResultadosNestedInput
    parametro?: ParametroExameUpdateOneRequiredWithoutResultadosNestedInput
  }

  export type ResultadoExameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoExameId?: IntFieldUpdateOperationsInput | number
    parametroId?: IntFieldUpdateOperationsInput | number
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    alterado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultadoExameCreateManyInput = {
    id?: number
    pedidoExameId: number
    parametroId: number
    valor?: string | null
    observacao?: string | null
    alterado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultadoExameUpdateManyMutationInput = {
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    alterado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultadoExameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoExameId?: IntFieldUpdateOperationsInput | number
    parametroId?: IntFieldUpdateOperationsInput | number
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    alterado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaudoCreateInput = {
    conteudo: string
    observacoes?: string | null
    dataLiberacao?: Date | string | null
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido: PedidoCreateNestedOneWithoutLaudosInput
    profissional?: ProfissionalCreateNestedOneWithoutLaudosAssinadosInput
    usuario?: UsuarioCreateNestedOneWithoutLaudosLiberadosInput
  }

  export type LaudoUncheckedCreateInput = {
    id?: number
    pedidoId: number
    profissionalId?: number | null
    usuarioId?: number | null
    conteudo: string
    observacoes?: string | null
    dataLiberacao?: Date | string | null
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaudoUpdateInput = {
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutLaudosNestedInput
    profissional?: ProfissionalUpdateOneWithoutLaudosAssinadosNestedInput
    usuario?: UsuarioUpdateOneWithoutLaudosLiberadosNestedInput
  }

  export type LaudoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaudoCreateManyInput = {
    id?: number
    pedidoId: number
    profissionalId?: number | null
    usuarioId?: number | null
    conteudo: string
    observacoes?: string | null
    dataLiberacao?: Date | string | null
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaudoUpdateManyMutationInput = {
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaudoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BancoCreateInput = {
    codigo?: string | null
    nome: string
    agencia?: string | null
    nomeAgencia?: string | null
    conta?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contas?: ContaCreateNestedManyWithoutBancoInput
  }

  export type BancoUncheckedCreateInput = {
    id?: number
    codigo?: string | null
    nome: string
    agencia?: string | null
    nomeAgencia?: string | null
    conta?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contas?: ContaUncheckedCreateNestedManyWithoutBancoInput
  }

  export type BancoUpdateInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nome?: StringFieldUpdateOperationsInput | string
    agencia?: NullableStringFieldUpdateOperationsInput | string | null
    nomeAgencia?: NullableStringFieldUpdateOperationsInput | string | null
    conta?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contas?: ContaUpdateManyWithoutBancoNestedInput
  }

  export type BancoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nome?: StringFieldUpdateOperationsInput | string
    agencia?: NullableStringFieldUpdateOperationsInput | string | null
    nomeAgencia?: NullableStringFieldUpdateOperationsInput | string | null
    conta?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contas?: ContaUncheckedUpdateManyWithoutBancoNestedInput
  }

  export type BancoCreateManyInput = {
    id?: number
    codigo?: string | null
    nome: string
    agencia?: string | null
    nomeAgencia?: string | null
    conta?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BancoUpdateManyMutationInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nome?: StringFieldUpdateOperationsInput | string
    agencia?: NullableStringFieldUpdateOperationsInput | string | null
    nomeAgencia?: NullableStringFieldUpdateOperationsInput | string | null
    conta?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BancoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nome?: StringFieldUpdateOperationsInput | string
    agencia?: NullableStringFieldUpdateOperationsInput | string | null
    nomeAgencia?: NullableStringFieldUpdateOperationsInput | string | null
    conta?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContaCreateInput = {
    tipo: $Enums.TipoConta
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    dataVencimento: Date | string
    dataPagamento?: Date | string | null
    status?: $Enums.StatusConta
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido?: PedidoCreateNestedOneWithoutContasInput
    banco?: BancoCreateNestedOneWithoutContasInput
  }

  export type ContaUncheckedCreateInput = {
    id?: number
    pedidoId?: number | null
    bancoId?: number | null
    tipo: $Enums.TipoConta
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    dataVencimento: Date | string
    dataPagamento?: Date | string | null
    status?: $Enums.StatusConta
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContaUpdateInput = {
    tipo?: EnumTipoContaFieldUpdateOperationsInput | $Enums.TipoConta
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusContaFieldUpdateOperationsInput | $Enums.StatusConta
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneWithoutContasNestedInput
    banco?: BancoUpdateOneWithoutContasNestedInput
  }

  export type ContaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: NullableIntFieldUpdateOperationsInput | number | null
    bancoId?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: EnumTipoContaFieldUpdateOperationsInput | $Enums.TipoConta
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusContaFieldUpdateOperationsInput | $Enums.StatusConta
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContaCreateManyInput = {
    id?: number
    pedidoId?: number | null
    bancoId?: number | null
    tipo: $Enums.TipoConta
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    dataVencimento: Date | string
    dataPagamento?: Date | string | null
    status?: $Enums.StatusConta
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContaUpdateManyMutationInput = {
    tipo?: EnumTipoContaFieldUpdateOperationsInput | $Enums.TipoConta
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusContaFieldUpdateOperationsInput | $Enums.StatusConta
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: NullableIntFieldUpdateOperationsInput | number | null
    bancoId?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: EnumTipoContaFieldUpdateOperationsInput | $Enums.TipoConta
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusContaFieldUpdateOperationsInput | $Enums.StatusConta
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogSistemaCreateInput = {
    usuarioId?: number | null
    acao: string
    tabela?: string | null
    registroId?: number | null
    dadosAntigos?: NullableJsonNullValueInput | InputJsonValue
    dadosNovos?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type LogSistemaUncheckedCreateInput = {
    id?: number
    usuarioId?: number | null
    acao: string
    tabela?: string | null
    registroId?: number | null
    dadosAntigos?: NullableJsonNullValueInput | InputJsonValue
    dadosNovos?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type LogSistemaUpdateInput = {
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    acao?: StringFieldUpdateOperationsInput | string
    tabela?: NullableStringFieldUpdateOperationsInput | string | null
    registroId?: NullableIntFieldUpdateOperationsInput | number | null
    dadosAntigos?: NullableJsonNullValueInput | InputJsonValue
    dadosNovos?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogSistemaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    acao?: StringFieldUpdateOperationsInput | string
    tabela?: NullableStringFieldUpdateOperationsInput | string | null
    registroId?: NullableIntFieldUpdateOperationsInput | number | null
    dadosAntigos?: NullableJsonNullValueInput | InputJsonValue
    dadosNovos?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogSistemaCreateManyInput = {
    id?: number
    usuarioId?: number | null
    acao: string
    tabela?: string | null
    registroId?: number | null
    dadosAntigos?: NullableJsonNullValueInput | InputJsonValue
    dadosNovos?: NullableJsonNullValueInput | InputJsonValue
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type LogSistemaUpdateManyMutationInput = {
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    acao?: StringFieldUpdateOperationsInput | string
    tabela?: NullableStringFieldUpdateOperationsInput | string | null
    registroId?: NullableIntFieldUpdateOperationsInput | number | null
    dadosAntigos?: NullableJsonNullValueInput | InputJsonValue
    dadosNovos?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogSistemaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    acao?: StringFieldUpdateOperationsInput | string
    tabela?: NullableStringFieldUpdateOperationsInput | string | null
    registroId?: NullableIntFieldUpdateOperationsInput | number | null
    dadosAntigos?: NullableJsonNullValueInput | InputJsonValue
    dadosNovos?: NullableJsonNullValueInput | InputJsonValue
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracaoSistemaCreateInput = {
    chave: string
    valor: string
    descricao?: string | null
    tipo?: $Enums.TipoConfiguracao
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracaoSistemaUncheckedCreateInput = {
    id?: number
    chave: string
    valor: string
    descricao?: string | null
    tipo?: $Enums.TipoConfiguracao
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracaoSistemaUpdateInput = {
    chave?: StringFieldUpdateOperationsInput | string
    valor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoConfiguracaoFieldUpdateOperationsInput | $Enums.TipoConfiguracao
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracaoSistemaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chave?: StringFieldUpdateOperationsInput | string
    valor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoConfiguracaoFieldUpdateOperationsInput | $Enums.TipoConfiguracao
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracaoSistemaCreateManyInput = {
    id?: number
    chave: string
    valor: string
    descricao?: string | null
    tipo?: $Enums.TipoConfiguracao
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfiguracaoSistemaUpdateManyMutationInput = {
    chave?: StringFieldUpdateOperationsInput | string
    valor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoConfiguracaoFieldUpdateOperationsInput | $Enums.TipoConfiguracao
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracaoSistemaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chave?: StringFieldUpdateOperationsInput | string
    valor?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoConfiguracaoFieldUpdateOperationsInput | $Enums.TipoConfiguracao
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EmpresaCountOrderByAggregateInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    cnpj?: SortOrder
    inscricaoEstadual?: SortOrder
    endereco?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    cep?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    logo?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpresaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmpresaMaxOrderByAggregateInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    cnpj?: SortOrder
    inscricaoEstadual?: SortOrder
    endereco?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    cep?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    logo?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpresaMinOrderByAggregateInput = {
    id?: SortOrder
    razaoSocial?: SortOrder
    nomeFantasia?: SortOrder
    cnpj?: SortOrder
    inscricaoEstadual?: SortOrder
    endereco?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    cep?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    logo?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmpresaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPerfilUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.PerfilUsuario | EnumPerfilUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumPerfilUsuarioFilter<$PrismaModel> | $Enums.PerfilUsuario
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PedidoListRelationFilter = {
    every?: PedidoWhereInput
    some?: PedidoWhereInput
    none?: PedidoWhereInput
  }

  export type LaudoListRelationFilter = {
    every?: LaudoWhereInput
    some?: LaudoWhereInput
    none?: LaudoWhereInput
  }

  export type PedidoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaudoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
    ultimoLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
    ultimoLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    perfil?: SortOrder
    ativo?: SortOrder
    ultimoLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPerfilUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PerfilUsuario | EnumPerfilUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumPerfilUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.PerfilUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPerfilUsuarioFilter<$PrismaModel>
    _max?: NestedEnumPerfilUsuarioFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ProfissionalListRelationFilter = {
    every?: ProfissionalWhereInput
    some?: ProfissionalWhereInput
    none?: ProfissionalWhereInput
  }

  export type ProfissionalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConselhoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConselhoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConselhoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConselhoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConselhoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumTipoProfissionalFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoProfissional | EnumTipoProfissionalFieldRefInput<$PrismaModel>
    in?: $Enums.TipoProfissional[] | ListEnumTipoProfissionalFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoProfissional[] | ListEnumTipoProfissionalFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoProfissionalFilter<$PrismaModel> | $Enums.TipoProfissional
  }

  export type ConselhoNullableRelationFilter = {
    is?: ConselhoWhereInput | null
    isNot?: ConselhoWhereInput | null
  }

  export type ClienteListRelationFilter = {
    every?: ClienteWhereInput
    some?: ClienteWhereInput
    none?: ClienteWhereInput
  }

  export type ClienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfissionalCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrder
    registro?: SortOrder
    conselhoId?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    endereco?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    cep?: SortOrder
    tipo?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfissionalAvgOrderByAggregateInput = {
    id?: SortOrder
    conselhoId?: SortOrder
  }

  export type ProfissionalMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrder
    registro?: SortOrder
    conselhoId?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    endereco?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    cep?: SortOrder
    tipo?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfissionalMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    documento?: SortOrder
    registro?: SortOrder
    conselhoId?: SortOrder
    telefone?: SortOrder
    email?: SortOrder
    endereco?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    cep?: SortOrder
    tipo?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfissionalSumOrderByAggregateInput = {
    id?: SortOrder
    conselhoId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumTipoProfissionalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoProfissional | EnumTipoProfissionalFieldRefInput<$PrismaModel>
    in?: $Enums.TipoProfissional[] | ListEnumTipoProfissionalFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoProfissional[] | ListEnumTipoProfissionalFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoProfissionalWithAggregatesFilter<$PrismaModel> | $Enums.TipoProfissional
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoProfissionalFilter<$PrismaModel>
    _max?: NestedEnumTipoProfissionalFilter<$PrismaModel>
  }

  export type AnimalListRelationFilter = {
    every?: AnimalWhereInput
    some?: AnimalWhereInput
    none?: AnimalWhereInput
  }

  export type ProfissionalNullableRelationFilter = {
    is?: ProfissionalWhereInput | null
    isNot?: ProfissionalWhereInput | null
  }

  export type AnimalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
    fax?: SortOrder
    celular?: SortOrder
    email?: SortOrder
    cpfCnpj?: SortOrder
    contato?: SortOrder
    dataCadastro?: SortOrder
    restricao?: SortOrder
    dataAtualizacao?: SortOrder
    ativo?: SortOrder
    codVetResp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClienteAvgOrderByAggregateInput = {
    id?: SortOrder
    codVetResp?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
    fax?: SortOrder
    celular?: SortOrder
    email?: SortOrder
    cpfCnpj?: SortOrder
    contato?: SortOrder
    dataCadastro?: SortOrder
    restricao?: SortOrder
    dataAtualizacao?: SortOrder
    ativo?: SortOrder
    codVetResp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    complemento?: SortOrder
    bairro?: SortOrder
    cep?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
    fax?: SortOrder
    celular?: SortOrder
    email?: SortOrder
    cpfCnpj?: SortOrder
    contato?: SortOrder
    dataCadastro?: SortOrder
    restricao?: SortOrder
    dataAtualizacao?: SortOrder
    ativo?: SortOrder
    codVetResp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClienteSumOrderByAggregateInput = {
    id?: SortOrder
    codVetResp?: SortOrder
  }

  export type EspecieCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EspecieAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EspecieMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EspecieMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EspecieSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumSexoAnimalFilter<$PrismaModel = never> = {
    equals?: $Enums.SexoAnimal | EnumSexoAnimalFieldRefInput<$PrismaModel>
    in?: $Enums.SexoAnimal[] | ListEnumSexoAnimalFieldRefInput<$PrismaModel>
    notIn?: $Enums.SexoAnimal[] | ListEnumSexoAnimalFieldRefInput<$PrismaModel>
    not?: NestedEnumSexoAnimalFilter<$PrismaModel> | $Enums.SexoAnimal
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EspecieRelationFilter = {
    is?: EspecieWhereInput
    isNot?: EspecieWhereInput
  }

  export type ClienteRelationFilter = {
    is?: ClienteWhereInput
    isNot?: ClienteWhereInput
  }

  export type AnimalCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    especieId?: SortOrder
    raca?: SortOrder
    sexo?: SortOrder
    idade?: SortOrder
    peso?: SortOrder
    cor?: SortOrder
    clienteId?: SortOrder
    observacoes?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnimalAvgOrderByAggregateInput = {
    id?: SortOrder
    especieId?: SortOrder
    peso?: SortOrder
    clienteId?: SortOrder
  }

  export type AnimalMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    especieId?: SortOrder
    raca?: SortOrder
    sexo?: SortOrder
    idade?: SortOrder
    peso?: SortOrder
    cor?: SortOrder
    clienteId?: SortOrder
    observacoes?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnimalMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    especieId?: SortOrder
    raca?: SortOrder
    sexo?: SortOrder
    idade?: SortOrder
    peso?: SortOrder
    cor?: SortOrder
    clienteId?: SortOrder
    observacoes?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnimalSumOrderByAggregateInput = {
    id?: SortOrder
    especieId?: SortOrder
    peso?: SortOrder
    clienteId?: SortOrder
  }

  export type EnumSexoAnimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SexoAnimal | EnumSexoAnimalFieldRefInput<$PrismaModel>
    in?: $Enums.SexoAnimal[] | ListEnumSexoAnimalFieldRefInput<$PrismaModel>
    notIn?: $Enums.SexoAnimal[] | ListEnumSexoAnimalFieldRefInput<$PrismaModel>
    not?: NestedEnumSexoAnimalWithAggregatesFilter<$PrismaModel> | $Enums.SexoAnimal
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexoAnimalFilter<$PrismaModel>
    _max?: NestedEnumSexoAnimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ParametroExameListRelationFilter = {
    every?: ParametroExameWhereInput
    some?: ParametroExameWhereInput
    none?: ParametroExameWhereInput
  }

  export type PedidoExameListRelationFilter = {
    every?: PedidoExameWhereInput
    some?: PedidoExameWhereInput
    none?: PedidoExameWhereInput
  }

  export type ParametroExameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoExameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExameCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    metodologia?: SortOrder
    material?: SortOrder
    valor?: SortOrder
    tempoResultado?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExameAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    tempoResultado?: SortOrder
  }

  export type ExameMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    metodologia?: SortOrder
    material?: SortOrder
    valor?: SortOrder
    tempoResultado?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExameMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    metodologia?: SortOrder
    material?: SortOrder
    valor?: SortOrder
    tempoResultado?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExameSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    tempoResultado?: SortOrder
  }

  export type ExameRelationFilter = {
    is?: ExameWhereInput
    isNot?: ExameWhereInput
  }

  export type ResultadoExameListRelationFilter = {
    every?: ResultadoExameWhereInput
    some?: ResultadoExameWhereInput
    none?: ResultadoExameWhereInput
  }

  export type ResultadoExameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParametroExameCountOrderByAggregateInput = {
    id?: SortOrder
    exameId?: SortOrder
    nome?: SortOrder
    unidade?: SortOrder
    valorReferencia?: SortOrder
    ordem?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParametroExameAvgOrderByAggregateInput = {
    id?: SortOrder
    exameId?: SortOrder
    ordem?: SortOrder
  }

  export type ParametroExameMaxOrderByAggregateInput = {
    id?: SortOrder
    exameId?: SortOrder
    nome?: SortOrder
    unidade?: SortOrder
    valorReferencia?: SortOrder
    ordem?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParametroExameMinOrderByAggregateInput = {
    id?: SortOrder
    exameId?: SortOrder
    nome?: SortOrder
    unidade?: SortOrder
    valorReferencia?: SortOrder
    ordem?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParametroExameSumOrderByAggregateInput = {
    id?: SortOrder
    exameId?: SortOrder
    ordem?: SortOrder
  }

  export type EnumStatusPedidoFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusPedido | EnumStatusPedidoFieldRefInput<$PrismaModel>
    in?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusPedidoFilter<$PrismaModel> | $Enums.StatusPedido
  }

  export type AnimalRelationFilter = {
    is?: AnimalWhereInput
    isNot?: AnimalWhereInput
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type ContaListRelationFilter = {
    every?: ContaWhereInput
    some?: ContaWhereInput
    none?: ContaWhereInput
  }

  export type ContaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoCountOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    clienteId?: SortOrder
    animalId?: SortOrder
    profissionalId?: SortOrder
    usuarioId?: SortOrder
    dataColeta?: SortOrder
    observacoes?: SortOrder
    status?: SortOrder
    valorTotal?: SortOrder
    desconto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoAvgOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    animalId?: SortOrder
    profissionalId?: SortOrder
    usuarioId?: SortOrder
    valorTotal?: SortOrder
    desconto?: SortOrder
  }

  export type PedidoMaxOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    clienteId?: SortOrder
    animalId?: SortOrder
    profissionalId?: SortOrder
    usuarioId?: SortOrder
    dataColeta?: SortOrder
    observacoes?: SortOrder
    status?: SortOrder
    valorTotal?: SortOrder
    desconto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoMinOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    clienteId?: SortOrder
    animalId?: SortOrder
    profissionalId?: SortOrder
    usuarioId?: SortOrder
    dataColeta?: SortOrder
    observacoes?: SortOrder
    status?: SortOrder
    valorTotal?: SortOrder
    desconto?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoSumOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    animalId?: SortOrder
    profissionalId?: SortOrder
    usuarioId?: SortOrder
    valorTotal?: SortOrder
    desconto?: SortOrder
  }

  export type EnumStatusPedidoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusPedido | EnumStatusPedidoFieldRefInput<$PrismaModel>
    in?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusPedidoWithAggregatesFilter<$PrismaModel> | $Enums.StatusPedido
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusPedidoFilter<$PrismaModel>
    _max?: NestedEnumStatusPedidoFilter<$PrismaModel>
  }

  export type EnumStatusExameFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusExame | EnumStatusExameFieldRefInput<$PrismaModel>
    in?: $Enums.StatusExame[] | ListEnumStatusExameFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusExame[] | ListEnumStatusExameFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusExameFilter<$PrismaModel> | $Enums.StatusExame
  }

  export type PedidoRelationFilter = {
    is?: PedidoWhereInput
    isNot?: PedidoWhereInput
  }

  export type PedidoExamePedidoIdExameIdCompoundUniqueInput = {
    pedidoId: number
    exameId: number
  }

  export type PedidoExameCountOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    exameId?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoExameAvgOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    exameId?: SortOrder
    valor?: SortOrder
  }

  export type PedidoExameMaxOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    exameId?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoExameMinOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    exameId?: SortOrder
    valor?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PedidoExameSumOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    exameId?: SortOrder
    valor?: SortOrder
  }

  export type EnumStatusExameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusExame | EnumStatusExameFieldRefInput<$PrismaModel>
    in?: $Enums.StatusExame[] | ListEnumStatusExameFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusExame[] | ListEnumStatusExameFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusExameWithAggregatesFilter<$PrismaModel> | $Enums.StatusExame
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusExameFilter<$PrismaModel>
    _max?: NestedEnumStatusExameFilter<$PrismaModel>
  }

  export type PedidoExameRelationFilter = {
    is?: PedidoExameWhereInput
    isNot?: PedidoExameWhereInput
  }

  export type ParametroExameRelationFilter = {
    is?: ParametroExameWhereInput
    isNot?: ParametroExameWhereInput
  }

  export type ResultadoExamePedidoExameIdParametroIdCompoundUniqueInput = {
    pedidoExameId: number
    parametroId: number
  }

  export type ResultadoExameCountOrderByAggregateInput = {
    id?: SortOrder
    pedidoExameId?: SortOrder
    parametroId?: SortOrder
    valor?: SortOrder
    observacao?: SortOrder
    alterado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultadoExameAvgOrderByAggregateInput = {
    id?: SortOrder
    pedidoExameId?: SortOrder
    parametroId?: SortOrder
  }

  export type ResultadoExameMaxOrderByAggregateInput = {
    id?: SortOrder
    pedidoExameId?: SortOrder
    parametroId?: SortOrder
    valor?: SortOrder
    observacao?: SortOrder
    alterado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultadoExameMinOrderByAggregateInput = {
    id?: SortOrder
    pedidoExameId?: SortOrder
    parametroId?: SortOrder
    valor?: SortOrder
    observacao?: SortOrder
    alterado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultadoExameSumOrderByAggregateInput = {
    id?: SortOrder
    pedidoExameId?: SortOrder
    parametroId?: SortOrder
  }

  export type UsuarioNullableRelationFilter = {
    is?: UsuarioWhereInput | null
    isNot?: UsuarioWhereInput | null
  }

  export type LaudoCountOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    profissionalId?: SortOrder
    usuarioId?: SortOrder
    conteudo?: SortOrder
    observacoes?: SortOrder
    dataLiberacao?: SortOrder
    assinado?: SortOrder
    enviado?: SortOrder
    dataEnvio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaudoAvgOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    profissionalId?: SortOrder
    usuarioId?: SortOrder
  }

  export type LaudoMaxOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    profissionalId?: SortOrder
    usuarioId?: SortOrder
    conteudo?: SortOrder
    observacoes?: SortOrder
    dataLiberacao?: SortOrder
    assinado?: SortOrder
    enviado?: SortOrder
    dataEnvio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaudoMinOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    profissionalId?: SortOrder
    usuarioId?: SortOrder
    conteudo?: SortOrder
    observacoes?: SortOrder
    dataLiberacao?: SortOrder
    assinado?: SortOrder
    enviado?: SortOrder
    dataEnvio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaudoSumOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    profissionalId?: SortOrder
    usuarioId?: SortOrder
  }

  export type BancoCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    agencia?: SortOrder
    nomeAgencia?: SortOrder
    conta?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BancoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BancoMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    agencia?: SortOrder
    nomeAgencia?: SortOrder
    conta?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BancoMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nome?: SortOrder
    agencia?: SortOrder
    nomeAgencia?: SortOrder
    conta?: SortOrder
    ativo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BancoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTipoContaFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoConta | EnumTipoContaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoConta[] | ListEnumTipoContaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoConta[] | ListEnumTipoContaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoContaFilter<$PrismaModel> | $Enums.TipoConta
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumStatusContaFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusConta | EnumStatusContaFieldRefInput<$PrismaModel>
    in?: $Enums.StatusConta[] | ListEnumStatusContaFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusConta[] | ListEnumStatusContaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusContaFilter<$PrismaModel> | $Enums.StatusConta
  }

  export type PedidoNullableRelationFilter = {
    is?: PedidoWhereInput | null
    isNot?: PedidoWhereInput | null
  }

  export type BancoNullableRelationFilter = {
    is?: BancoWhereInput | null
    isNot?: BancoWhereInput | null
  }

  export type ContaCountOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    bancoId?: SortOrder
    tipo?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    dataVencimento?: SortOrder
    dataPagamento?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContaAvgOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    bancoId?: SortOrder
    valor?: SortOrder
  }

  export type ContaMaxOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    bancoId?: SortOrder
    tipo?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    dataVencimento?: SortOrder
    dataPagamento?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContaMinOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    bancoId?: SortOrder
    tipo?: SortOrder
    descricao?: SortOrder
    valor?: SortOrder
    dataVencimento?: SortOrder
    dataPagamento?: SortOrder
    status?: SortOrder
    observacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContaSumOrderByAggregateInput = {
    id?: SortOrder
    pedidoId?: SortOrder
    bancoId?: SortOrder
    valor?: SortOrder
  }

  export type EnumTipoContaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoConta | EnumTipoContaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoConta[] | ListEnumTipoContaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoConta[] | ListEnumTipoContaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoContaWithAggregatesFilter<$PrismaModel> | $Enums.TipoConta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoContaFilter<$PrismaModel>
    _max?: NestedEnumTipoContaFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumStatusContaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusConta | EnumStatusContaFieldRefInput<$PrismaModel>
    in?: $Enums.StatusConta[] | ListEnumStatusContaFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusConta[] | ListEnumStatusContaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusContaWithAggregatesFilter<$PrismaModel> | $Enums.StatusConta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusContaFilter<$PrismaModel>
    _max?: NestedEnumStatusContaFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type LogSistemaCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    acao?: SortOrder
    tabela?: SortOrder
    registroId?: SortOrder
    dadosAntigos?: SortOrder
    dadosNovos?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type LogSistemaAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    registroId?: SortOrder
  }

  export type LogSistemaMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    acao?: SortOrder
    tabela?: SortOrder
    registroId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type LogSistemaMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    acao?: SortOrder
    tabela?: SortOrder
    registroId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type LogSistemaSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    registroId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumTipoConfiguracaoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoConfiguracao | EnumTipoConfiguracaoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoConfiguracao[] | ListEnumTipoConfiguracaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoConfiguracao[] | ListEnumTipoConfiguracaoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoConfiguracaoFilter<$PrismaModel> | $Enums.TipoConfiguracao
  }

  export type ConfiguracaoSistemaCountOrderByAggregateInput = {
    id?: SortOrder
    chave?: SortOrder
    valor?: SortOrder
    descricao?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracaoSistemaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConfiguracaoSistemaMaxOrderByAggregateInput = {
    id?: SortOrder
    chave?: SortOrder
    valor?: SortOrder
    descricao?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracaoSistemaMinOrderByAggregateInput = {
    id?: SortOrder
    chave?: SortOrder
    valor?: SortOrder
    descricao?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfiguracaoSistemaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTipoConfiguracaoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoConfiguracao | EnumTipoConfiguracaoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoConfiguracao[] | ListEnumTipoConfiguracaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoConfiguracao[] | ListEnumTipoConfiguracaoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoConfiguracaoWithAggregatesFilter<$PrismaModel> | $Enums.TipoConfiguracao
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoConfiguracaoFilter<$PrismaModel>
    _max?: NestedEnumTipoConfiguracaoFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PedidoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput> | PedidoCreateWithoutUsuarioInput[] | PedidoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutUsuarioInput | PedidoCreateOrConnectWithoutUsuarioInput[]
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type LaudoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<LaudoCreateWithoutUsuarioInput, LaudoUncheckedCreateWithoutUsuarioInput> | LaudoCreateWithoutUsuarioInput[] | LaudoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LaudoCreateOrConnectWithoutUsuarioInput | LaudoCreateOrConnectWithoutUsuarioInput[]
    createMany?: LaudoCreateManyUsuarioInputEnvelope
    connect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput> | PedidoCreateWithoutUsuarioInput[] | PedidoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutUsuarioInput | PedidoCreateOrConnectWithoutUsuarioInput[]
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type LaudoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<LaudoCreateWithoutUsuarioInput, LaudoUncheckedCreateWithoutUsuarioInput> | LaudoCreateWithoutUsuarioInput[] | LaudoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LaudoCreateOrConnectWithoutUsuarioInput | LaudoCreateOrConnectWithoutUsuarioInput[]
    createMany?: LaudoCreateManyUsuarioInputEnvelope
    connect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
  }

  export type EnumPerfilUsuarioFieldUpdateOperationsInput = {
    set?: $Enums.PerfilUsuario
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PedidoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput> | PedidoCreateWithoutUsuarioInput[] | PedidoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutUsuarioInput | PedidoCreateOrConnectWithoutUsuarioInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutUsuarioInput | PedidoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutUsuarioInput | PedidoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutUsuarioInput | PedidoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type LaudoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<LaudoCreateWithoutUsuarioInput, LaudoUncheckedCreateWithoutUsuarioInput> | LaudoCreateWithoutUsuarioInput[] | LaudoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LaudoCreateOrConnectWithoutUsuarioInput | LaudoCreateOrConnectWithoutUsuarioInput[]
    upsert?: LaudoUpsertWithWhereUniqueWithoutUsuarioInput | LaudoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: LaudoCreateManyUsuarioInputEnvelope
    set?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    disconnect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    delete?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    connect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    update?: LaudoUpdateWithWhereUniqueWithoutUsuarioInput | LaudoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: LaudoUpdateManyWithWhereWithoutUsuarioInput | LaudoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: LaudoScalarWhereInput | LaudoScalarWhereInput[]
  }

  export type PedidoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput> | PedidoCreateWithoutUsuarioInput[] | PedidoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutUsuarioInput | PedidoCreateOrConnectWithoutUsuarioInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutUsuarioInput | PedidoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: PedidoCreateManyUsuarioInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutUsuarioInput | PedidoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutUsuarioInput | PedidoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type LaudoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<LaudoCreateWithoutUsuarioInput, LaudoUncheckedCreateWithoutUsuarioInput> | LaudoCreateWithoutUsuarioInput[] | LaudoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LaudoCreateOrConnectWithoutUsuarioInput | LaudoCreateOrConnectWithoutUsuarioInput[]
    upsert?: LaudoUpsertWithWhereUniqueWithoutUsuarioInput | LaudoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: LaudoCreateManyUsuarioInputEnvelope
    set?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    disconnect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    delete?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    connect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    update?: LaudoUpdateWithWhereUniqueWithoutUsuarioInput | LaudoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: LaudoUpdateManyWithWhereWithoutUsuarioInput | LaudoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: LaudoScalarWhereInput | LaudoScalarWhereInput[]
  }

  export type ProfissionalCreateNestedManyWithoutConselhoInput = {
    create?: XOR<ProfissionalCreateWithoutConselhoInput, ProfissionalUncheckedCreateWithoutConselhoInput> | ProfissionalCreateWithoutConselhoInput[] | ProfissionalUncheckedCreateWithoutConselhoInput[]
    connectOrCreate?: ProfissionalCreateOrConnectWithoutConselhoInput | ProfissionalCreateOrConnectWithoutConselhoInput[]
    createMany?: ProfissionalCreateManyConselhoInputEnvelope
    connect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
  }

  export type ProfissionalUncheckedCreateNestedManyWithoutConselhoInput = {
    create?: XOR<ProfissionalCreateWithoutConselhoInput, ProfissionalUncheckedCreateWithoutConselhoInput> | ProfissionalCreateWithoutConselhoInput[] | ProfissionalUncheckedCreateWithoutConselhoInput[]
    connectOrCreate?: ProfissionalCreateOrConnectWithoutConselhoInput | ProfissionalCreateOrConnectWithoutConselhoInput[]
    createMany?: ProfissionalCreateManyConselhoInputEnvelope
    connect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
  }

  export type ProfissionalUpdateManyWithoutConselhoNestedInput = {
    create?: XOR<ProfissionalCreateWithoutConselhoInput, ProfissionalUncheckedCreateWithoutConselhoInput> | ProfissionalCreateWithoutConselhoInput[] | ProfissionalUncheckedCreateWithoutConselhoInput[]
    connectOrCreate?: ProfissionalCreateOrConnectWithoutConselhoInput | ProfissionalCreateOrConnectWithoutConselhoInput[]
    upsert?: ProfissionalUpsertWithWhereUniqueWithoutConselhoInput | ProfissionalUpsertWithWhereUniqueWithoutConselhoInput[]
    createMany?: ProfissionalCreateManyConselhoInputEnvelope
    set?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    disconnect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    delete?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    connect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    update?: ProfissionalUpdateWithWhereUniqueWithoutConselhoInput | ProfissionalUpdateWithWhereUniqueWithoutConselhoInput[]
    updateMany?: ProfissionalUpdateManyWithWhereWithoutConselhoInput | ProfissionalUpdateManyWithWhereWithoutConselhoInput[]
    deleteMany?: ProfissionalScalarWhereInput | ProfissionalScalarWhereInput[]
  }

  export type ProfissionalUncheckedUpdateManyWithoutConselhoNestedInput = {
    create?: XOR<ProfissionalCreateWithoutConselhoInput, ProfissionalUncheckedCreateWithoutConselhoInput> | ProfissionalCreateWithoutConselhoInput[] | ProfissionalUncheckedCreateWithoutConselhoInput[]
    connectOrCreate?: ProfissionalCreateOrConnectWithoutConselhoInput | ProfissionalCreateOrConnectWithoutConselhoInput[]
    upsert?: ProfissionalUpsertWithWhereUniqueWithoutConselhoInput | ProfissionalUpsertWithWhereUniqueWithoutConselhoInput[]
    createMany?: ProfissionalCreateManyConselhoInputEnvelope
    set?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    disconnect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    delete?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    connect?: ProfissionalWhereUniqueInput | ProfissionalWhereUniqueInput[]
    update?: ProfissionalUpdateWithWhereUniqueWithoutConselhoInput | ProfissionalUpdateWithWhereUniqueWithoutConselhoInput[]
    updateMany?: ProfissionalUpdateManyWithWhereWithoutConselhoInput | ProfissionalUpdateManyWithWhereWithoutConselhoInput[]
    deleteMany?: ProfissionalScalarWhereInput | ProfissionalScalarWhereInput[]
  }

  export type ConselhoCreateNestedOneWithoutProfissionaisInput = {
    create?: XOR<ConselhoCreateWithoutProfissionaisInput, ConselhoUncheckedCreateWithoutProfissionaisInput>
    connectOrCreate?: ConselhoCreateOrConnectWithoutProfissionaisInput
    connect?: ConselhoWhereUniqueInput
  }

  export type PedidoCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<PedidoCreateWithoutProfissionalInput, PedidoUncheckedCreateWithoutProfissionalInput> | PedidoCreateWithoutProfissionalInput[] | PedidoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutProfissionalInput | PedidoCreateOrConnectWithoutProfissionalInput[]
    createMany?: PedidoCreateManyProfissionalInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type LaudoCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<LaudoCreateWithoutProfissionalInput, LaudoUncheckedCreateWithoutProfissionalInput> | LaudoCreateWithoutProfissionalInput[] | LaudoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: LaudoCreateOrConnectWithoutProfissionalInput | LaudoCreateOrConnectWithoutProfissionalInput[]
    createMany?: LaudoCreateManyProfissionalInputEnvelope
    connect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
  }

  export type ClienteCreateNestedManyWithoutVeterinarioRespInput = {
    create?: XOR<ClienteCreateWithoutVeterinarioRespInput, ClienteUncheckedCreateWithoutVeterinarioRespInput> | ClienteCreateWithoutVeterinarioRespInput[] | ClienteUncheckedCreateWithoutVeterinarioRespInput[]
    connectOrCreate?: ClienteCreateOrConnectWithoutVeterinarioRespInput | ClienteCreateOrConnectWithoutVeterinarioRespInput[]
    createMany?: ClienteCreateManyVeterinarioRespInputEnvelope
    connect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<PedidoCreateWithoutProfissionalInput, PedidoUncheckedCreateWithoutProfissionalInput> | PedidoCreateWithoutProfissionalInput[] | PedidoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutProfissionalInput | PedidoCreateOrConnectWithoutProfissionalInput[]
    createMany?: PedidoCreateManyProfissionalInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type LaudoUncheckedCreateNestedManyWithoutProfissionalInput = {
    create?: XOR<LaudoCreateWithoutProfissionalInput, LaudoUncheckedCreateWithoutProfissionalInput> | LaudoCreateWithoutProfissionalInput[] | LaudoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: LaudoCreateOrConnectWithoutProfissionalInput | LaudoCreateOrConnectWithoutProfissionalInput[]
    createMany?: LaudoCreateManyProfissionalInputEnvelope
    connect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
  }

  export type ClienteUncheckedCreateNestedManyWithoutVeterinarioRespInput = {
    create?: XOR<ClienteCreateWithoutVeterinarioRespInput, ClienteUncheckedCreateWithoutVeterinarioRespInput> | ClienteCreateWithoutVeterinarioRespInput[] | ClienteUncheckedCreateWithoutVeterinarioRespInput[]
    connectOrCreate?: ClienteCreateOrConnectWithoutVeterinarioRespInput | ClienteCreateOrConnectWithoutVeterinarioRespInput[]
    createMany?: ClienteCreateManyVeterinarioRespInputEnvelope
    connect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
  }

  export type EnumTipoProfissionalFieldUpdateOperationsInput = {
    set?: $Enums.TipoProfissional
  }

  export type ConselhoUpdateOneWithoutProfissionaisNestedInput = {
    create?: XOR<ConselhoCreateWithoutProfissionaisInput, ConselhoUncheckedCreateWithoutProfissionaisInput>
    connectOrCreate?: ConselhoCreateOrConnectWithoutProfissionaisInput
    upsert?: ConselhoUpsertWithoutProfissionaisInput
    disconnect?: ConselhoWhereInput | boolean
    delete?: ConselhoWhereInput | boolean
    connect?: ConselhoWhereUniqueInput
    update?: XOR<XOR<ConselhoUpdateToOneWithWhereWithoutProfissionaisInput, ConselhoUpdateWithoutProfissionaisInput>, ConselhoUncheckedUpdateWithoutProfissionaisInput>
  }

  export type PedidoUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<PedidoCreateWithoutProfissionalInput, PedidoUncheckedCreateWithoutProfissionalInput> | PedidoCreateWithoutProfissionalInput[] | PedidoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutProfissionalInput | PedidoCreateOrConnectWithoutProfissionalInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutProfissionalInput | PedidoUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: PedidoCreateManyProfissionalInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutProfissionalInput | PedidoUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutProfissionalInput | PedidoUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type LaudoUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<LaudoCreateWithoutProfissionalInput, LaudoUncheckedCreateWithoutProfissionalInput> | LaudoCreateWithoutProfissionalInput[] | LaudoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: LaudoCreateOrConnectWithoutProfissionalInput | LaudoCreateOrConnectWithoutProfissionalInput[]
    upsert?: LaudoUpsertWithWhereUniqueWithoutProfissionalInput | LaudoUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: LaudoCreateManyProfissionalInputEnvelope
    set?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    disconnect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    delete?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    connect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    update?: LaudoUpdateWithWhereUniqueWithoutProfissionalInput | LaudoUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: LaudoUpdateManyWithWhereWithoutProfissionalInput | LaudoUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: LaudoScalarWhereInput | LaudoScalarWhereInput[]
  }

  export type ClienteUpdateManyWithoutVeterinarioRespNestedInput = {
    create?: XOR<ClienteCreateWithoutVeterinarioRespInput, ClienteUncheckedCreateWithoutVeterinarioRespInput> | ClienteCreateWithoutVeterinarioRespInput[] | ClienteUncheckedCreateWithoutVeterinarioRespInput[]
    connectOrCreate?: ClienteCreateOrConnectWithoutVeterinarioRespInput | ClienteCreateOrConnectWithoutVeterinarioRespInput[]
    upsert?: ClienteUpsertWithWhereUniqueWithoutVeterinarioRespInput | ClienteUpsertWithWhereUniqueWithoutVeterinarioRespInput[]
    createMany?: ClienteCreateManyVeterinarioRespInputEnvelope
    set?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    disconnect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    delete?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    connect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    update?: ClienteUpdateWithWhereUniqueWithoutVeterinarioRespInput | ClienteUpdateWithWhereUniqueWithoutVeterinarioRespInput[]
    updateMany?: ClienteUpdateManyWithWhereWithoutVeterinarioRespInput | ClienteUpdateManyWithWhereWithoutVeterinarioRespInput[]
    deleteMany?: ClienteScalarWhereInput | ClienteScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PedidoUncheckedUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<PedidoCreateWithoutProfissionalInput, PedidoUncheckedCreateWithoutProfissionalInput> | PedidoCreateWithoutProfissionalInput[] | PedidoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutProfissionalInput | PedidoCreateOrConnectWithoutProfissionalInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutProfissionalInput | PedidoUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: PedidoCreateManyProfissionalInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutProfissionalInput | PedidoUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutProfissionalInput | PedidoUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type LaudoUncheckedUpdateManyWithoutProfissionalNestedInput = {
    create?: XOR<LaudoCreateWithoutProfissionalInput, LaudoUncheckedCreateWithoutProfissionalInput> | LaudoCreateWithoutProfissionalInput[] | LaudoUncheckedCreateWithoutProfissionalInput[]
    connectOrCreate?: LaudoCreateOrConnectWithoutProfissionalInput | LaudoCreateOrConnectWithoutProfissionalInput[]
    upsert?: LaudoUpsertWithWhereUniqueWithoutProfissionalInput | LaudoUpsertWithWhereUniqueWithoutProfissionalInput[]
    createMany?: LaudoCreateManyProfissionalInputEnvelope
    set?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    disconnect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    delete?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    connect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    update?: LaudoUpdateWithWhereUniqueWithoutProfissionalInput | LaudoUpdateWithWhereUniqueWithoutProfissionalInput[]
    updateMany?: LaudoUpdateManyWithWhereWithoutProfissionalInput | LaudoUpdateManyWithWhereWithoutProfissionalInput[]
    deleteMany?: LaudoScalarWhereInput | LaudoScalarWhereInput[]
  }

  export type ClienteUncheckedUpdateManyWithoutVeterinarioRespNestedInput = {
    create?: XOR<ClienteCreateWithoutVeterinarioRespInput, ClienteUncheckedCreateWithoutVeterinarioRespInput> | ClienteCreateWithoutVeterinarioRespInput[] | ClienteUncheckedCreateWithoutVeterinarioRespInput[]
    connectOrCreate?: ClienteCreateOrConnectWithoutVeterinarioRespInput | ClienteCreateOrConnectWithoutVeterinarioRespInput[]
    upsert?: ClienteUpsertWithWhereUniqueWithoutVeterinarioRespInput | ClienteUpsertWithWhereUniqueWithoutVeterinarioRespInput[]
    createMany?: ClienteCreateManyVeterinarioRespInputEnvelope
    set?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    disconnect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    delete?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    connect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    update?: ClienteUpdateWithWhereUniqueWithoutVeterinarioRespInput | ClienteUpdateWithWhereUniqueWithoutVeterinarioRespInput[]
    updateMany?: ClienteUpdateManyWithWhereWithoutVeterinarioRespInput | ClienteUpdateManyWithWhereWithoutVeterinarioRespInput[]
    deleteMany?: ClienteScalarWhereInput | ClienteScalarWhereInput[]
  }

  export type AnimalCreateNestedManyWithoutClienteInput = {
    create?: XOR<AnimalCreateWithoutClienteInput, AnimalUncheckedCreateWithoutClienteInput> | AnimalCreateWithoutClienteInput[] | AnimalUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: AnimalCreateOrConnectWithoutClienteInput | AnimalCreateOrConnectWithoutClienteInput[]
    createMany?: AnimalCreateManyClienteInputEnvelope
    connect?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
  }

  export type PedidoCreateNestedManyWithoutClienteInput = {
    create?: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput> | PedidoCreateWithoutClienteInput[] | PedidoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutClienteInput | PedidoCreateOrConnectWithoutClienteInput[]
    createMany?: PedidoCreateManyClienteInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type ProfissionalCreateNestedOneWithoutClientesResponsavelInput = {
    create?: XOR<ProfissionalCreateWithoutClientesResponsavelInput, ProfissionalUncheckedCreateWithoutClientesResponsavelInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutClientesResponsavelInput
    connect?: ProfissionalWhereUniqueInput
  }

  export type AnimalUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<AnimalCreateWithoutClienteInput, AnimalUncheckedCreateWithoutClienteInput> | AnimalCreateWithoutClienteInput[] | AnimalUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: AnimalCreateOrConnectWithoutClienteInput | AnimalCreateOrConnectWithoutClienteInput[]
    createMany?: AnimalCreateManyClienteInputEnvelope
    connect?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput> | PedidoCreateWithoutClienteInput[] | PedidoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutClienteInput | PedidoCreateOrConnectWithoutClienteInput[]
    createMany?: PedidoCreateManyClienteInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type AnimalUpdateManyWithoutClienteNestedInput = {
    create?: XOR<AnimalCreateWithoutClienteInput, AnimalUncheckedCreateWithoutClienteInput> | AnimalCreateWithoutClienteInput[] | AnimalUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: AnimalCreateOrConnectWithoutClienteInput | AnimalCreateOrConnectWithoutClienteInput[]
    upsert?: AnimalUpsertWithWhereUniqueWithoutClienteInput | AnimalUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: AnimalCreateManyClienteInputEnvelope
    set?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    disconnect?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    delete?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    connect?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    update?: AnimalUpdateWithWhereUniqueWithoutClienteInput | AnimalUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: AnimalUpdateManyWithWhereWithoutClienteInput | AnimalUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: AnimalScalarWhereInput | AnimalScalarWhereInput[]
  }

  export type PedidoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput> | PedidoCreateWithoutClienteInput[] | PedidoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutClienteInput | PedidoCreateOrConnectWithoutClienteInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutClienteInput | PedidoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: PedidoCreateManyClienteInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutClienteInput | PedidoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutClienteInput | PedidoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type ProfissionalUpdateOneWithoutClientesResponsavelNestedInput = {
    create?: XOR<ProfissionalCreateWithoutClientesResponsavelInput, ProfissionalUncheckedCreateWithoutClientesResponsavelInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutClientesResponsavelInput
    upsert?: ProfissionalUpsertWithoutClientesResponsavelInput
    disconnect?: ProfissionalWhereInput | boolean
    delete?: ProfissionalWhereInput | boolean
    connect?: ProfissionalWhereUniqueInput
    update?: XOR<XOR<ProfissionalUpdateToOneWithWhereWithoutClientesResponsavelInput, ProfissionalUpdateWithoutClientesResponsavelInput>, ProfissionalUncheckedUpdateWithoutClientesResponsavelInput>
  }

  export type AnimalUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<AnimalCreateWithoutClienteInput, AnimalUncheckedCreateWithoutClienteInput> | AnimalCreateWithoutClienteInput[] | AnimalUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: AnimalCreateOrConnectWithoutClienteInput | AnimalCreateOrConnectWithoutClienteInput[]
    upsert?: AnimalUpsertWithWhereUniqueWithoutClienteInput | AnimalUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: AnimalCreateManyClienteInputEnvelope
    set?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    disconnect?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    delete?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    connect?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    update?: AnimalUpdateWithWhereUniqueWithoutClienteInput | AnimalUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: AnimalUpdateManyWithWhereWithoutClienteInput | AnimalUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: AnimalScalarWhereInput | AnimalScalarWhereInput[]
  }

  export type PedidoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput> | PedidoCreateWithoutClienteInput[] | PedidoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutClienteInput | PedidoCreateOrConnectWithoutClienteInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutClienteInput | PedidoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: PedidoCreateManyClienteInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutClienteInput | PedidoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutClienteInput | PedidoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type AnimalCreateNestedManyWithoutEspecieInput = {
    create?: XOR<AnimalCreateWithoutEspecieInput, AnimalUncheckedCreateWithoutEspecieInput> | AnimalCreateWithoutEspecieInput[] | AnimalUncheckedCreateWithoutEspecieInput[]
    connectOrCreate?: AnimalCreateOrConnectWithoutEspecieInput | AnimalCreateOrConnectWithoutEspecieInput[]
    createMany?: AnimalCreateManyEspecieInputEnvelope
    connect?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
  }

  export type AnimalUncheckedCreateNestedManyWithoutEspecieInput = {
    create?: XOR<AnimalCreateWithoutEspecieInput, AnimalUncheckedCreateWithoutEspecieInput> | AnimalCreateWithoutEspecieInput[] | AnimalUncheckedCreateWithoutEspecieInput[]
    connectOrCreate?: AnimalCreateOrConnectWithoutEspecieInput | AnimalCreateOrConnectWithoutEspecieInput[]
    createMany?: AnimalCreateManyEspecieInputEnvelope
    connect?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
  }

  export type AnimalUpdateManyWithoutEspecieNestedInput = {
    create?: XOR<AnimalCreateWithoutEspecieInput, AnimalUncheckedCreateWithoutEspecieInput> | AnimalCreateWithoutEspecieInput[] | AnimalUncheckedCreateWithoutEspecieInput[]
    connectOrCreate?: AnimalCreateOrConnectWithoutEspecieInput | AnimalCreateOrConnectWithoutEspecieInput[]
    upsert?: AnimalUpsertWithWhereUniqueWithoutEspecieInput | AnimalUpsertWithWhereUniqueWithoutEspecieInput[]
    createMany?: AnimalCreateManyEspecieInputEnvelope
    set?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    disconnect?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    delete?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    connect?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    update?: AnimalUpdateWithWhereUniqueWithoutEspecieInput | AnimalUpdateWithWhereUniqueWithoutEspecieInput[]
    updateMany?: AnimalUpdateManyWithWhereWithoutEspecieInput | AnimalUpdateManyWithWhereWithoutEspecieInput[]
    deleteMany?: AnimalScalarWhereInput | AnimalScalarWhereInput[]
  }

  export type AnimalUncheckedUpdateManyWithoutEspecieNestedInput = {
    create?: XOR<AnimalCreateWithoutEspecieInput, AnimalUncheckedCreateWithoutEspecieInput> | AnimalCreateWithoutEspecieInput[] | AnimalUncheckedCreateWithoutEspecieInput[]
    connectOrCreate?: AnimalCreateOrConnectWithoutEspecieInput | AnimalCreateOrConnectWithoutEspecieInput[]
    upsert?: AnimalUpsertWithWhereUniqueWithoutEspecieInput | AnimalUpsertWithWhereUniqueWithoutEspecieInput[]
    createMany?: AnimalCreateManyEspecieInputEnvelope
    set?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    disconnect?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    delete?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    connect?: AnimalWhereUniqueInput | AnimalWhereUniqueInput[]
    update?: AnimalUpdateWithWhereUniqueWithoutEspecieInput | AnimalUpdateWithWhereUniqueWithoutEspecieInput[]
    updateMany?: AnimalUpdateManyWithWhereWithoutEspecieInput | AnimalUpdateManyWithWhereWithoutEspecieInput[]
    deleteMany?: AnimalScalarWhereInput | AnimalScalarWhereInput[]
  }

  export type EspecieCreateNestedOneWithoutAnimaisInput = {
    create?: XOR<EspecieCreateWithoutAnimaisInput, EspecieUncheckedCreateWithoutAnimaisInput>
    connectOrCreate?: EspecieCreateOrConnectWithoutAnimaisInput
    connect?: EspecieWhereUniqueInput
  }

  export type ClienteCreateNestedOneWithoutAnimaisInput = {
    create?: XOR<ClienteCreateWithoutAnimaisInput, ClienteUncheckedCreateWithoutAnimaisInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutAnimaisInput
    connect?: ClienteWhereUniqueInput
  }

  export type PedidoCreateNestedManyWithoutAnimalInput = {
    create?: XOR<PedidoCreateWithoutAnimalInput, PedidoUncheckedCreateWithoutAnimalInput> | PedidoCreateWithoutAnimalInput[] | PedidoUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutAnimalInput | PedidoCreateOrConnectWithoutAnimalInput[]
    createMany?: PedidoCreateManyAnimalInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type PedidoUncheckedCreateNestedManyWithoutAnimalInput = {
    create?: XOR<PedidoCreateWithoutAnimalInput, PedidoUncheckedCreateWithoutAnimalInput> | PedidoCreateWithoutAnimalInput[] | PedidoUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutAnimalInput | PedidoCreateOrConnectWithoutAnimalInput[]
    createMany?: PedidoCreateManyAnimalInputEnvelope
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
  }

  export type EnumSexoAnimalFieldUpdateOperationsInput = {
    set?: $Enums.SexoAnimal
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EspecieUpdateOneRequiredWithoutAnimaisNestedInput = {
    create?: XOR<EspecieCreateWithoutAnimaisInput, EspecieUncheckedCreateWithoutAnimaisInput>
    connectOrCreate?: EspecieCreateOrConnectWithoutAnimaisInput
    upsert?: EspecieUpsertWithoutAnimaisInput
    connect?: EspecieWhereUniqueInput
    update?: XOR<XOR<EspecieUpdateToOneWithWhereWithoutAnimaisInput, EspecieUpdateWithoutAnimaisInput>, EspecieUncheckedUpdateWithoutAnimaisInput>
  }

  export type ClienteUpdateOneRequiredWithoutAnimaisNestedInput = {
    create?: XOR<ClienteCreateWithoutAnimaisInput, ClienteUncheckedCreateWithoutAnimaisInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutAnimaisInput
    upsert?: ClienteUpsertWithoutAnimaisInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutAnimaisInput, ClienteUpdateWithoutAnimaisInput>, ClienteUncheckedUpdateWithoutAnimaisInput>
  }

  export type PedidoUpdateManyWithoutAnimalNestedInput = {
    create?: XOR<PedidoCreateWithoutAnimalInput, PedidoUncheckedCreateWithoutAnimalInput> | PedidoCreateWithoutAnimalInput[] | PedidoUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutAnimalInput | PedidoCreateOrConnectWithoutAnimalInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutAnimalInput | PedidoUpsertWithWhereUniqueWithoutAnimalInput[]
    createMany?: PedidoCreateManyAnimalInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutAnimalInput | PedidoUpdateWithWhereUniqueWithoutAnimalInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutAnimalInput | PedidoUpdateManyWithWhereWithoutAnimalInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type PedidoUncheckedUpdateManyWithoutAnimalNestedInput = {
    create?: XOR<PedidoCreateWithoutAnimalInput, PedidoUncheckedCreateWithoutAnimalInput> | PedidoCreateWithoutAnimalInput[] | PedidoUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: PedidoCreateOrConnectWithoutAnimalInput | PedidoCreateOrConnectWithoutAnimalInput[]
    upsert?: PedidoUpsertWithWhereUniqueWithoutAnimalInput | PedidoUpsertWithWhereUniqueWithoutAnimalInput[]
    createMany?: PedidoCreateManyAnimalInputEnvelope
    set?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    disconnect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    delete?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    connect?: PedidoWhereUniqueInput | PedidoWhereUniqueInput[]
    update?: PedidoUpdateWithWhereUniqueWithoutAnimalInput | PedidoUpdateWithWhereUniqueWithoutAnimalInput[]
    updateMany?: PedidoUpdateManyWithWhereWithoutAnimalInput | PedidoUpdateManyWithWhereWithoutAnimalInput[]
    deleteMany?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
  }

  export type ParametroExameCreateNestedManyWithoutExameInput = {
    create?: XOR<ParametroExameCreateWithoutExameInput, ParametroExameUncheckedCreateWithoutExameInput> | ParametroExameCreateWithoutExameInput[] | ParametroExameUncheckedCreateWithoutExameInput[]
    connectOrCreate?: ParametroExameCreateOrConnectWithoutExameInput | ParametroExameCreateOrConnectWithoutExameInput[]
    createMany?: ParametroExameCreateManyExameInputEnvelope
    connect?: ParametroExameWhereUniqueInput | ParametroExameWhereUniqueInput[]
  }

  export type PedidoExameCreateNestedManyWithoutExameInput = {
    create?: XOR<PedidoExameCreateWithoutExameInput, PedidoExameUncheckedCreateWithoutExameInput> | PedidoExameCreateWithoutExameInput[] | PedidoExameUncheckedCreateWithoutExameInput[]
    connectOrCreate?: PedidoExameCreateOrConnectWithoutExameInput | PedidoExameCreateOrConnectWithoutExameInput[]
    createMany?: PedidoExameCreateManyExameInputEnvelope
    connect?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
  }

  export type ParametroExameUncheckedCreateNestedManyWithoutExameInput = {
    create?: XOR<ParametroExameCreateWithoutExameInput, ParametroExameUncheckedCreateWithoutExameInput> | ParametroExameCreateWithoutExameInput[] | ParametroExameUncheckedCreateWithoutExameInput[]
    connectOrCreate?: ParametroExameCreateOrConnectWithoutExameInput | ParametroExameCreateOrConnectWithoutExameInput[]
    createMany?: ParametroExameCreateManyExameInputEnvelope
    connect?: ParametroExameWhereUniqueInput | ParametroExameWhereUniqueInput[]
  }

  export type PedidoExameUncheckedCreateNestedManyWithoutExameInput = {
    create?: XOR<PedidoExameCreateWithoutExameInput, PedidoExameUncheckedCreateWithoutExameInput> | PedidoExameCreateWithoutExameInput[] | PedidoExameUncheckedCreateWithoutExameInput[]
    connectOrCreate?: PedidoExameCreateOrConnectWithoutExameInput | PedidoExameCreateOrConnectWithoutExameInput[]
    createMany?: PedidoExameCreateManyExameInputEnvelope
    connect?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
  }

  export type ParametroExameUpdateManyWithoutExameNestedInput = {
    create?: XOR<ParametroExameCreateWithoutExameInput, ParametroExameUncheckedCreateWithoutExameInput> | ParametroExameCreateWithoutExameInput[] | ParametroExameUncheckedCreateWithoutExameInput[]
    connectOrCreate?: ParametroExameCreateOrConnectWithoutExameInput | ParametroExameCreateOrConnectWithoutExameInput[]
    upsert?: ParametroExameUpsertWithWhereUniqueWithoutExameInput | ParametroExameUpsertWithWhereUniqueWithoutExameInput[]
    createMany?: ParametroExameCreateManyExameInputEnvelope
    set?: ParametroExameWhereUniqueInput | ParametroExameWhereUniqueInput[]
    disconnect?: ParametroExameWhereUniqueInput | ParametroExameWhereUniqueInput[]
    delete?: ParametroExameWhereUniqueInput | ParametroExameWhereUniqueInput[]
    connect?: ParametroExameWhereUniqueInput | ParametroExameWhereUniqueInput[]
    update?: ParametroExameUpdateWithWhereUniqueWithoutExameInput | ParametroExameUpdateWithWhereUniqueWithoutExameInput[]
    updateMany?: ParametroExameUpdateManyWithWhereWithoutExameInput | ParametroExameUpdateManyWithWhereWithoutExameInput[]
    deleteMany?: ParametroExameScalarWhereInput | ParametroExameScalarWhereInput[]
  }

  export type PedidoExameUpdateManyWithoutExameNestedInput = {
    create?: XOR<PedidoExameCreateWithoutExameInput, PedidoExameUncheckedCreateWithoutExameInput> | PedidoExameCreateWithoutExameInput[] | PedidoExameUncheckedCreateWithoutExameInput[]
    connectOrCreate?: PedidoExameCreateOrConnectWithoutExameInput | PedidoExameCreateOrConnectWithoutExameInput[]
    upsert?: PedidoExameUpsertWithWhereUniqueWithoutExameInput | PedidoExameUpsertWithWhereUniqueWithoutExameInput[]
    createMany?: PedidoExameCreateManyExameInputEnvelope
    set?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    disconnect?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    delete?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    connect?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    update?: PedidoExameUpdateWithWhereUniqueWithoutExameInput | PedidoExameUpdateWithWhereUniqueWithoutExameInput[]
    updateMany?: PedidoExameUpdateManyWithWhereWithoutExameInput | PedidoExameUpdateManyWithWhereWithoutExameInput[]
    deleteMany?: PedidoExameScalarWhereInput | PedidoExameScalarWhereInput[]
  }

  export type ParametroExameUncheckedUpdateManyWithoutExameNestedInput = {
    create?: XOR<ParametroExameCreateWithoutExameInput, ParametroExameUncheckedCreateWithoutExameInput> | ParametroExameCreateWithoutExameInput[] | ParametroExameUncheckedCreateWithoutExameInput[]
    connectOrCreate?: ParametroExameCreateOrConnectWithoutExameInput | ParametroExameCreateOrConnectWithoutExameInput[]
    upsert?: ParametroExameUpsertWithWhereUniqueWithoutExameInput | ParametroExameUpsertWithWhereUniqueWithoutExameInput[]
    createMany?: ParametroExameCreateManyExameInputEnvelope
    set?: ParametroExameWhereUniqueInput | ParametroExameWhereUniqueInput[]
    disconnect?: ParametroExameWhereUniqueInput | ParametroExameWhereUniqueInput[]
    delete?: ParametroExameWhereUniqueInput | ParametroExameWhereUniqueInput[]
    connect?: ParametroExameWhereUniqueInput | ParametroExameWhereUniqueInput[]
    update?: ParametroExameUpdateWithWhereUniqueWithoutExameInput | ParametroExameUpdateWithWhereUniqueWithoutExameInput[]
    updateMany?: ParametroExameUpdateManyWithWhereWithoutExameInput | ParametroExameUpdateManyWithWhereWithoutExameInput[]
    deleteMany?: ParametroExameScalarWhereInput | ParametroExameScalarWhereInput[]
  }

  export type PedidoExameUncheckedUpdateManyWithoutExameNestedInput = {
    create?: XOR<PedidoExameCreateWithoutExameInput, PedidoExameUncheckedCreateWithoutExameInput> | PedidoExameCreateWithoutExameInput[] | PedidoExameUncheckedCreateWithoutExameInput[]
    connectOrCreate?: PedidoExameCreateOrConnectWithoutExameInput | PedidoExameCreateOrConnectWithoutExameInput[]
    upsert?: PedidoExameUpsertWithWhereUniqueWithoutExameInput | PedidoExameUpsertWithWhereUniqueWithoutExameInput[]
    createMany?: PedidoExameCreateManyExameInputEnvelope
    set?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    disconnect?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    delete?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    connect?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    update?: PedidoExameUpdateWithWhereUniqueWithoutExameInput | PedidoExameUpdateWithWhereUniqueWithoutExameInput[]
    updateMany?: PedidoExameUpdateManyWithWhereWithoutExameInput | PedidoExameUpdateManyWithWhereWithoutExameInput[]
    deleteMany?: PedidoExameScalarWhereInput | PedidoExameScalarWhereInput[]
  }

  export type ExameCreateNestedOneWithoutParametrosInput = {
    create?: XOR<ExameCreateWithoutParametrosInput, ExameUncheckedCreateWithoutParametrosInput>
    connectOrCreate?: ExameCreateOrConnectWithoutParametrosInput
    connect?: ExameWhereUniqueInput
  }

  export type ResultadoExameCreateNestedManyWithoutParametroInput = {
    create?: XOR<ResultadoExameCreateWithoutParametroInput, ResultadoExameUncheckedCreateWithoutParametroInput> | ResultadoExameCreateWithoutParametroInput[] | ResultadoExameUncheckedCreateWithoutParametroInput[]
    connectOrCreate?: ResultadoExameCreateOrConnectWithoutParametroInput | ResultadoExameCreateOrConnectWithoutParametroInput[]
    createMany?: ResultadoExameCreateManyParametroInputEnvelope
    connect?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
  }

  export type ResultadoExameUncheckedCreateNestedManyWithoutParametroInput = {
    create?: XOR<ResultadoExameCreateWithoutParametroInput, ResultadoExameUncheckedCreateWithoutParametroInput> | ResultadoExameCreateWithoutParametroInput[] | ResultadoExameUncheckedCreateWithoutParametroInput[]
    connectOrCreate?: ResultadoExameCreateOrConnectWithoutParametroInput | ResultadoExameCreateOrConnectWithoutParametroInput[]
    createMany?: ResultadoExameCreateManyParametroInputEnvelope
    connect?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
  }

  export type ExameUpdateOneRequiredWithoutParametrosNestedInput = {
    create?: XOR<ExameCreateWithoutParametrosInput, ExameUncheckedCreateWithoutParametrosInput>
    connectOrCreate?: ExameCreateOrConnectWithoutParametrosInput
    upsert?: ExameUpsertWithoutParametrosInput
    connect?: ExameWhereUniqueInput
    update?: XOR<XOR<ExameUpdateToOneWithWhereWithoutParametrosInput, ExameUpdateWithoutParametrosInput>, ExameUncheckedUpdateWithoutParametrosInput>
  }

  export type ResultadoExameUpdateManyWithoutParametroNestedInput = {
    create?: XOR<ResultadoExameCreateWithoutParametroInput, ResultadoExameUncheckedCreateWithoutParametroInput> | ResultadoExameCreateWithoutParametroInput[] | ResultadoExameUncheckedCreateWithoutParametroInput[]
    connectOrCreate?: ResultadoExameCreateOrConnectWithoutParametroInput | ResultadoExameCreateOrConnectWithoutParametroInput[]
    upsert?: ResultadoExameUpsertWithWhereUniqueWithoutParametroInput | ResultadoExameUpsertWithWhereUniqueWithoutParametroInput[]
    createMany?: ResultadoExameCreateManyParametroInputEnvelope
    set?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    disconnect?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    delete?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    connect?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    update?: ResultadoExameUpdateWithWhereUniqueWithoutParametroInput | ResultadoExameUpdateWithWhereUniqueWithoutParametroInput[]
    updateMany?: ResultadoExameUpdateManyWithWhereWithoutParametroInput | ResultadoExameUpdateManyWithWhereWithoutParametroInput[]
    deleteMany?: ResultadoExameScalarWhereInput | ResultadoExameScalarWhereInput[]
  }

  export type ResultadoExameUncheckedUpdateManyWithoutParametroNestedInput = {
    create?: XOR<ResultadoExameCreateWithoutParametroInput, ResultadoExameUncheckedCreateWithoutParametroInput> | ResultadoExameCreateWithoutParametroInput[] | ResultadoExameUncheckedCreateWithoutParametroInput[]
    connectOrCreate?: ResultadoExameCreateOrConnectWithoutParametroInput | ResultadoExameCreateOrConnectWithoutParametroInput[]
    upsert?: ResultadoExameUpsertWithWhereUniqueWithoutParametroInput | ResultadoExameUpsertWithWhereUniqueWithoutParametroInput[]
    createMany?: ResultadoExameCreateManyParametroInputEnvelope
    set?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    disconnect?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    delete?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    connect?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    update?: ResultadoExameUpdateWithWhereUniqueWithoutParametroInput | ResultadoExameUpdateWithWhereUniqueWithoutParametroInput[]
    updateMany?: ResultadoExameUpdateManyWithWhereWithoutParametroInput | ResultadoExameUpdateManyWithWhereWithoutParametroInput[]
    deleteMany?: ResultadoExameScalarWhereInput | ResultadoExameScalarWhereInput[]
  }

  export type ClienteCreateNestedOneWithoutPedidosInput = {
    create?: XOR<ClienteCreateWithoutPedidosInput, ClienteUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutPedidosInput
    connect?: ClienteWhereUniqueInput
  }

  export type AnimalCreateNestedOneWithoutPedidosInput = {
    create?: XOR<AnimalCreateWithoutPedidosInput, AnimalUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: AnimalCreateOrConnectWithoutPedidosInput
    connect?: AnimalWhereUniqueInput
  }

  export type ProfissionalCreateNestedOneWithoutPedidosSolicitadosInput = {
    create?: XOR<ProfissionalCreateWithoutPedidosSolicitadosInput, ProfissionalUncheckedCreateWithoutPedidosSolicitadosInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutPedidosSolicitadosInput
    connect?: ProfissionalWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutPedidosCriadosInput = {
    create?: XOR<UsuarioCreateWithoutPedidosCriadosInput, UsuarioUncheckedCreateWithoutPedidosCriadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosCriadosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PedidoExameCreateNestedManyWithoutPedidoInput = {
    create?: XOR<PedidoExameCreateWithoutPedidoInput, PedidoExameUncheckedCreateWithoutPedidoInput> | PedidoExameCreateWithoutPedidoInput[] | PedidoExameUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoExameCreateOrConnectWithoutPedidoInput | PedidoExameCreateOrConnectWithoutPedidoInput[]
    createMany?: PedidoExameCreateManyPedidoInputEnvelope
    connect?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
  }

  export type LaudoCreateNestedManyWithoutPedidoInput = {
    create?: XOR<LaudoCreateWithoutPedidoInput, LaudoUncheckedCreateWithoutPedidoInput> | LaudoCreateWithoutPedidoInput[] | LaudoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: LaudoCreateOrConnectWithoutPedidoInput | LaudoCreateOrConnectWithoutPedidoInput[]
    createMany?: LaudoCreateManyPedidoInputEnvelope
    connect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
  }

  export type ContaCreateNestedManyWithoutPedidoInput = {
    create?: XOR<ContaCreateWithoutPedidoInput, ContaUncheckedCreateWithoutPedidoInput> | ContaCreateWithoutPedidoInput[] | ContaUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: ContaCreateOrConnectWithoutPedidoInput | ContaCreateOrConnectWithoutPedidoInput[]
    createMany?: ContaCreateManyPedidoInputEnvelope
    connect?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
  }

  export type PedidoExameUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<PedidoExameCreateWithoutPedidoInput, PedidoExameUncheckedCreateWithoutPedidoInput> | PedidoExameCreateWithoutPedidoInput[] | PedidoExameUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoExameCreateOrConnectWithoutPedidoInput | PedidoExameCreateOrConnectWithoutPedidoInput[]
    createMany?: PedidoExameCreateManyPedidoInputEnvelope
    connect?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
  }

  export type LaudoUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<LaudoCreateWithoutPedidoInput, LaudoUncheckedCreateWithoutPedidoInput> | LaudoCreateWithoutPedidoInput[] | LaudoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: LaudoCreateOrConnectWithoutPedidoInput | LaudoCreateOrConnectWithoutPedidoInput[]
    createMany?: LaudoCreateManyPedidoInputEnvelope
    connect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
  }

  export type ContaUncheckedCreateNestedManyWithoutPedidoInput = {
    create?: XOR<ContaCreateWithoutPedidoInput, ContaUncheckedCreateWithoutPedidoInput> | ContaCreateWithoutPedidoInput[] | ContaUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: ContaCreateOrConnectWithoutPedidoInput | ContaCreateOrConnectWithoutPedidoInput[]
    createMany?: ContaCreateManyPedidoInputEnvelope
    connect?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
  }

  export type EnumStatusPedidoFieldUpdateOperationsInput = {
    set?: $Enums.StatusPedido
  }

  export type ClienteUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<ClienteCreateWithoutPedidosInput, ClienteUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutPedidosInput
    upsert?: ClienteUpsertWithoutPedidosInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutPedidosInput, ClienteUpdateWithoutPedidosInput>, ClienteUncheckedUpdateWithoutPedidosInput>
  }

  export type AnimalUpdateOneRequiredWithoutPedidosNestedInput = {
    create?: XOR<AnimalCreateWithoutPedidosInput, AnimalUncheckedCreateWithoutPedidosInput>
    connectOrCreate?: AnimalCreateOrConnectWithoutPedidosInput
    upsert?: AnimalUpsertWithoutPedidosInput
    connect?: AnimalWhereUniqueInput
    update?: XOR<XOR<AnimalUpdateToOneWithWhereWithoutPedidosInput, AnimalUpdateWithoutPedidosInput>, AnimalUncheckedUpdateWithoutPedidosInput>
  }

  export type ProfissionalUpdateOneWithoutPedidosSolicitadosNestedInput = {
    create?: XOR<ProfissionalCreateWithoutPedidosSolicitadosInput, ProfissionalUncheckedCreateWithoutPedidosSolicitadosInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutPedidosSolicitadosInput
    upsert?: ProfissionalUpsertWithoutPedidosSolicitadosInput
    disconnect?: ProfissionalWhereInput | boolean
    delete?: ProfissionalWhereInput | boolean
    connect?: ProfissionalWhereUniqueInput
    update?: XOR<XOR<ProfissionalUpdateToOneWithWhereWithoutPedidosSolicitadosInput, ProfissionalUpdateWithoutPedidosSolicitadosInput>, ProfissionalUncheckedUpdateWithoutPedidosSolicitadosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutPedidosCriadosNestedInput = {
    create?: XOR<UsuarioCreateWithoutPedidosCriadosInput, UsuarioUncheckedCreateWithoutPedidosCriadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPedidosCriadosInput
    upsert?: UsuarioUpsertWithoutPedidosCriadosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPedidosCriadosInput, UsuarioUpdateWithoutPedidosCriadosInput>, UsuarioUncheckedUpdateWithoutPedidosCriadosInput>
  }

  export type PedidoExameUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<PedidoExameCreateWithoutPedidoInput, PedidoExameUncheckedCreateWithoutPedidoInput> | PedidoExameCreateWithoutPedidoInput[] | PedidoExameUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoExameCreateOrConnectWithoutPedidoInput | PedidoExameCreateOrConnectWithoutPedidoInput[]
    upsert?: PedidoExameUpsertWithWhereUniqueWithoutPedidoInput | PedidoExameUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: PedidoExameCreateManyPedidoInputEnvelope
    set?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    disconnect?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    delete?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    connect?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    update?: PedidoExameUpdateWithWhereUniqueWithoutPedidoInput | PedidoExameUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: PedidoExameUpdateManyWithWhereWithoutPedidoInput | PedidoExameUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: PedidoExameScalarWhereInput | PedidoExameScalarWhereInput[]
  }

  export type LaudoUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<LaudoCreateWithoutPedidoInput, LaudoUncheckedCreateWithoutPedidoInput> | LaudoCreateWithoutPedidoInput[] | LaudoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: LaudoCreateOrConnectWithoutPedidoInput | LaudoCreateOrConnectWithoutPedidoInput[]
    upsert?: LaudoUpsertWithWhereUniqueWithoutPedidoInput | LaudoUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: LaudoCreateManyPedidoInputEnvelope
    set?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    disconnect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    delete?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    connect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    update?: LaudoUpdateWithWhereUniqueWithoutPedidoInput | LaudoUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: LaudoUpdateManyWithWhereWithoutPedidoInput | LaudoUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: LaudoScalarWhereInput | LaudoScalarWhereInput[]
  }

  export type ContaUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<ContaCreateWithoutPedidoInput, ContaUncheckedCreateWithoutPedidoInput> | ContaCreateWithoutPedidoInput[] | ContaUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: ContaCreateOrConnectWithoutPedidoInput | ContaCreateOrConnectWithoutPedidoInput[]
    upsert?: ContaUpsertWithWhereUniqueWithoutPedidoInput | ContaUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: ContaCreateManyPedidoInputEnvelope
    set?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    disconnect?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    delete?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    connect?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    update?: ContaUpdateWithWhereUniqueWithoutPedidoInput | ContaUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: ContaUpdateManyWithWhereWithoutPedidoInput | ContaUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: ContaScalarWhereInput | ContaScalarWhereInput[]
  }

  export type PedidoExameUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<PedidoExameCreateWithoutPedidoInput, PedidoExameUncheckedCreateWithoutPedidoInput> | PedidoExameCreateWithoutPedidoInput[] | PedidoExameUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: PedidoExameCreateOrConnectWithoutPedidoInput | PedidoExameCreateOrConnectWithoutPedidoInput[]
    upsert?: PedidoExameUpsertWithWhereUniqueWithoutPedidoInput | PedidoExameUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: PedidoExameCreateManyPedidoInputEnvelope
    set?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    disconnect?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    delete?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    connect?: PedidoExameWhereUniqueInput | PedidoExameWhereUniqueInput[]
    update?: PedidoExameUpdateWithWhereUniqueWithoutPedidoInput | PedidoExameUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: PedidoExameUpdateManyWithWhereWithoutPedidoInput | PedidoExameUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: PedidoExameScalarWhereInput | PedidoExameScalarWhereInput[]
  }

  export type LaudoUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<LaudoCreateWithoutPedidoInput, LaudoUncheckedCreateWithoutPedidoInput> | LaudoCreateWithoutPedidoInput[] | LaudoUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: LaudoCreateOrConnectWithoutPedidoInput | LaudoCreateOrConnectWithoutPedidoInput[]
    upsert?: LaudoUpsertWithWhereUniqueWithoutPedidoInput | LaudoUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: LaudoCreateManyPedidoInputEnvelope
    set?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    disconnect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    delete?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    connect?: LaudoWhereUniqueInput | LaudoWhereUniqueInput[]
    update?: LaudoUpdateWithWhereUniqueWithoutPedidoInput | LaudoUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: LaudoUpdateManyWithWhereWithoutPedidoInput | LaudoUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: LaudoScalarWhereInput | LaudoScalarWhereInput[]
  }

  export type ContaUncheckedUpdateManyWithoutPedidoNestedInput = {
    create?: XOR<ContaCreateWithoutPedidoInput, ContaUncheckedCreateWithoutPedidoInput> | ContaCreateWithoutPedidoInput[] | ContaUncheckedCreateWithoutPedidoInput[]
    connectOrCreate?: ContaCreateOrConnectWithoutPedidoInput | ContaCreateOrConnectWithoutPedidoInput[]
    upsert?: ContaUpsertWithWhereUniqueWithoutPedidoInput | ContaUpsertWithWhereUniqueWithoutPedidoInput[]
    createMany?: ContaCreateManyPedidoInputEnvelope
    set?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    disconnect?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    delete?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    connect?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    update?: ContaUpdateWithWhereUniqueWithoutPedidoInput | ContaUpdateWithWhereUniqueWithoutPedidoInput[]
    updateMany?: ContaUpdateManyWithWhereWithoutPedidoInput | ContaUpdateManyWithWhereWithoutPedidoInput[]
    deleteMany?: ContaScalarWhereInput | ContaScalarWhereInput[]
  }

  export type PedidoCreateNestedOneWithoutExamesInput = {
    create?: XOR<PedidoCreateWithoutExamesInput, PedidoUncheckedCreateWithoutExamesInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutExamesInput
    connect?: PedidoWhereUniqueInput
  }

  export type ExameCreateNestedOneWithoutPedidoExamesInput = {
    create?: XOR<ExameCreateWithoutPedidoExamesInput, ExameUncheckedCreateWithoutPedidoExamesInput>
    connectOrCreate?: ExameCreateOrConnectWithoutPedidoExamesInput
    connect?: ExameWhereUniqueInput
  }

  export type ResultadoExameCreateNestedManyWithoutPedidoExameInput = {
    create?: XOR<ResultadoExameCreateWithoutPedidoExameInput, ResultadoExameUncheckedCreateWithoutPedidoExameInput> | ResultadoExameCreateWithoutPedidoExameInput[] | ResultadoExameUncheckedCreateWithoutPedidoExameInput[]
    connectOrCreate?: ResultadoExameCreateOrConnectWithoutPedidoExameInput | ResultadoExameCreateOrConnectWithoutPedidoExameInput[]
    createMany?: ResultadoExameCreateManyPedidoExameInputEnvelope
    connect?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
  }

  export type ResultadoExameUncheckedCreateNestedManyWithoutPedidoExameInput = {
    create?: XOR<ResultadoExameCreateWithoutPedidoExameInput, ResultadoExameUncheckedCreateWithoutPedidoExameInput> | ResultadoExameCreateWithoutPedidoExameInput[] | ResultadoExameUncheckedCreateWithoutPedidoExameInput[]
    connectOrCreate?: ResultadoExameCreateOrConnectWithoutPedidoExameInput | ResultadoExameCreateOrConnectWithoutPedidoExameInput[]
    createMany?: ResultadoExameCreateManyPedidoExameInputEnvelope
    connect?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
  }

  export type EnumStatusExameFieldUpdateOperationsInput = {
    set?: $Enums.StatusExame
  }

  export type PedidoUpdateOneRequiredWithoutExamesNestedInput = {
    create?: XOR<PedidoCreateWithoutExamesInput, PedidoUncheckedCreateWithoutExamesInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutExamesInput
    upsert?: PedidoUpsertWithoutExamesInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutExamesInput, PedidoUpdateWithoutExamesInput>, PedidoUncheckedUpdateWithoutExamesInput>
  }

  export type ExameUpdateOneRequiredWithoutPedidoExamesNestedInput = {
    create?: XOR<ExameCreateWithoutPedidoExamesInput, ExameUncheckedCreateWithoutPedidoExamesInput>
    connectOrCreate?: ExameCreateOrConnectWithoutPedidoExamesInput
    upsert?: ExameUpsertWithoutPedidoExamesInput
    connect?: ExameWhereUniqueInput
    update?: XOR<XOR<ExameUpdateToOneWithWhereWithoutPedidoExamesInput, ExameUpdateWithoutPedidoExamesInput>, ExameUncheckedUpdateWithoutPedidoExamesInput>
  }

  export type ResultadoExameUpdateManyWithoutPedidoExameNestedInput = {
    create?: XOR<ResultadoExameCreateWithoutPedidoExameInput, ResultadoExameUncheckedCreateWithoutPedidoExameInput> | ResultadoExameCreateWithoutPedidoExameInput[] | ResultadoExameUncheckedCreateWithoutPedidoExameInput[]
    connectOrCreate?: ResultadoExameCreateOrConnectWithoutPedidoExameInput | ResultadoExameCreateOrConnectWithoutPedidoExameInput[]
    upsert?: ResultadoExameUpsertWithWhereUniqueWithoutPedidoExameInput | ResultadoExameUpsertWithWhereUniqueWithoutPedidoExameInput[]
    createMany?: ResultadoExameCreateManyPedidoExameInputEnvelope
    set?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    disconnect?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    delete?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    connect?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    update?: ResultadoExameUpdateWithWhereUniqueWithoutPedidoExameInput | ResultadoExameUpdateWithWhereUniqueWithoutPedidoExameInput[]
    updateMany?: ResultadoExameUpdateManyWithWhereWithoutPedidoExameInput | ResultadoExameUpdateManyWithWhereWithoutPedidoExameInput[]
    deleteMany?: ResultadoExameScalarWhereInput | ResultadoExameScalarWhereInput[]
  }

  export type ResultadoExameUncheckedUpdateManyWithoutPedidoExameNestedInput = {
    create?: XOR<ResultadoExameCreateWithoutPedidoExameInput, ResultadoExameUncheckedCreateWithoutPedidoExameInput> | ResultadoExameCreateWithoutPedidoExameInput[] | ResultadoExameUncheckedCreateWithoutPedidoExameInput[]
    connectOrCreate?: ResultadoExameCreateOrConnectWithoutPedidoExameInput | ResultadoExameCreateOrConnectWithoutPedidoExameInput[]
    upsert?: ResultadoExameUpsertWithWhereUniqueWithoutPedidoExameInput | ResultadoExameUpsertWithWhereUniqueWithoutPedidoExameInput[]
    createMany?: ResultadoExameCreateManyPedidoExameInputEnvelope
    set?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    disconnect?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    delete?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    connect?: ResultadoExameWhereUniqueInput | ResultadoExameWhereUniqueInput[]
    update?: ResultadoExameUpdateWithWhereUniqueWithoutPedidoExameInput | ResultadoExameUpdateWithWhereUniqueWithoutPedidoExameInput[]
    updateMany?: ResultadoExameUpdateManyWithWhereWithoutPedidoExameInput | ResultadoExameUpdateManyWithWhereWithoutPedidoExameInput[]
    deleteMany?: ResultadoExameScalarWhereInput | ResultadoExameScalarWhereInput[]
  }

  export type PedidoExameCreateNestedOneWithoutResultadosInput = {
    create?: XOR<PedidoExameCreateWithoutResultadosInput, PedidoExameUncheckedCreateWithoutResultadosInput>
    connectOrCreate?: PedidoExameCreateOrConnectWithoutResultadosInput
    connect?: PedidoExameWhereUniqueInput
  }

  export type ParametroExameCreateNestedOneWithoutResultadosInput = {
    create?: XOR<ParametroExameCreateWithoutResultadosInput, ParametroExameUncheckedCreateWithoutResultadosInput>
    connectOrCreate?: ParametroExameCreateOrConnectWithoutResultadosInput
    connect?: ParametroExameWhereUniqueInput
  }

  export type PedidoExameUpdateOneRequiredWithoutResultadosNestedInput = {
    create?: XOR<PedidoExameCreateWithoutResultadosInput, PedidoExameUncheckedCreateWithoutResultadosInput>
    connectOrCreate?: PedidoExameCreateOrConnectWithoutResultadosInput
    upsert?: PedidoExameUpsertWithoutResultadosInput
    connect?: PedidoExameWhereUniqueInput
    update?: XOR<XOR<PedidoExameUpdateToOneWithWhereWithoutResultadosInput, PedidoExameUpdateWithoutResultadosInput>, PedidoExameUncheckedUpdateWithoutResultadosInput>
  }

  export type ParametroExameUpdateOneRequiredWithoutResultadosNestedInput = {
    create?: XOR<ParametroExameCreateWithoutResultadosInput, ParametroExameUncheckedCreateWithoutResultadosInput>
    connectOrCreate?: ParametroExameCreateOrConnectWithoutResultadosInput
    upsert?: ParametroExameUpsertWithoutResultadosInput
    connect?: ParametroExameWhereUniqueInput
    update?: XOR<XOR<ParametroExameUpdateToOneWithWhereWithoutResultadosInput, ParametroExameUpdateWithoutResultadosInput>, ParametroExameUncheckedUpdateWithoutResultadosInput>
  }

  export type PedidoCreateNestedOneWithoutLaudosInput = {
    create?: XOR<PedidoCreateWithoutLaudosInput, PedidoUncheckedCreateWithoutLaudosInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutLaudosInput
    connect?: PedidoWhereUniqueInput
  }

  export type ProfissionalCreateNestedOneWithoutLaudosAssinadosInput = {
    create?: XOR<ProfissionalCreateWithoutLaudosAssinadosInput, ProfissionalUncheckedCreateWithoutLaudosAssinadosInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutLaudosAssinadosInput
    connect?: ProfissionalWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutLaudosLiberadosInput = {
    create?: XOR<UsuarioCreateWithoutLaudosLiberadosInput, UsuarioUncheckedCreateWithoutLaudosLiberadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutLaudosLiberadosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PedidoUpdateOneRequiredWithoutLaudosNestedInput = {
    create?: XOR<PedidoCreateWithoutLaudosInput, PedidoUncheckedCreateWithoutLaudosInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutLaudosInput
    upsert?: PedidoUpsertWithoutLaudosInput
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutLaudosInput, PedidoUpdateWithoutLaudosInput>, PedidoUncheckedUpdateWithoutLaudosInput>
  }

  export type ProfissionalUpdateOneWithoutLaudosAssinadosNestedInput = {
    create?: XOR<ProfissionalCreateWithoutLaudosAssinadosInput, ProfissionalUncheckedCreateWithoutLaudosAssinadosInput>
    connectOrCreate?: ProfissionalCreateOrConnectWithoutLaudosAssinadosInput
    upsert?: ProfissionalUpsertWithoutLaudosAssinadosInput
    disconnect?: ProfissionalWhereInput | boolean
    delete?: ProfissionalWhereInput | boolean
    connect?: ProfissionalWhereUniqueInput
    update?: XOR<XOR<ProfissionalUpdateToOneWithWhereWithoutLaudosAssinadosInput, ProfissionalUpdateWithoutLaudosAssinadosInput>, ProfissionalUncheckedUpdateWithoutLaudosAssinadosInput>
  }

  export type UsuarioUpdateOneWithoutLaudosLiberadosNestedInput = {
    create?: XOR<UsuarioCreateWithoutLaudosLiberadosInput, UsuarioUncheckedCreateWithoutLaudosLiberadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutLaudosLiberadosInput
    upsert?: UsuarioUpsertWithoutLaudosLiberadosInput
    disconnect?: UsuarioWhereInput | boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutLaudosLiberadosInput, UsuarioUpdateWithoutLaudosLiberadosInput>, UsuarioUncheckedUpdateWithoutLaudosLiberadosInput>
  }

  export type ContaCreateNestedManyWithoutBancoInput = {
    create?: XOR<ContaCreateWithoutBancoInput, ContaUncheckedCreateWithoutBancoInput> | ContaCreateWithoutBancoInput[] | ContaUncheckedCreateWithoutBancoInput[]
    connectOrCreate?: ContaCreateOrConnectWithoutBancoInput | ContaCreateOrConnectWithoutBancoInput[]
    createMany?: ContaCreateManyBancoInputEnvelope
    connect?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
  }

  export type ContaUncheckedCreateNestedManyWithoutBancoInput = {
    create?: XOR<ContaCreateWithoutBancoInput, ContaUncheckedCreateWithoutBancoInput> | ContaCreateWithoutBancoInput[] | ContaUncheckedCreateWithoutBancoInput[]
    connectOrCreate?: ContaCreateOrConnectWithoutBancoInput | ContaCreateOrConnectWithoutBancoInput[]
    createMany?: ContaCreateManyBancoInputEnvelope
    connect?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
  }

  export type ContaUpdateManyWithoutBancoNestedInput = {
    create?: XOR<ContaCreateWithoutBancoInput, ContaUncheckedCreateWithoutBancoInput> | ContaCreateWithoutBancoInput[] | ContaUncheckedCreateWithoutBancoInput[]
    connectOrCreate?: ContaCreateOrConnectWithoutBancoInput | ContaCreateOrConnectWithoutBancoInput[]
    upsert?: ContaUpsertWithWhereUniqueWithoutBancoInput | ContaUpsertWithWhereUniqueWithoutBancoInput[]
    createMany?: ContaCreateManyBancoInputEnvelope
    set?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    disconnect?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    delete?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    connect?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    update?: ContaUpdateWithWhereUniqueWithoutBancoInput | ContaUpdateWithWhereUniqueWithoutBancoInput[]
    updateMany?: ContaUpdateManyWithWhereWithoutBancoInput | ContaUpdateManyWithWhereWithoutBancoInput[]
    deleteMany?: ContaScalarWhereInput | ContaScalarWhereInput[]
  }

  export type ContaUncheckedUpdateManyWithoutBancoNestedInput = {
    create?: XOR<ContaCreateWithoutBancoInput, ContaUncheckedCreateWithoutBancoInput> | ContaCreateWithoutBancoInput[] | ContaUncheckedCreateWithoutBancoInput[]
    connectOrCreate?: ContaCreateOrConnectWithoutBancoInput | ContaCreateOrConnectWithoutBancoInput[]
    upsert?: ContaUpsertWithWhereUniqueWithoutBancoInput | ContaUpsertWithWhereUniqueWithoutBancoInput[]
    createMany?: ContaCreateManyBancoInputEnvelope
    set?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    disconnect?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    delete?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    connect?: ContaWhereUniqueInput | ContaWhereUniqueInput[]
    update?: ContaUpdateWithWhereUniqueWithoutBancoInput | ContaUpdateWithWhereUniqueWithoutBancoInput[]
    updateMany?: ContaUpdateManyWithWhereWithoutBancoInput | ContaUpdateManyWithWhereWithoutBancoInput[]
    deleteMany?: ContaScalarWhereInput | ContaScalarWhereInput[]
  }

  export type PedidoCreateNestedOneWithoutContasInput = {
    create?: XOR<PedidoCreateWithoutContasInput, PedidoUncheckedCreateWithoutContasInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutContasInput
    connect?: PedidoWhereUniqueInput
  }

  export type BancoCreateNestedOneWithoutContasInput = {
    create?: XOR<BancoCreateWithoutContasInput, BancoUncheckedCreateWithoutContasInput>
    connectOrCreate?: BancoCreateOrConnectWithoutContasInput
    connect?: BancoWhereUniqueInput
  }

  export type EnumTipoContaFieldUpdateOperationsInput = {
    set?: $Enums.TipoConta
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumStatusContaFieldUpdateOperationsInput = {
    set?: $Enums.StatusConta
  }

  export type PedidoUpdateOneWithoutContasNestedInput = {
    create?: XOR<PedidoCreateWithoutContasInput, PedidoUncheckedCreateWithoutContasInput>
    connectOrCreate?: PedidoCreateOrConnectWithoutContasInput
    upsert?: PedidoUpsertWithoutContasInput
    disconnect?: PedidoWhereInput | boolean
    delete?: PedidoWhereInput | boolean
    connect?: PedidoWhereUniqueInput
    update?: XOR<XOR<PedidoUpdateToOneWithWhereWithoutContasInput, PedidoUpdateWithoutContasInput>, PedidoUncheckedUpdateWithoutContasInput>
  }

  export type BancoUpdateOneWithoutContasNestedInput = {
    create?: XOR<BancoCreateWithoutContasInput, BancoUncheckedCreateWithoutContasInput>
    connectOrCreate?: BancoCreateOrConnectWithoutContasInput
    upsert?: BancoUpsertWithoutContasInput
    disconnect?: BancoWhereInput | boolean
    delete?: BancoWhereInput | boolean
    connect?: BancoWhereUniqueInput
    update?: XOR<XOR<BancoUpdateToOneWithWhereWithoutContasInput, BancoUpdateWithoutContasInput>, BancoUncheckedUpdateWithoutContasInput>
  }

  export type EnumTipoConfiguracaoFieldUpdateOperationsInput = {
    set?: $Enums.TipoConfiguracao
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPerfilUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.PerfilUsuario | EnumPerfilUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumPerfilUsuarioFilter<$PrismaModel> | $Enums.PerfilUsuario
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPerfilUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PerfilUsuario | EnumPerfilUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.PerfilUsuario[] | ListEnumPerfilUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumPerfilUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.PerfilUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPerfilUsuarioFilter<$PrismaModel>
    _max?: NestedEnumPerfilUsuarioFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTipoProfissionalFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoProfissional | EnumTipoProfissionalFieldRefInput<$PrismaModel>
    in?: $Enums.TipoProfissional[] | ListEnumTipoProfissionalFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoProfissional[] | ListEnumTipoProfissionalFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoProfissionalFilter<$PrismaModel> | $Enums.TipoProfissional
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTipoProfissionalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoProfissional | EnumTipoProfissionalFieldRefInput<$PrismaModel>
    in?: $Enums.TipoProfissional[] | ListEnumTipoProfissionalFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoProfissional[] | ListEnumTipoProfissionalFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoProfissionalWithAggregatesFilter<$PrismaModel> | $Enums.TipoProfissional
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoProfissionalFilter<$PrismaModel>
    _max?: NestedEnumTipoProfissionalFilter<$PrismaModel>
  }

  export type NestedEnumSexoAnimalFilter<$PrismaModel = never> = {
    equals?: $Enums.SexoAnimal | EnumSexoAnimalFieldRefInput<$PrismaModel>
    in?: $Enums.SexoAnimal[] | ListEnumSexoAnimalFieldRefInput<$PrismaModel>
    notIn?: $Enums.SexoAnimal[] | ListEnumSexoAnimalFieldRefInput<$PrismaModel>
    not?: NestedEnumSexoAnimalFilter<$PrismaModel> | $Enums.SexoAnimal
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumSexoAnimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SexoAnimal | EnumSexoAnimalFieldRefInput<$PrismaModel>
    in?: $Enums.SexoAnimal[] | ListEnumSexoAnimalFieldRefInput<$PrismaModel>
    notIn?: $Enums.SexoAnimal[] | ListEnumSexoAnimalFieldRefInput<$PrismaModel>
    not?: NestedEnumSexoAnimalWithAggregatesFilter<$PrismaModel> | $Enums.SexoAnimal
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexoAnimalFilter<$PrismaModel>
    _max?: NestedEnumSexoAnimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusPedidoFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusPedido | EnumStatusPedidoFieldRefInput<$PrismaModel>
    in?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusPedidoFilter<$PrismaModel> | $Enums.StatusPedido
  }

  export type NestedEnumStatusPedidoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusPedido | EnumStatusPedidoFieldRefInput<$PrismaModel>
    in?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusPedido[] | ListEnumStatusPedidoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusPedidoWithAggregatesFilter<$PrismaModel> | $Enums.StatusPedido
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusPedidoFilter<$PrismaModel>
    _max?: NestedEnumStatusPedidoFilter<$PrismaModel>
  }

  export type NestedEnumStatusExameFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusExame | EnumStatusExameFieldRefInput<$PrismaModel>
    in?: $Enums.StatusExame[] | ListEnumStatusExameFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusExame[] | ListEnumStatusExameFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusExameFilter<$PrismaModel> | $Enums.StatusExame
  }

  export type NestedEnumStatusExameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusExame | EnumStatusExameFieldRefInput<$PrismaModel>
    in?: $Enums.StatusExame[] | ListEnumStatusExameFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusExame[] | ListEnumStatusExameFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusExameWithAggregatesFilter<$PrismaModel> | $Enums.StatusExame
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusExameFilter<$PrismaModel>
    _max?: NestedEnumStatusExameFilter<$PrismaModel>
  }

  export type NestedEnumTipoContaFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoConta | EnumTipoContaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoConta[] | ListEnumTipoContaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoConta[] | ListEnumTipoContaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoContaFilter<$PrismaModel> | $Enums.TipoConta
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumStatusContaFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusConta | EnumStatusContaFieldRefInput<$PrismaModel>
    in?: $Enums.StatusConta[] | ListEnumStatusContaFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusConta[] | ListEnumStatusContaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusContaFilter<$PrismaModel> | $Enums.StatusConta
  }

  export type NestedEnumTipoContaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoConta | EnumTipoContaFieldRefInput<$PrismaModel>
    in?: $Enums.TipoConta[] | ListEnumTipoContaFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoConta[] | ListEnumTipoContaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoContaWithAggregatesFilter<$PrismaModel> | $Enums.TipoConta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoContaFilter<$PrismaModel>
    _max?: NestedEnumTipoContaFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumStatusContaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusConta | EnumStatusContaFieldRefInput<$PrismaModel>
    in?: $Enums.StatusConta[] | ListEnumStatusContaFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusConta[] | ListEnumStatusContaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusContaWithAggregatesFilter<$PrismaModel> | $Enums.StatusConta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusContaFilter<$PrismaModel>
    _max?: NestedEnumStatusContaFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTipoConfiguracaoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoConfiguracao | EnumTipoConfiguracaoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoConfiguracao[] | ListEnumTipoConfiguracaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoConfiguracao[] | ListEnumTipoConfiguracaoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoConfiguracaoFilter<$PrismaModel> | $Enums.TipoConfiguracao
  }

  export type NestedEnumTipoConfiguracaoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoConfiguracao | EnumTipoConfiguracaoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoConfiguracao[] | ListEnumTipoConfiguracaoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoConfiguracao[] | ListEnumTipoConfiguracaoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoConfiguracaoWithAggregatesFilter<$PrismaModel> | $Enums.TipoConfiguracao
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoConfiguracaoFilter<$PrismaModel>
    _max?: NestedEnumTipoConfiguracaoFilter<$PrismaModel>
  }

  export type PedidoCreateWithoutUsuarioInput = {
    numero: string
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutPedidosInput
    animal: AnimalCreateNestedOneWithoutPedidosInput
    profissional?: ProfissionalCreateNestedOneWithoutPedidosSolicitadosInput
    exames?: PedidoExameCreateNestedManyWithoutPedidoInput
    laudos?: LaudoCreateNestedManyWithoutPedidoInput
    contas?: ContaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    numero: string
    clienteId: number
    animalId: number
    profissionalId?: number | null
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exames?: PedidoExameUncheckedCreateNestedManyWithoutPedidoInput
    laudos?: LaudoUncheckedCreateNestedManyWithoutPedidoInput
    contas?: ContaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput>
  }

  export type PedidoCreateManyUsuarioInputEnvelope = {
    data: PedidoCreateManyUsuarioInput | PedidoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type LaudoCreateWithoutUsuarioInput = {
    conteudo: string
    observacoes?: string | null
    dataLiberacao?: Date | string | null
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido: PedidoCreateNestedOneWithoutLaudosInput
    profissional?: ProfissionalCreateNestedOneWithoutLaudosAssinadosInput
  }

  export type LaudoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    pedidoId: number
    profissionalId?: number | null
    conteudo: string
    observacoes?: string | null
    dataLiberacao?: Date | string | null
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaudoCreateOrConnectWithoutUsuarioInput = {
    where: LaudoWhereUniqueInput
    create: XOR<LaudoCreateWithoutUsuarioInput, LaudoUncheckedCreateWithoutUsuarioInput>
  }

  export type LaudoCreateManyUsuarioInputEnvelope = {
    data: LaudoCreateManyUsuarioInput | LaudoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type PedidoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutUsuarioInput, PedidoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PedidoCreateWithoutUsuarioInput, PedidoUncheckedCreateWithoutUsuarioInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutUsuarioInput, PedidoUncheckedUpdateWithoutUsuarioInput>
  }

  export type PedidoUpdateManyWithWhereWithoutUsuarioInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type PedidoScalarWhereInput = {
    AND?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    OR?: PedidoScalarWhereInput[]
    NOT?: PedidoScalarWhereInput | PedidoScalarWhereInput[]
    id?: IntFilter<"Pedido"> | number
    numero?: StringFilter<"Pedido"> | string
    clienteId?: IntFilter<"Pedido"> | number
    animalId?: IntFilter<"Pedido"> | number
    profissionalId?: IntNullableFilter<"Pedido"> | number | null
    usuarioId?: IntFilter<"Pedido"> | number
    dataColeta?: DateTimeFilter<"Pedido"> | Date | string
    observacoes?: StringNullableFilter<"Pedido"> | string | null
    status?: EnumStatusPedidoFilter<"Pedido"> | $Enums.StatusPedido
    valorTotal?: DecimalNullableFilter<"Pedido"> | Decimal | DecimalJsLike | number | string | null
    desconto?: DecimalNullableFilter<"Pedido"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Pedido"> | Date | string
    updatedAt?: DateTimeFilter<"Pedido"> | Date | string
  }

  export type LaudoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: LaudoWhereUniqueInput
    update: XOR<LaudoUpdateWithoutUsuarioInput, LaudoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<LaudoCreateWithoutUsuarioInput, LaudoUncheckedCreateWithoutUsuarioInput>
  }

  export type LaudoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: LaudoWhereUniqueInput
    data: XOR<LaudoUpdateWithoutUsuarioInput, LaudoUncheckedUpdateWithoutUsuarioInput>
  }

  export type LaudoUpdateManyWithWhereWithoutUsuarioInput = {
    where: LaudoScalarWhereInput
    data: XOR<LaudoUpdateManyMutationInput, LaudoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type LaudoScalarWhereInput = {
    AND?: LaudoScalarWhereInput | LaudoScalarWhereInput[]
    OR?: LaudoScalarWhereInput[]
    NOT?: LaudoScalarWhereInput | LaudoScalarWhereInput[]
    id?: IntFilter<"Laudo"> | number
    pedidoId?: IntFilter<"Laudo"> | number
    profissionalId?: IntNullableFilter<"Laudo"> | number | null
    usuarioId?: IntNullableFilter<"Laudo"> | number | null
    conteudo?: StringFilter<"Laudo"> | string
    observacoes?: StringNullableFilter<"Laudo"> | string | null
    dataLiberacao?: DateTimeNullableFilter<"Laudo"> | Date | string | null
    assinado?: BoolFilter<"Laudo"> | boolean
    enviado?: BoolFilter<"Laudo"> | boolean
    dataEnvio?: DateTimeNullableFilter<"Laudo"> | Date | string | null
    createdAt?: DateTimeFilter<"Laudo"> | Date | string
    updatedAt?: DateTimeFilter<"Laudo"> | Date | string
  }

  export type ProfissionalCreateWithoutConselhoInput = {
    nome: string
    documento?: string | null
    registro?: string | null
    telefone?: string | null
    email?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    tipo: $Enums.TipoProfissional
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidosSolicitados?: PedidoCreateNestedManyWithoutProfissionalInput
    laudosAssinados?: LaudoCreateNestedManyWithoutProfissionalInput
    clientesResponsavel?: ClienteCreateNestedManyWithoutVeterinarioRespInput
  }

  export type ProfissionalUncheckedCreateWithoutConselhoInput = {
    id?: number
    nome: string
    documento?: string | null
    registro?: string | null
    telefone?: string | null
    email?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    tipo: $Enums.TipoProfissional
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidosSolicitados?: PedidoUncheckedCreateNestedManyWithoutProfissionalInput
    laudosAssinados?: LaudoUncheckedCreateNestedManyWithoutProfissionalInput
    clientesResponsavel?: ClienteUncheckedCreateNestedManyWithoutVeterinarioRespInput
  }

  export type ProfissionalCreateOrConnectWithoutConselhoInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutConselhoInput, ProfissionalUncheckedCreateWithoutConselhoInput>
  }

  export type ProfissionalCreateManyConselhoInputEnvelope = {
    data: ProfissionalCreateManyConselhoInput | ProfissionalCreateManyConselhoInput[]
    skipDuplicates?: boolean
  }

  export type ProfissionalUpsertWithWhereUniqueWithoutConselhoInput = {
    where: ProfissionalWhereUniqueInput
    update: XOR<ProfissionalUpdateWithoutConselhoInput, ProfissionalUncheckedUpdateWithoutConselhoInput>
    create: XOR<ProfissionalCreateWithoutConselhoInput, ProfissionalUncheckedCreateWithoutConselhoInput>
  }

  export type ProfissionalUpdateWithWhereUniqueWithoutConselhoInput = {
    where: ProfissionalWhereUniqueInput
    data: XOR<ProfissionalUpdateWithoutConselhoInput, ProfissionalUncheckedUpdateWithoutConselhoInput>
  }

  export type ProfissionalUpdateManyWithWhereWithoutConselhoInput = {
    where: ProfissionalScalarWhereInput
    data: XOR<ProfissionalUpdateManyMutationInput, ProfissionalUncheckedUpdateManyWithoutConselhoInput>
  }

  export type ProfissionalScalarWhereInput = {
    AND?: ProfissionalScalarWhereInput | ProfissionalScalarWhereInput[]
    OR?: ProfissionalScalarWhereInput[]
    NOT?: ProfissionalScalarWhereInput | ProfissionalScalarWhereInput[]
    id?: IntFilter<"Profissional"> | number
    nome?: StringFilter<"Profissional"> | string
    documento?: StringNullableFilter<"Profissional"> | string | null
    registro?: StringNullableFilter<"Profissional"> | string | null
    conselhoId?: IntNullableFilter<"Profissional"> | number | null
    telefone?: StringNullableFilter<"Profissional"> | string | null
    email?: StringNullableFilter<"Profissional"> | string | null
    endereco?: StringNullableFilter<"Profissional"> | string | null
    cidade?: StringNullableFilter<"Profissional"> | string | null
    uf?: StringNullableFilter<"Profissional"> | string | null
    cep?: StringNullableFilter<"Profissional"> | string | null
    tipo?: EnumTipoProfissionalFilter<"Profissional"> | $Enums.TipoProfissional
    ativo?: BoolFilter<"Profissional"> | boolean
    createdAt?: DateTimeFilter<"Profissional"> | Date | string
    updatedAt?: DateTimeFilter<"Profissional"> | Date | string
  }

  export type ConselhoCreateWithoutProfissionaisInput = {
    nome: string
    sigla: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConselhoUncheckedCreateWithoutProfissionaisInput = {
    id?: number
    nome: string
    sigla: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConselhoCreateOrConnectWithoutProfissionaisInput = {
    where: ConselhoWhereUniqueInput
    create: XOR<ConselhoCreateWithoutProfissionaisInput, ConselhoUncheckedCreateWithoutProfissionaisInput>
  }

  export type PedidoCreateWithoutProfissionalInput = {
    numero: string
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutPedidosInput
    animal: AnimalCreateNestedOneWithoutPedidosInput
    usuario: UsuarioCreateNestedOneWithoutPedidosCriadosInput
    exames?: PedidoExameCreateNestedManyWithoutPedidoInput
    laudos?: LaudoCreateNestedManyWithoutPedidoInput
    contas?: ContaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutProfissionalInput = {
    id?: number
    numero: string
    clienteId: number
    animalId: number
    usuarioId: number
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exames?: PedidoExameUncheckedCreateNestedManyWithoutPedidoInput
    laudos?: LaudoUncheckedCreateNestedManyWithoutPedidoInput
    contas?: ContaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutProfissionalInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutProfissionalInput, PedidoUncheckedCreateWithoutProfissionalInput>
  }

  export type PedidoCreateManyProfissionalInputEnvelope = {
    data: PedidoCreateManyProfissionalInput | PedidoCreateManyProfissionalInput[]
    skipDuplicates?: boolean
  }

  export type LaudoCreateWithoutProfissionalInput = {
    conteudo: string
    observacoes?: string | null
    dataLiberacao?: Date | string | null
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido: PedidoCreateNestedOneWithoutLaudosInput
    usuario?: UsuarioCreateNestedOneWithoutLaudosLiberadosInput
  }

  export type LaudoUncheckedCreateWithoutProfissionalInput = {
    id?: number
    pedidoId: number
    usuarioId?: number | null
    conteudo: string
    observacoes?: string | null
    dataLiberacao?: Date | string | null
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaudoCreateOrConnectWithoutProfissionalInput = {
    where: LaudoWhereUniqueInput
    create: XOR<LaudoCreateWithoutProfissionalInput, LaudoUncheckedCreateWithoutProfissionalInput>
  }

  export type LaudoCreateManyProfissionalInputEnvelope = {
    data: LaudoCreateManyProfissionalInput | LaudoCreateManyProfissionalInput[]
    skipDuplicates?: boolean
  }

  export type ClienteCreateWithoutVeterinarioRespInput = {
    nome: string
    endereco?: string | null
    numero?: string | null
    complemento?: string | null
    bairro?: string | null
    cep?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    fax?: string | null
    celular?: string | null
    email?: string | null
    cpfCnpj?: string | null
    contato?: string | null
    dataCadastro?: Date | string
    restricao?: string | null
    dataAtualizacao?: Date | string | null
    ativo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    animais?: AnimalCreateNestedManyWithoutClienteInput
    pedidos?: PedidoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutVeterinarioRespInput = {
    id?: number
    nome: string
    endereco?: string | null
    numero?: string | null
    complemento?: string | null
    bairro?: string | null
    cep?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    fax?: string | null
    celular?: string | null
    email?: string | null
    cpfCnpj?: string | null
    contato?: string | null
    dataCadastro?: Date | string
    restricao?: string | null
    dataAtualizacao?: Date | string | null
    ativo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    animais?: AnimalUncheckedCreateNestedManyWithoutClienteInput
    pedidos?: PedidoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutVeterinarioRespInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutVeterinarioRespInput, ClienteUncheckedCreateWithoutVeterinarioRespInput>
  }

  export type ClienteCreateManyVeterinarioRespInputEnvelope = {
    data: ClienteCreateManyVeterinarioRespInput | ClienteCreateManyVeterinarioRespInput[]
    skipDuplicates?: boolean
  }

  export type ConselhoUpsertWithoutProfissionaisInput = {
    update: XOR<ConselhoUpdateWithoutProfissionaisInput, ConselhoUncheckedUpdateWithoutProfissionaisInput>
    create: XOR<ConselhoCreateWithoutProfissionaisInput, ConselhoUncheckedCreateWithoutProfissionaisInput>
    where?: ConselhoWhereInput
  }

  export type ConselhoUpdateToOneWithWhereWithoutProfissionaisInput = {
    where?: ConselhoWhereInput
    data: XOR<ConselhoUpdateWithoutProfissionaisInput, ConselhoUncheckedUpdateWithoutProfissionaisInput>
  }

  export type ConselhoUpdateWithoutProfissionaisInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConselhoUncheckedUpdateWithoutProfissionaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUpsertWithWhereUniqueWithoutProfissionalInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutProfissionalInput, PedidoUncheckedUpdateWithoutProfissionalInput>
    create: XOR<PedidoCreateWithoutProfissionalInput, PedidoUncheckedCreateWithoutProfissionalInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutProfissionalInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutProfissionalInput, PedidoUncheckedUpdateWithoutProfissionalInput>
  }

  export type PedidoUpdateManyWithWhereWithoutProfissionalInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutProfissionalInput>
  }

  export type LaudoUpsertWithWhereUniqueWithoutProfissionalInput = {
    where: LaudoWhereUniqueInput
    update: XOR<LaudoUpdateWithoutProfissionalInput, LaudoUncheckedUpdateWithoutProfissionalInput>
    create: XOR<LaudoCreateWithoutProfissionalInput, LaudoUncheckedCreateWithoutProfissionalInput>
  }

  export type LaudoUpdateWithWhereUniqueWithoutProfissionalInput = {
    where: LaudoWhereUniqueInput
    data: XOR<LaudoUpdateWithoutProfissionalInput, LaudoUncheckedUpdateWithoutProfissionalInput>
  }

  export type LaudoUpdateManyWithWhereWithoutProfissionalInput = {
    where: LaudoScalarWhereInput
    data: XOR<LaudoUpdateManyMutationInput, LaudoUncheckedUpdateManyWithoutProfissionalInput>
  }

  export type ClienteUpsertWithWhereUniqueWithoutVeterinarioRespInput = {
    where: ClienteWhereUniqueInput
    update: XOR<ClienteUpdateWithoutVeterinarioRespInput, ClienteUncheckedUpdateWithoutVeterinarioRespInput>
    create: XOR<ClienteCreateWithoutVeterinarioRespInput, ClienteUncheckedCreateWithoutVeterinarioRespInput>
  }

  export type ClienteUpdateWithWhereUniqueWithoutVeterinarioRespInput = {
    where: ClienteWhereUniqueInput
    data: XOR<ClienteUpdateWithoutVeterinarioRespInput, ClienteUncheckedUpdateWithoutVeterinarioRespInput>
  }

  export type ClienteUpdateManyWithWhereWithoutVeterinarioRespInput = {
    where: ClienteScalarWhereInput
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyWithoutVeterinarioRespInput>
  }

  export type ClienteScalarWhereInput = {
    AND?: ClienteScalarWhereInput | ClienteScalarWhereInput[]
    OR?: ClienteScalarWhereInput[]
    NOT?: ClienteScalarWhereInput | ClienteScalarWhereInput[]
    id?: IntFilter<"Cliente"> | number
    nome?: StringFilter<"Cliente"> | string
    endereco?: StringNullableFilter<"Cliente"> | string | null
    numero?: StringNullableFilter<"Cliente"> | string | null
    complemento?: StringNullableFilter<"Cliente"> | string | null
    bairro?: StringNullableFilter<"Cliente"> | string | null
    cep?: StringNullableFilter<"Cliente"> | string | null
    cidade?: StringNullableFilter<"Cliente"> | string | null
    uf?: StringNullableFilter<"Cliente"> | string | null
    telefone?: StringNullableFilter<"Cliente"> | string | null
    fax?: StringNullableFilter<"Cliente"> | string | null
    celular?: StringNullableFilter<"Cliente"> | string | null
    email?: StringNullableFilter<"Cliente"> | string | null
    cpfCnpj?: StringNullableFilter<"Cliente"> | string | null
    contato?: StringNullableFilter<"Cliente"> | string | null
    dataCadastro?: DateTimeFilter<"Cliente"> | Date | string
    restricao?: StringNullableFilter<"Cliente"> | string | null
    dataAtualizacao?: DateTimeNullableFilter<"Cliente"> | Date | string | null
    ativo?: StringFilter<"Cliente"> | string
    codVetResp?: IntNullableFilter<"Cliente"> | number | null
    createdAt?: DateTimeFilter<"Cliente"> | Date | string
    updatedAt?: DateTimeFilter<"Cliente"> | Date | string
  }

  export type AnimalCreateWithoutClienteInput = {
    nome: string
    raca?: string | null
    sexo: $Enums.SexoAnimal
    idade?: string | null
    peso?: Decimal | DecimalJsLike | number | string | null
    cor?: string | null
    observacoes?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    especie: EspecieCreateNestedOneWithoutAnimaisInput
    pedidos?: PedidoCreateNestedManyWithoutAnimalInput
  }

  export type AnimalUncheckedCreateWithoutClienteInput = {
    id?: number
    nome: string
    especieId: number
    raca?: string | null
    sexo: $Enums.SexoAnimal
    idade?: string | null
    peso?: Decimal | DecimalJsLike | number | string | null
    cor?: string | null
    observacoes?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutAnimalInput
  }

  export type AnimalCreateOrConnectWithoutClienteInput = {
    where: AnimalWhereUniqueInput
    create: XOR<AnimalCreateWithoutClienteInput, AnimalUncheckedCreateWithoutClienteInput>
  }

  export type AnimalCreateManyClienteInputEnvelope = {
    data: AnimalCreateManyClienteInput | AnimalCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type PedidoCreateWithoutClienteInput = {
    numero: string
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    animal: AnimalCreateNestedOneWithoutPedidosInput
    profissional?: ProfissionalCreateNestedOneWithoutPedidosSolicitadosInput
    usuario: UsuarioCreateNestedOneWithoutPedidosCriadosInput
    exames?: PedidoExameCreateNestedManyWithoutPedidoInput
    laudos?: LaudoCreateNestedManyWithoutPedidoInput
    contas?: ContaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutClienteInput = {
    id?: number
    numero: string
    animalId: number
    profissionalId?: number | null
    usuarioId: number
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exames?: PedidoExameUncheckedCreateNestedManyWithoutPedidoInput
    laudos?: LaudoUncheckedCreateNestedManyWithoutPedidoInput
    contas?: ContaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutClienteInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput>
  }

  export type PedidoCreateManyClienteInputEnvelope = {
    data: PedidoCreateManyClienteInput | PedidoCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type ProfissionalCreateWithoutClientesResponsavelInput = {
    nome: string
    documento?: string | null
    registro?: string | null
    telefone?: string | null
    email?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    tipo: $Enums.TipoProfissional
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conselho?: ConselhoCreateNestedOneWithoutProfissionaisInput
    pedidosSolicitados?: PedidoCreateNestedManyWithoutProfissionalInput
    laudosAssinados?: LaudoCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalUncheckedCreateWithoutClientesResponsavelInput = {
    id?: number
    nome: string
    documento?: string | null
    registro?: string | null
    conselhoId?: number | null
    telefone?: string | null
    email?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    tipo: $Enums.TipoProfissional
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidosSolicitados?: PedidoUncheckedCreateNestedManyWithoutProfissionalInput
    laudosAssinados?: LaudoUncheckedCreateNestedManyWithoutProfissionalInput
  }

  export type ProfissionalCreateOrConnectWithoutClientesResponsavelInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutClientesResponsavelInput, ProfissionalUncheckedCreateWithoutClientesResponsavelInput>
  }

  export type AnimalUpsertWithWhereUniqueWithoutClienteInput = {
    where: AnimalWhereUniqueInput
    update: XOR<AnimalUpdateWithoutClienteInput, AnimalUncheckedUpdateWithoutClienteInput>
    create: XOR<AnimalCreateWithoutClienteInput, AnimalUncheckedCreateWithoutClienteInput>
  }

  export type AnimalUpdateWithWhereUniqueWithoutClienteInput = {
    where: AnimalWhereUniqueInput
    data: XOR<AnimalUpdateWithoutClienteInput, AnimalUncheckedUpdateWithoutClienteInput>
  }

  export type AnimalUpdateManyWithWhereWithoutClienteInput = {
    where: AnimalScalarWhereInput
    data: XOR<AnimalUpdateManyMutationInput, AnimalUncheckedUpdateManyWithoutClienteInput>
  }

  export type AnimalScalarWhereInput = {
    AND?: AnimalScalarWhereInput | AnimalScalarWhereInput[]
    OR?: AnimalScalarWhereInput[]
    NOT?: AnimalScalarWhereInput | AnimalScalarWhereInput[]
    id?: IntFilter<"Animal"> | number
    nome?: StringFilter<"Animal"> | string
    especieId?: IntFilter<"Animal"> | number
    raca?: StringNullableFilter<"Animal"> | string | null
    sexo?: EnumSexoAnimalFilter<"Animal"> | $Enums.SexoAnimal
    idade?: StringNullableFilter<"Animal"> | string | null
    peso?: DecimalNullableFilter<"Animal"> | Decimal | DecimalJsLike | number | string | null
    cor?: StringNullableFilter<"Animal"> | string | null
    clienteId?: IntFilter<"Animal"> | number
    observacoes?: StringNullableFilter<"Animal"> | string | null
    ativo?: BoolFilter<"Animal"> | boolean
    createdAt?: DateTimeFilter<"Animal"> | Date | string
    updatedAt?: DateTimeFilter<"Animal"> | Date | string
  }

  export type PedidoUpsertWithWhereUniqueWithoutClienteInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutClienteInput, PedidoUncheckedUpdateWithoutClienteInput>
    create: XOR<PedidoCreateWithoutClienteInput, PedidoUncheckedCreateWithoutClienteInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutClienteInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutClienteInput, PedidoUncheckedUpdateWithoutClienteInput>
  }

  export type PedidoUpdateManyWithWhereWithoutClienteInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutClienteInput>
  }

  export type ProfissionalUpsertWithoutClientesResponsavelInput = {
    update: XOR<ProfissionalUpdateWithoutClientesResponsavelInput, ProfissionalUncheckedUpdateWithoutClientesResponsavelInput>
    create: XOR<ProfissionalCreateWithoutClientesResponsavelInput, ProfissionalUncheckedCreateWithoutClientesResponsavelInput>
    where?: ProfissionalWhereInput
  }

  export type ProfissionalUpdateToOneWithWhereWithoutClientesResponsavelInput = {
    where?: ProfissionalWhereInput
    data: XOR<ProfissionalUpdateWithoutClientesResponsavelInput, ProfissionalUncheckedUpdateWithoutClientesResponsavelInput>
  }

  export type ProfissionalUpdateWithoutClientesResponsavelInput = {
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conselho?: ConselhoUpdateOneWithoutProfissionaisNestedInput
    pedidosSolicitados?: PedidoUpdateManyWithoutProfissionalNestedInput
    laudosAssinados?: LaudoUpdateManyWithoutProfissionalNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutClientesResponsavelInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    conselhoId?: NullableIntFieldUpdateOperationsInput | number | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidosSolicitados?: PedidoUncheckedUpdateManyWithoutProfissionalNestedInput
    laudosAssinados?: LaudoUncheckedUpdateManyWithoutProfissionalNestedInput
  }

  export type AnimalCreateWithoutEspecieInput = {
    nome: string
    raca?: string | null
    sexo: $Enums.SexoAnimal
    idade?: string | null
    peso?: Decimal | DecimalJsLike | number | string | null
    cor?: string | null
    observacoes?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutAnimaisInput
    pedidos?: PedidoCreateNestedManyWithoutAnimalInput
  }

  export type AnimalUncheckedCreateWithoutEspecieInput = {
    id?: number
    nome: string
    raca?: string | null
    sexo: $Enums.SexoAnimal
    idade?: string | null
    peso?: Decimal | DecimalJsLike | number | string | null
    cor?: string | null
    clienteId: number
    observacoes?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutAnimalInput
  }

  export type AnimalCreateOrConnectWithoutEspecieInput = {
    where: AnimalWhereUniqueInput
    create: XOR<AnimalCreateWithoutEspecieInput, AnimalUncheckedCreateWithoutEspecieInput>
  }

  export type AnimalCreateManyEspecieInputEnvelope = {
    data: AnimalCreateManyEspecieInput | AnimalCreateManyEspecieInput[]
    skipDuplicates?: boolean
  }

  export type AnimalUpsertWithWhereUniqueWithoutEspecieInput = {
    where: AnimalWhereUniqueInput
    update: XOR<AnimalUpdateWithoutEspecieInput, AnimalUncheckedUpdateWithoutEspecieInput>
    create: XOR<AnimalCreateWithoutEspecieInput, AnimalUncheckedCreateWithoutEspecieInput>
  }

  export type AnimalUpdateWithWhereUniqueWithoutEspecieInput = {
    where: AnimalWhereUniqueInput
    data: XOR<AnimalUpdateWithoutEspecieInput, AnimalUncheckedUpdateWithoutEspecieInput>
  }

  export type AnimalUpdateManyWithWhereWithoutEspecieInput = {
    where: AnimalScalarWhereInput
    data: XOR<AnimalUpdateManyMutationInput, AnimalUncheckedUpdateManyWithoutEspecieInput>
  }

  export type EspecieCreateWithoutAnimaisInput = {
    nome: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EspecieUncheckedCreateWithoutAnimaisInput = {
    id?: number
    nome: string
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EspecieCreateOrConnectWithoutAnimaisInput = {
    where: EspecieWhereUniqueInput
    create: XOR<EspecieCreateWithoutAnimaisInput, EspecieUncheckedCreateWithoutAnimaisInput>
  }

  export type ClienteCreateWithoutAnimaisInput = {
    nome: string
    endereco?: string | null
    numero?: string | null
    complemento?: string | null
    bairro?: string | null
    cep?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    fax?: string | null
    celular?: string | null
    email?: string | null
    cpfCnpj?: string | null
    contato?: string | null
    dataCadastro?: Date | string
    restricao?: string | null
    dataAtualizacao?: Date | string | null
    ativo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoCreateNestedManyWithoutClienteInput
    veterinarioResp?: ProfissionalCreateNestedOneWithoutClientesResponsavelInput
  }

  export type ClienteUncheckedCreateWithoutAnimaisInput = {
    id?: number
    nome: string
    endereco?: string | null
    numero?: string | null
    complemento?: string | null
    bairro?: string | null
    cep?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    fax?: string | null
    celular?: string | null
    email?: string | null
    cpfCnpj?: string | null
    contato?: string | null
    dataCadastro?: Date | string
    restricao?: string | null
    dataAtualizacao?: Date | string | null
    ativo?: string
    codVetResp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidos?: PedidoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutAnimaisInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutAnimaisInput, ClienteUncheckedCreateWithoutAnimaisInput>
  }

  export type PedidoCreateWithoutAnimalInput = {
    numero: string
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutPedidosInput
    profissional?: ProfissionalCreateNestedOneWithoutPedidosSolicitadosInput
    usuario: UsuarioCreateNestedOneWithoutPedidosCriadosInput
    exames?: PedidoExameCreateNestedManyWithoutPedidoInput
    laudos?: LaudoCreateNestedManyWithoutPedidoInput
    contas?: ContaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutAnimalInput = {
    id?: number
    numero: string
    clienteId: number
    profissionalId?: number | null
    usuarioId: number
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exames?: PedidoExameUncheckedCreateNestedManyWithoutPedidoInput
    laudos?: LaudoUncheckedCreateNestedManyWithoutPedidoInput
    contas?: ContaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutAnimalInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutAnimalInput, PedidoUncheckedCreateWithoutAnimalInput>
  }

  export type PedidoCreateManyAnimalInputEnvelope = {
    data: PedidoCreateManyAnimalInput | PedidoCreateManyAnimalInput[]
    skipDuplicates?: boolean
  }

  export type EspecieUpsertWithoutAnimaisInput = {
    update: XOR<EspecieUpdateWithoutAnimaisInput, EspecieUncheckedUpdateWithoutAnimaisInput>
    create: XOR<EspecieCreateWithoutAnimaisInput, EspecieUncheckedCreateWithoutAnimaisInput>
    where?: EspecieWhereInput
  }

  export type EspecieUpdateToOneWithWhereWithoutAnimaisInput = {
    where?: EspecieWhereInput
    data: XOR<EspecieUpdateWithoutAnimaisInput, EspecieUncheckedUpdateWithoutAnimaisInput>
  }

  export type EspecieUpdateWithoutAnimaisInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EspecieUncheckedUpdateWithoutAnimaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteUpsertWithoutAnimaisInput = {
    update: XOR<ClienteUpdateWithoutAnimaisInput, ClienteUncheckedUpdateWithoutAnimaisInput>
    create: XOR<ClienteCreateWithoutAnimaisInput, ClienteUncheckedCreateWithoutAnimaisInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutAnimaisInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutAnimaisInput, ClienteUncheckedUpdateWithoutAnimaisInput>
  }

  export type ClienteUpdateWithoutAnimaisInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contato?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    restricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataAtualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUpdateManyWithoutClienteNestedInput
    veterinarioResp?: ProfissionalUpdateOneWithoutClientesResponsavelNestedInput
  }

  export type ClienteUncheckedUpdateWithoutAnimaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contato?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    restricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataAtualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: StringFieldUpdateOperationsInput | string
    codVetResp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type PedidoUpsertWithWhereUniqueWithoutAnimalInput = {
    where: PedidoWhereUniqueInput
    update: XOR<PedidoUpdateWithoutAnimalInput, PedidoUncheckedUpdateWithoutAnimalInput>
    create: XOR<PedidoCreateWithoutAnimalInput, PedidoUncheckedCreateWithoutAnimalInput>
  }

  export type PedidoUpdateWithWhereUniqueWithoutAnimalInput = {
    where: PedidoWhereUniqueInput
    data: XOR<PedidoUpdateWithoutAnimalInput, PedidoUncheckedUpdateWithoutAnimalInput>
  }

  export type PedidoUpdateManyWithWhereWithoutAnimalInput = {
    where: PedidoScalarWhereInput
    data: XOR<PedidoUpdateManyMutationInput, PedidoUncheckedUpdateManyWithoutAnimalInput>
  }

  export type ParametroExameCreateWithoutExameInput = {
    nome: string
    unidade?: string | null
    valorReferencia?: string | null
    ordem?: number
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resultados?: ResultadoExameCreateNestedManyWithoutParametroInput
  }

  export type ParametroExameUncheckedCreateWithoutExameInput = {
    id?: number
    nome: string
    unidade?: string | null
    valorReferencia?: string | null
    ordem?: number
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resultados?: ResultadoExameUncheckedCreateNestedManyWithoutParametroInput
  }

  export type ParametroExameCreateOrConnectWithoutExameInput = {
    where: ParametroExameWhereUniqueInput
    create: XOR<ParametroExameCreateWithoutExameInput, ParametroExameUncheckedCreateWithoutExameInput>
  }

  export type ParametroExameCreateManyExameInputEnvelope = {
    data: ParametroExameCreateManyExameInput | ParametroExameCreateManyExameInput[]
    skipDuplicates?: boolean
  }

  export type PedidoExameCreateWithoutExameInput = {
    valor?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.StatusExame
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido: PedidoCreateNestedOneWithoutExamesInput
    resultados?: ResultadoExameCreateNestedManyWithoutPedidoExameInput
  }

  export type PedidoExameUncheckedCreateWithoutExameInput = {
    id?: number
    pedidoId: number
    valor?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.StatusExame
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resultados?: ResultadoExameUncheckedCreateNestedManyWithoutPedidoExameInput
  }

  export type PedidoExameCreateOrConnectWithoutExameInput = {
    where: PedidoExameWhereUniqueInput
    create: XOR<PedidoExameCreateWithoutExameInput, PedidoExameUncheckedCreateWithoutExameInput>
  }

  export type PedidoExameCreateManyExameInputEnvelope = {
    data: PedidoExameCreateManyExameInput | PedidoExameCreateManyExameInput[]
    skipDuplicates?: boolean
  }

  export type ParametroExameUpsertWithWhereUniqueWithoutExameInput = {
    where: ParametroExameWhereUniqueInput
    update: XOR<ParametroExameUpdateWithoutExameInput, ParametroExameUncheckedUpdateWithoutExameInput>
    create: XOR<ParametroExameCreateWithoutExameInput, ParametroExameUncheckedCreateWithoutExameInput>
  }

  export type ParametroExameUpdateWithWhereUniqueWithoutExameInput = {
    where: ParametroExameWhereUniqueInput
    data: XOR<ParametroExameUpdateWithoutExameInput, ParametroExameUncheckedUpdateWithoutExameInput>
  }

  export type ParametroExameUpdateManyWithWhereWithoutExameInput = {
    where: ParametroExameScalarWhereInput
    data: XOR<ParametroExameUpdateManyMutationInput, ParametroExameUncheckedUpdateManyWithoutExameInput>
  }

  export type ParametroExameScalarWhereInput = {
    AND?: ParametroExameScalarWhereInput | ParametroExameScalarWhereInput[]
    OR?: ParametroExameScalarWhereInput[]
    NOT?: ParametroExameScalarWhereInput | ParametroExameScalarWhereInput[]
    id?: IntFilter<"ParametroExame"> | number
    exameId?: IntFilter<"ParametroExame"> | number
    nome?: StringFilter<"ParametroExame"> | string
    unidade?: StringNullableFilter<"ParametroExame"> | string | null
    valorReferencia?: StringNullableFilter<"ParametroExame"> | string | null
    ordem?: IntFilter<"ParametroExame"> | number
    ativo?: BoolFilter<"ParametroExame"> | boolean
    createdAt?: DateTimeFilter<"ParametroExame"> | Date | string
    updatedAt?: DateTimeFilter<"ParametroExame"> | Date | string
  }

  export type PedidoExameUpsertWithWhereUniqueWithoutExameInput = {
    where: PedidoExameWhereUniqueInput
    update: XOR<PedidoExameUpdateWithoutExameInput, PedidoExameUncheckedUpdateWithoutExameInput>
    create: XOR<PedidoExameCreateWithoutExameInput, PedidoExameUncheckedCreateWithoutExameInput>
  }

  export type PedidoExameUpdateWithWhereUniqueWithoutExameInput = {
    where: PedidoExameWhereUniqueInput
    data: XOR<PedidoExameUpdateWithoutExameInput, PedidoExameUncheckedUpdateWithoutExameInput>
  }

  export type PedidoExameUpdateManyWithWhereWithoutExameInput = {
    where: PedidoExameScalarWhereInput
    data: XOR<PedidoExameUpdateManyMutationInput, PedidoExameUncheckedUpdateManyWithoutExameInput>
  }

  export type PedidoExameScalarWhereInput = {
    AND?: PedidoExameScalarWhereInput | PedidoExameScalarWhereInput[]
    OR?: PedidoExameScalarWhereInput[]
    NOT?: PedidoExameScalarWhereInput | PedidoExameScalarWhereInput[]
    id?: IntFilter<"PedidoExame"> | number
    pedidoId?: IntFilter<"PedidoExame"> | number
    exameId?: IntFilter<"PedidoExame"> | number
    valor?: DecimalNullableFilter<"PedidoExame"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFilter<"PedidoExame"> | $Enums.StatusExame
    observacoes?: StringNullableFilter<"PedidoExame"> | string | null
    createdAt?: DateTimeFilter<"PedidoExame"> | Date | string
    updatedAt?: DateTimeFilter<"PedidoExame"> | Date | string
  }

  export type ExameCreateWithoutParametrosInput = {
    codigo: string
    nome: string
    descricao?: string | null
    metodologia?: string | null
    material?: string | null
    valor?: Decimal | DecimalJsLike | number | string | null
    tempoResultado?: number | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidoExames?: PedidoExameCreateNestedManyWithoutExameInput
  }

  export type ExameUncheckedCreateWithoutParametrosInput = {
    id?: number
    codigo: string
    nome: string
    descricao?: string | null
    metodologia?: string | null
    material?: string | null
    valor?: Decimal | DecimalJsLike | number | string | null
    tempoResultado?: number | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidoExames?: PedidoExameUncheckedCreateNestedManyWithoutExameInput
  }

  export type ExameCreateOrConnectWithoutParametrosInput = {
    where: ExameWhereUniqueInput
    create: XOR<ExameCreateWithoutParametrosInput, ExameUncheckedCreateWithoutParametrosInput>
  }

  export type ResultadoExameCreateWithoutParametroInput = {
    valor?: string | null
    observacao?: string | null
    alterado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidoExame: PedidoExameCreateNestedOneWithoutResultadosInput
  }

  export type ResultadoExameUncheckedCreateWithoutParametroInput = {
    id?: number
    pedidoExameId: number
    valor?: string | null
    observacao?: string | null
    alterado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultadoExameCreateOrConnectWithoutParametroInput = {
    where: ResultadoExameWhereUniqueInput
    create: XOR<ResultadoExameCreateWithoutParametroInput, ResultadoExameUncheckedCreateWithoutParametroInput>
  }

  export type ResultadoExameCreateManyParametroInputEnvelope = {
    data: ResultadoExameCreateManyParametroInput | ResultadoExameCreateManyParametroInput[]
    skipDuplicates?: boolean
  }

  export type ExameUpsertWithoutParametrosInput = {
    update: XOR<ExameUpdateWithoutParametrosInput, ExameUncheckedUpdateWithoutParametrosInput>
    create: XOR<ExameCreateWithoutParametrosInput, ExameUncheckedCreateWithoutParametrosInput>
    where?: ExameWhereInput
  }

  export type ExameUpdateToOneWithWhereWithoutParametrosInput = {
    where?: ExameWhereInput
    data: XOR<ExameUpdateWithoutParametrosInput, ExameUncheckedUpdateWithoutParametrosInput>
  }

  export type ExameUpdateWithoutParametrosInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempoResultado?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidoExames?: PedidoExameUpdateManyWithoutExameNestedInput
  }

  export type ExameUncheckedUpdateWithoutParametrosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempoResultado?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidoExames?: PedidoExameUncheckedUpdateManyWithoutExameNestedInput
  }

  export type ResultadoExameUpsertWithWhereUniqueWithoutParametroInput = {
    where: ResultadoExameWhereUniqueInput
    update: XOR<ResultadoExameUpdateWithoutParametroInput, ResultadoExameUncheckedUpdateWithoutParametroInput>
    create: XOR<ResultadoExameCreateWithoutParametroInput, ResultadoExameUncheckedCreateWithoutParametroInput>
  }

  export type ResultadoExameUpdateWithWhereUniqueWithoutParametroInput = {
    where: ResultadoExameWhereUniqueInput
    data: XOR<ResultadoExameUpdateWithoutParametroInput, ResultadoExameUncheckedUpdateWithoutParametroInput>
  }

  export type ResultadoExameUpdateManyWithWhereWithoutParametroInput = {
    where: ResultadoExameScalarWhereInput
    data: XOR<ResultadoExameUpdateManyMutationInput, ResultadoExameUncheckedUpdateManyWithoutParametroInput>
  }

  export type ResultadoExameScalarWhereInput = {
    AND?: ResultadoExameScalarWhereInput | ResultadoExameScalarWhereInput[]
    OR?: ResultadoExameScalarWhereInput[]
    NOT?: ResultadoExameScalarWhereInput | ResultadoExameScalarWhereInput[]
    id?: IntFilter<"ResultadoExame"> | number
    pedidoExameId?: IntFilter<"ResultadoExame"> | number
    parametroId?: IntFilter<"ResultadoExame"> | number
    valor?: StringNullableFilter<"ResultadoExame"> | string | null
    observacao?: StringNullableFilter<"ResultadoExame"> | string | null
    alterado?: BoolFilter<"ResultadoExame"> | boolean
    createdAt?: DateTimeFilter<"ResultadoExame"> | Date | string
    updatedAt?: DateTimeFilter<"ResultadoExame"> | Date | string
  }

  export type ClienteCreateWithoutPedidosInput = {
    nome: string
    endereco?: string | null
    numero?: string | null
    complemento?: string | null
    bairro?: string | null
    cep?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    fax?: string | null
    celular?: string | null
    email?: string | null
    cpfCnpj?: string | null
    contato?: string | null
    dataCadastro?: Date | string
    restricao?: string | null
    dataAtualizacao?: Date | string | null
    ativo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    animais?: AnimalCreateNestedManyWithoutClienteInput
    veterinarioResp?: ProfissionalCreateNestedOneWithoutClientesResponsavelInput
  }

  export type ClienteUncheckedCreateWithoutPedidosInput = {
    id?: number
    nome: string
    endereco?: string | null
    numero?: string | null
    complemento?: string | null
    bairro?: string | null
    cep?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    fax?: string | null
    celular?: string | null
    email?: string | null
    cpfCnpj?: string | null
    contato?: string | null
    dataCadastro?: Date | string
    restricao?: string | null
    dataAtualizacao?: Date | string | null
    ativo?: string
    codVetResp?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    animais?: AnimalUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutPedidosInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutPedidosInput, ClienteUncheckedCreateWithoutPedidosInput>
  }

  export type AnimalCreateWithoutPedidosInput = {
    nome: string
    raca?: string | null
    sexo: $Enums.SexoAnimal
    idade?: string | null
    peso?: Decimal | DecimalJsLike | number | string | null
    cor?: string | null
    observacoes?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    especie: EspecieCreateNestedOneWithoutAnimaisInput
    cliente: ClienteCreateNestedOneWithoutAnimaisInput
  }

  export type AnimalUncheckedCreateWithoutPedidosInput = {
    id?: number
    nome: string
    especieId: number
    raca?: string | null
    sexo: $Enums.SexoAnimal
    idade?: string | null
    peso?: Decimal | DecimalJsLike | number | string | null
    cor?: string | null
    clienteId: number
    observacoes?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnimalCreateOrConnectWithoutPedidosInput = {
    where: AnimalWhereUniqueInput
    create: XOR<AnimalCreateWithoutPedidosInput, AnimalUncheckedCreateWithoutPedidosInput>
  }

  export type ProfissionalCreateWithoutPedidosSolicitadosInput = {
    nome: string
    documento?: string | null
    registro?: string | null
    telefone?: string | null
    email?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    tipo: $Enums.TipoProfissional
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conselho?: ConselhoCreateNestedOneWithoutProfissionaisInput
    laudosAssinados?: LaudoCreateNestedManyWithoutProfissionalInput
    clientesResponsavel?: ClienteCreateNestedManyWithoutVeterinarioRespInput
  }

  export type ProfissionalUncheckedCreateWithoutPedidosSolicitadosInput = {
    id?: number
    nome: string
    documento?: string | null
    registro?: string | null
    conselhoId?: number | null
    telefone?: string | null
    email?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    tipo: $Enums.TipoProfissional
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    laudosAssinados?: LaudoUncheckedCreateNestedManyWithoutProfissionalInput
    clientesResponsavel?: ClienteUncheckedCreateNestedManyWithoutVeterinarioRespInput
  }

  export type ProfissionalCreateOrConnectWithoutPedidosSolicitadosInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutPedidosSolicitadosInput, ProfissionalUncheckedCreateWithoutPedidosSolicitadosInput>
  }

  export type UsuarioCreateWithoutPedidosCriadosInput = {
    nome: string
    email: string
    senha: string
    perfil?: $Enums.PerfilUsuario
    ativo?: boolean
    ultimoLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    laudosLiberados?: LaudoCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPedidosCriadosInput = {
    id?: number
    nome: string
    email: string
    senha: string
    perfil?: $Enums.PerfilUsuario
    ativo?: boolean
    ultimoLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    laudosLiberados?: LaudoUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPedidosCriadosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPedidosCriadosInput, UsuarioUncheckedCreateWithoutPedidosCriadosInput>
  }

  export type PedidoExameCreateWithoutPedidoInput = {
    valor?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.StatusExame
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exame: ExameCreateNestedOneWithoutPedidoExamesInput
    resultados?: ResultadoExameCreateNestedManyWithoutPedidoExameInput
  }

  export type PedidoExameUncheckedCreateWithoutPedidoInput = {
    id?: number
    exameId: number
    valor?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.StatusExame
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resultados?: ResultadoExameUncheckedCreateNestedManyWithoutPedidoExameInput
  }

  export type PedidoExameCreateOrConnectWithoutPedidoInput = {
    where: PedidoExameWhereUniqueInput
    create: XOR<PedidoExameCreateWithoutPedidoInput, PedidoExameUncheckedCreateWithoutPedidoInput>
  }

  export type PedidoExameCreateManyPedidoInputEnvelope = {
    data: PedidoExameCreateManyPedidoInput | PedidoExameCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type LaudoCreateWithoutPedidoInput = {
    conteudo: string
    observacoes?: string | null
    dataLiberacao?: Date | string | null
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profissional?: ProfissionalCreateNestedOneWithoutLaudosAssinadosInput
    usuario?: UsuarioCreateNestedOneWithoutLaudosLiberadosInput
  }

  export type LaudoUncheckedCreateWithoutPedidoInput = {
    id?: number
    profissionalId?: number | null
    usuarioId?: number | null
    conteudo: string
    observacoes?: string | null
    dataLiberacao?: Date | string | null
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaudoCreateOrConnectWithoutPedidoInput = {
    where: LaudoWhereUniqueInput
    create: XOR<LaudoCreateWithoutPedidoInput, LaudoUncheckedCreateWithoutPedidoInput>
  }

  export type LaudoCreateManyPedidoInputEnvelope = {
    data: LaudoCreateManyPedidoInput | LaudoCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type ContaCreateWithoutPedidoInput = {
    tipo: $Enums.TipoConta
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    dataVencimento: Date | string
    dataPagamento?: Date | string | null
    status?: $Enums.StatusConta
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    banco?: BancoCreateNestedOneWithoutContasInput
  }

  export type ContaUncheckedCreateWithoutPedidoInput = {
    id?: number
    bancoId?: number | null
    tipo: $Enums.TipoConta
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    dataVencimento: Date | string
    dataPagamento?: Date | string | null
    status?: $Enums.StatusConta
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContaCreateOrConnectWithoutPedidoInput = {
    where: ContaWhereUniqueInput
    create: XOR<ContaCreateWithoutPedidoInput, ContaUncheckedCreateWithoutPedidoInput>
  }

  export type ContaCreateManyPedidoInputEnvelope = {
    data: ContaCreateManyPedidoInput | ContaCreateManyPedidoInput[]
    skipDuplicates?: boolean
  }

  export type ClienteUpsertWithoutPedidosInput = {
    update: XOR<ClienteUpdateWithoutPedidosInput, ClienteUncheckedUpdateWithoutPedidosInput>
    create: XOR<ClienteCreateWithoutPedidosInput, ClienteUncheckedCreateWithoutPedidosInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutPedidosInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutPedidosInput, ClienteUncheckedUpdateWithoutPedidosInput>
  }

  export type ClienteUpdateWithoutPedidosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contato?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    restricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataAtualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animais?: AnimalUpdateManyWithoutClienteNestedInput
    veterinarioResp?: ProfissionalUpdateOneWithoutClientesResponsavelNestedInput
  }

  export type ClienteUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contato?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    restricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataAtualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: StringFieldUpdateOperationsInput | string
    codVetResp?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animais?: AnimalUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type AnimalUpsertWithoutPedidosInput = {
    update: XOR<AnimalUpdateWithoutPedidosInput, AnimalUncheckedUpdateWithoutPedidosInput>
    create: XOR<AnimalCreateWithoutPedidosInput, AnimalUncheckedCreateWithoutPedidosInput>
    where?: AnimalWhereInput
  }

  export type AnimalUpdateToOneWithWhereWithoutPedidosInput = {
    where?: AnimalWhereInput
    data: XOR<AnimalUpdateWithoutPedidosInput, AnimalUncheckedUpdateWithoutPedidosInput>
  }

  export type AnimalUpdateWithoutPedidosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    raca?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoAnimalFieldUpdateOperationsInput | $Enums.SexoAnimal
    idade?: NullableStringFieldUpdateOperationsInput | string | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    especie?: EspecieUpdateOneRequiredWithoutAnimaisNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutAnimaisNestedInput
  }

  export type AnimalUncheckedUpdateWithoutPedidosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    especieId?: IntFieldUpdateOperationsInput | number
    raca?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoAnimalFieldUpdateOperationsInput | $Enums.SexoAnimal
    idade?: NullableStringFieldUpdateOperationsInput | string | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    clienteId?: IntFieldUpdateOperationsInput | number
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfissionalUpsertWithoutPedidosSolicitadosInput = {
    update: XOR<ProfissionalUpdateWithoutPedidosSolicitadosInput, ProfissionalUncheckedUpdateWithoutPedidosSolicitadosInput>
    create: XOR<ProfissionalCreateWithoutPedidosSolicitadosInput, ProfissionalUncheckedCreateWithoutPedidosSolicitadosInput>
    where?: ProfissionalWhereInput
  }

  export type ProfissionalUpdateToOneWithWhereWithoutPedidosSolicitadosInput = {
    where?: ProfissionalWhereInput
    data: XOR<ProfissionalUpdateWithoutPedidosSolicitadosInput, ProfissionalUncheckedUpdateWithoutPedidosSolicitadosInput>
  }

  export type ProfissionalUpdateWithoutPedidosSolicitadosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conselho?: ConselhoUpdateOneWithoutProfissionaisNestedInput
    laudosAssinados?: LaudoUpdateManyWithoutProfissionalNestedInput
    clientesResponsavel?: ClienteUpdateManyWithoutVeterinarioRespNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutPedidosSolicitadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    conselhoId?: NullableIntFieldUpdateOperationsInput | number | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laudosAssinados?: LaudoUncheckedUpdateManyWithoutProfissionalNestedInput
    clientesResponsavel?: ClienteUncheckedUpdateManyWithoutVeterinarioRespNestedInput
  }

  export type UsuarioUpsertWithoutPedidosCriadosInput = {
    update: XOR<UsuarioUpdateWithoutPedidosCriadosInput, UsuarioUncheckedUpdateWithoutPedidosCriadosInput>
    create: XOR<UsuarioCreateWithoutPedidosCriadosInput, UsuarioUncheckedCreateWithoutPedidosCriadosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPedidosCriadosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPedidosCriadosInput, UsuarioUncheckedUpdateWithoutPedidosCriadosInput>
  }

  export type UsuarioUpdateWithoutPedidosCriadosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: EnumPerfilUsuarioFieldUpdateOperationsInput | $Enums.PerfilUsuario
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laudosLiberados?: LaudoUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPedidosCriadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: EnumPerfilUsuarioFieldUpdateOperationsInput | $Enums.PerfilUsuario
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laudosLiberados?: LaudoUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type PedidoExameUpsertWithWhereUniqueWithoutPedidoInput = {
    where: PedidoExameWhereUniqueInput
    update: XOR<PedidoExameUpdateWithoutPedidoInput, PedidoExameUncheckedUpdateWithoutPedidoInput>
    create: XOR<PedidoExameCreateWithoutPedidoInput, PedidoExameUncheckedCreateWithoutPedidoInput>
  }

  export type PedidoExameUpdateWithWhereUniqueWithoutPedidoInput = {
    where: PedidoExameWhereUniqueInput
    data: XOR<PedidoExameUpdateWithoutPedidoInput, PedidoExameUncheckedUpdateWithoutPedidoInput>
  }

  export type PedidoExameUpdateManyWithWhereWithoutPedidoInput = {
    where: PedidoExameScalarWhereInput
    data: XOR<PedidoExameUpdateManyMutationInput, PedidoExameUncheckedUpdateManyWithoutPedidoInput>
  }

  export type LaudoUpsertWithWhereUniqueWithoutPedidoInput = {
    where: LaudoWhereUniqueInput
    update: XOR<LaudoUpdateWithoutPedidoInput, LaudoUncheckedUpdateWithoutPedidoInput>
    create: XOR<LaudoCreateWithoutPedidoInput, LaudoUncheckedCreateWithoutPedidoInput>
  }

  export type LaudoUpdateWithWhereUniqueWithoutPedidoInput = {
    where: LaudoWhereUniqueInput
    data: XOR<LaudoUpdateWithoutPedidoInput, LaudoUncheckedUpdateWithoutPedidoInput>
  }

  export type LaudoUpdateManyWithWhereWithoutPedidoInput = {
    where: LaudoScalarWhereInput
    data: XOR<LaudoUpdateManyMutationInput, LaudoUncheckedUpdateManyWithoutPedidoInput>
  }

  export type ContaUpsertWithWhereUniqueWithoutPedidoInput = {
    where: ContaWhereUniqueInput
    update: XOR<ContaUpdateWithoutPedidoInput, ContaUncheckedUpdateWithoutPedidoInput>
    create: XOR<ContaCreateWithoutPedidoInput, ContaUncheckedCreateWithoutPedidoInput>
  }

  export type ContaUpdateWithWhereUniqueWithoutPedidoInput = {
    where: ContaWhereUniqueInput
    data: XOR<ContaUpdateWithoutPedidoInput, ContaUncheckedUpdateWithoutPedidoInput>
  }

  export type ContaUpdateManyWithWhereWithoutPedidoInput = {
    where: ContaScalarWhereInput
    data: XOR<ContaUpdateManyMutationInput, ContaUncheckedUpdateManyWithoutPedidoInput>
  }

  export type ContaScalarWhereInput = {
    AND?: ContaScalarWhereInput | ContaScalarWhereInput[]
    OR?: ContaScalarWhereInput[]
    NOT?: ContaScalarWhereInput | ContaScalarWhereInput[]
    id?: IntFilter<"Conta"> | number
    pedidoId?: IntNullableFilter<"Conta"> | number | null
    bancoId?: IntNullableFilter<"Conta"> | number | null
    tipo?: EnumTipoContaFilter<"Conta"> | $Enums.TipoConta
    descricao?: StringFilter<"Conta"> | string
    valor?: DecimalFilter<"Conta"> | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFilter<"Conta"> | Date | string
    dataPagamento?: DateTimeNullableFilter<"Conta"> | Date | string | null
    status?: EnumStatusContaFilter<"Conta"> | $Enums.StatusConta
    observacoes?: StringNullableFilter<"Conta"> | string | null
    createdAt?: DateTimeFilter<"Conta"> | Date | string
    updatedAt?: DateTimeFilter<"Conta"> | Date | string
  }

  export type PedidoCreateWithoutExamesInput = {
    numero: string
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutPedidosInput
    animal: AnimalCreateNestedOneWithoutPedidosInput
    profissional?: ProfissionalCreateNestedOneWithoutPedidosSolicitadosInput
    usuario: UsuarioCreateNestedOneWithoutPedidosCriadosInput
    laudos?: LaudoCreateNestedManyWithoutPedidoInput
    contas?: ContaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutExamesInput = {
    id?: number
    numero: string
    clienteId: number
    animalId: number
    profissionalId?: number | null
    usuarioId: number
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    laudos?: LaudoUncheckedCreateNestedManyWithoutPedidoInput
    contas?: ContaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutExamesInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutExamesInput, PedidoUncheckedCreateWithoutExamesInput>
  }

  export type ExameCreateWithoutPedidoExamesInput = {
    codigo: string
    nome: string
    descricao?: string | null
    metodologia?: string | null
    material?: string | null
    valor?: Decimal | DecimalJsLike | number | string | null
    tempoResultado?: number | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parametros?: ParametroExameCreateNestedManyWithoutExameInput
  }

  export type ExameUncheckedCreateWithoutPedidoExamesInput = {
    id?: number
    codigo: string
    nome: string
    descricao?: string | null
    metodologia?: string | null
    material?: string | null
    valor?: Decimal | DecimalJsLike | number | string | null
    tempoResultado?: number | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parametros?: ParametroExameUncheckedCreateNestedManyWithoutExameInput
  }

  export type ExameCreateOrConnectWithoutPedidoExamesInput = {
    where: ExameWhereUniqueInput
    create: XOR<ExameCreateWithoutPedidoExamesInput, ExameUncheckedCreateWithoutPedidoExamesInput>
  }

  export type ResultadoExameCreateWithoutPedidoExameInput = {
    valor?: string | null
    observacao?: string | null
    alterado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parametro: ParametroExameCreateNestedOneWithoutResultadosInput
  }

  export type ResultadoExameUncheckedCreateWithoutPedidoExameInput = {
    id?: number
    parametroId: number
    valor?: string | null
    observacao?: string | null
    alterado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultadoExameCreateOrConnectWithoutPedidoExameInput = {
    where: ResultadoExameWhereUniqueInput
    create: XOR<ResultadoExameCreateWithoutPedidoExameInput, ResultadoExameUncheckedCreateWithoutPedidoExameInput>
  }

  export type ResultadoExameCreateManyPedidoExameInputEnvelope = {
    data: ResultadoExameCreateManyPedidoExameInput | ResultadoExameCreateManyPedidoExameInput[]
    skipDuplicates?: boolean
  }

  export type PedidoUpsertWithoutExamesInput = {
    update: XOR<PedidoUpdateWithoutExamesInput, PedidoUncheckedUpdateWithoutExamesInput>
    create: XOR<PedidoCreateWithoutExamesInput, PedidoUncheckedCreateWithoutExamesInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutExamesInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutExamesInput, PedidoUncheckedUpdateWithoutExamesInput>
  }

  export type PedidoUpdateWithoutExamesInput = {
    numero?: StringFieldUpdateOperationsInput | string
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutPedidosNestedInput
    animal?: AnimalUpdateOneRequiredWithoutPedidosNestedInput
    profissional?: ProfissionalUpdateOneWithoutPedidosSolicitadosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosCriadosNestedInput
    laudos?: LaudoUpdateManyWithoutPedidoNestedInput
    contas?: ContaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutExamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    clienteId?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: IntFieldUpdateOperationsInput | number
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laudos?: LaudoUncheckedUpdateManyWithoutPedidoNestedInput
    contas?: ContaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type ExameUpsertWithoutPedidoExamesInput = {
    update: XOR<ExameUpdateWithoutPedidoExamesInput, ExameUncheckedUpdateWithoutPedidoExamesInput>
    create: XOR<ExameCreateWithoutPedidoExamesInput, ExameUncheckedCreateWithoutPedidoExamesInput>
    where?: ExameWhereInput
  }

  export type ExameUpdateToOneWithWhereWithoutPedidoExamesInput = {
    where?: ExameWhereInput
    data: XOR<ExameUpdateWithoutPedidoExamesInput, ExameUncheckedUpdateWithoutPedidoExamesInput>
  }

  export type ExameUpdateWithoutPedidoExamesInput = {
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempoResultado?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parametros?: ParametroExameUpdateManyWithoutExameNestedInput
  }

  export type ExameUncheckedUpdateWithoutPedidoExamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    metodologia?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tempoResultado?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parametros?: ParametroExameUncheckedUpdateManyWithoutExameNestedInput
  }

  export type ResultadoExameUpsertWithWhereUniqueWithoutPedidoExameInput = {
    where: ResultadoExameWhereUniqueInput
    update: XOR<ResultadoExameUpdateWithoutPedidoExameInput, ResultadoExameUncheckedUpdateWithoutPedidoExameInput>
    create: XOR<ResultadoExameCreateWithoutPedidoExameInput, ResultadoExameUncheckedCreateWithoutPedidoExameInput>
  }

  export type ResultadoExameUpdateWithWhereUniqueWithoutPedidoExameInput = {
    where: ResultadoExameWhereUniqueInput
    data: XOR<ResultadoExameUpdateWithoutPedidoExameInput, ResultadoExameUncheckedUpdateWithoutPedidoExameInput>
  }

  export type ResultadoExameUpdateManyWithWhereWithoutPedidoExameInput = {
    where: ResultadoExameScalarWhereInput
    data: XOR<ResultadoExameUpdateManyMutationInput, ResultadoExameUncheckedUpdateManyWithoutPedidoExameInput>
  }

  export type PedidoExameCreateWithoutResultadosInput = {
    valor?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.StatusExame
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido: PedidoCreateNestedOneWithoutExamesInput
    exame: ExameCreateNestedOneWithoutPedidoExamesInput
  }

  export type PedidoExameUncheckedCreateWithoutResultadosInput = {
    id?: number
    pedidoId: number
    exameId: number
    valor?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.StatusExame
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoExameCreateOrConnectWithoutResultadosInput = {
    where: PedidoExameWhereUniqueInput
    create: XOR<PedidoExameCreateWithoutResultadosInput, PedidoExameUncheckedCreateWithoutResultadosInput>
  }

  export type ParametroExameCreateWithoutResultadosInput = {
    nome: string
    unidade?: string | null
    valorReferencia?: string | null
    ordem?: number
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exame: ExameCreateNestedOneWithoutParametrosInput
  }

  export type ParametroExameUncheckedCreateWithoutResultadosInput = {
    id?: number
    exameId: number
    nome: string
    unidade?: string | null
    valorReferencia?: string | null
    ordem?: number
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParametroExameCreateOrConnectWithoutResultadosInput = {
    where: ParametroExameWhereUniqueInput
    create: XOR<ParametroExameCreateWithoutResultadosInput, ParametroExameUncheckedCreateWithoutResultadosInput>
  }

  export type PedidoExameUpsertWithoutResultadosInput = {
    update: XOR<PedidoExameUpdateWithoutResultadosInput, PedidoExameUncheckedUpdateWithoutResultadosInput>
    create: XOR<PedidoExameCreateWithoutResultadosInput, PedidoExameUncheckedCreateWithoutResultadosInput>
    where?: PedidoExameWhereInput
  }

  export type PedidoExameUpdateToOneWithWhereWithoutResultadosInput = {
    where?: PedidoExameWhereInput
    data: XOR<PedidoExameUpdateWithoutResultadosInput, PedidoExameUncheckedUpdateWithoutResultadosInput>
  }

  export type PedidoExameUpdateWithoutResultadosInput = {
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFieldUpdateOperationsInput | $Enums.StatusExame
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutExamesNestedInput
    exame?: ExameUpdateOneRequiredWithoutPedidoExamesNestedInput
  }

  export type PedidoExameUncheckedUpdateWithoutResultadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    exameId?: IntFieldUpdateOperationsInput | number
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFieldUpdateOperationsInput | $Enums.StatusExame
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParametroExameUpsertWithoutResultadosInput = {
    update: XOR<ParametroExameUpdateWithoutResultadosInput, ParametroExameUncheckedUpdateWithoutResultadosInput>
    create: XOR<ParametroExameCreateWithoutResultadosInput, ParametroExameUncheckedCreateWithoutResultadosInput>
    where?: ParametroExameWhereInput
  }

  export type ParametroExameUpdateToOneWithWhereWithoutResultadosInput = {
    where?: ParametroExameWhereInput
    data: XOR<ParametroExameUpdateWithoutResultadosInput, ParametroExameUncheckedUpdateWithoutResultadosInput>
  }

  export type ParametroExameUpdateWithoutResultadosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    valorReferencia?: NullableStringFieldUpdateOperationsInput | string | null
    ordem?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exame?: ExameUpdateOneRequiredWithoutParametrosNestedInput
  }

  export type ParametroExameUncheckedUpdateWithoutResultadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    exameId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    valorReferencia?: NullableStringFieldUpdateOperationsInput | string | null
    ordem?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateWithoutLaudosInput = {
    numero: string
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutPedidosInput
    animal: AnimalCreateNestedOneWithoutPedidosInput
    profissional?: ProfissionalCreateNestedOneWithoutPedidosSolicitadosInput
    usuario: UsuarioCreateNestedOneWithoutPedidosCriadosInput
    exames?: PedidoExameCreateNestedManyWithoutPedidoInput
    contas?: ContaCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutLaudosInput = {
    id?: number
    numero: string
    clienteId: number
    animalId: number
    profissionalId?: number | null
    usuarioId: number
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exames?: PedidoExameUncheckedCreateNestedManyWithoutPedidoInput
    contas?: ContaUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutLaudosInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutLaudosInput, PedidoUncheckedCreateWithoutLaudosInput>
  }

  export type ProfissionalCreateWithoutLaudosAssinadosInput = {
    nome: string
    documento?: string | null
    registro?: string | null
    telefone?: string | null
    email?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    tipo: $Enums.TipoProfissional
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conselho?: ConselhoCreateNestedOneWithoutProfissionaisInput
    pedidosSolicitados?: PedidoCreateNestedManyWithoutProfissionalInput
    clientesResponsavel?: ClienteCreateNestedManyWithoutVeterinarioRespInput
  }

  export type ProfissionalUncheckedCreateWithoutLaudosAssinadosInput = {
    id?: number
    nome: string
    documento?: string | null
    registro?: string | null
    conselhoId?: number | null
    telefone?: string | null
    email?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    tipo: $Enums.TipoProfissional
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidosSolicitados?: PedidoUncheckedCreateNestedManyWithoutProfissionalInput
    clientesResponsavel?: ClienteUncheckedCreateNestedManyWithoutVeterinarioRespInput
  }

  export type ProfissionalCreateOrConnectWithoutLaudosAssinadosInput = {
    where: ProfissionalWhereUniqueInput
    create: XOR<ProfissionalCreateWithoutLaudosAssinadosInput, ProfissionalUncheckedCreateWithoutLaudosAssinadosInput>
  }

  export type UsuarioCreateWithoutLaudosLiberadosInput = {
    nome: string
    email: string
    senha: string
    perfil?: $Enums.PerfilUsuario
    ativo?: boolean
    ultimoLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidosCriados?: PedidoCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutLaudosLiberadosInput = {
    id?: number
    nome: string
    email: string
    senha: string
    perfil?: $Enums.PerfilUsuario
    ativo?: boolean
    ultimoLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidosCriados?: PedidoUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutLaudosLiberadosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutLaudosLiberadosInput, UsuarioUncheckedCreateWithoutLaudosLiberadosInput>
  }

  export type PedidoUpsertWithoutLaudosInput = {
    update: XOR<PedidoUpdateWithoutLaudosInput, PedidoUncheckedUpdateWithoutLaudosInput>
    create: XOR<PedidoCreateWithoutLaudosInput, PedidoUncheckedCreateWithoutLaudosInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutLaudosInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutLaudosInput, PedidoUncheckedUpdateWithoutLaudosInput>
  }

  export type PedidoUpdateWithoutLaudosInput = {
    numero?: StringFieldUpdateOperationsInput | string
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutPedidosNestedInput
    animal?: AnimalUpdateOneRequiredWithoutPedidosNestedInput
    profissional?: ProfissionalUpdateOneWithoutPedidosSolicitadosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosCriadosNestedInput
    exames?: PedidoExameUpdateManyWithoutPedidoNestedInput
    contas?: ContaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutLaudosInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    clienteId?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: IntFieldUpdateOperationsInput | number
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exames?: PedidoExameUncheckedUpdateManyWithoutPedidoNestedInput
    contas?: ContaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type ProfissionalUpsertWithoutLaudosAssinadosInput = {
    update: XOR<ProfissionalUpdateWithoutLaudosAssinadosInput, ProfissionalUncheckedUpdateWithoutLaudosAssinadosInput>
    create: XOR<ProfissionalCreateWithoutLaudosAssinadosInput, ProfissionalUncheckedCreateWithoutLaudosAssinadosInput>
    where?: ProfissionalWhereInput
  }

  export type ProfissionalUpdateToOneWithWhereWithoutLaudosAssinadosInput = {
    where?: ProfissionalWhereInput
    data: XOR<ProfissionalUpdateWithoutLaudosAssinadosInput, ProfissionalUncheckedUpdateWithoutLaudosAssinadosInput>
  }

  export type ProfissionalUpdateWithoutLaudosAssinadosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conselho?: ConselhoUpdateOneWithoutProfissionaisNestedInput
    pedidosSolicitados?: PedidoUpdateManyWithoutProfissionalNestedInput
    clientesResponsavel?: ClienteUpdateManyWithoutVeterinarioRespNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutLaudosAssinadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    conselhoId?: NullableIntFieldUpdateOperationsInput | number | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidosSolicitados?: PedidoUncheckedUpdateManyWithoutProfissionalNestedInput
    clientesResponsavel?: ClienteUncheckedUpdateManyWithoutVeterinarioRespNestedInput
  }

  export type UsuarioUpsertWithoutLaudosLiberadosInput = {
    update: XOR<UsuarioUpdateWithoutLaudosLiberadosInput, UsuarioUncheckedUpdateWithoutLaudosLiberadosInput>
    create: XOR<UsuarioCreateWithoutLaudosLiberadosInput, UsuarioUncheckedCreateWithoutLaudosLiberadosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutLaudosLiberadosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutLaudosLiberadosInput, UsuarioUncheckedUpdateWithoutLaudosLiberadosInput>
  }

  export type UsuarioUpdateWithoutLaudosLiberadosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: EnumPerfilUsuarioFieldUpdateOperationsInput | $Enums.PerfilUsuario
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidosCriados?: PedidoUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutLaudosLiberadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    perfil?: EnumPerfilUsuarioFieldUpdateOperationsInput | $Enums.PerfilUsuario
    ativo?: BoolFieldUpdateOperationsInput | boolean
    ultimoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidosCriados?: PedidoUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ContaCreateWithoutBancoInput = {
    tipo: $Enums.TipoConta
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    dataVencimento: Date | string
    dataPagamento?: Date | string | null
    status?: $Enums.StatusConta
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pedido?: PedidoCreateNestedOneWithoutContasInput
  }

  export type ContaUncheckedCreateWithoutBancoInput = {
    id?: number
    pedidoId?: number | null
    tipo: $Enums.TipoConta
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    dataVencimento: Date | string
    dataPagamento?: Date | string | null
    status?: $Enums.StatusConta
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContaCreateOrConnectWithoutBancoInput = {
    where: ContaWhereUniqueInput
    create: XOR<ContaCreateWithoutBancoInput, ContaUncheckedCreateWithoutBancoInput>
  }

  export type ContaCreateManyBancoInputEnvelope = {
    data: ContaCreateManyBancoInput | ContaCreateManyBancoInput[]
    skipDuplicates?: boolean
  }

  export type ContaUpsertWithWhereUniqueWithoutBancoInput = {
    where: ContaWhereUniqueInput
    update: XOR<ContaUpdateWithoutBancoInput, ContaUncheckedUpdateWithoutBancoInput>
    create: XOR<ContaCreateWithoutBancoInput, ContaUncheckedCreateWithoutBancoInput>
  }

  export type ContaUpdateWithWhereUniqueWithoutBancoInput = {
    where: ContaWhereUniqueInput
    data: XOR<ContaUpdateWithoutBancoInput, ContaUncheckedUpdateWithoutBancoInput>
  }

  export type ContaUpdateManyWithWhereWithoutBancoInput = {
    where: ContaScalarWhereInput
    data: XOR<ContaUpdateManyMutationInput, ContaUncheckedUpdateManyWithoutBancoInput>
  }

  export type PedidoCreateWithoutContasInput = {
    numero: string
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutPedidosInput
    animal: AnimalCreateNestedOneWithoutPedidosInput
    profissional?: ProfissionalCreateNestedOneWithoutPedidosSolicitadosInput
    usuario: UsuarioCreateNestedOneWithoutPedidosCriadosInput
    exames?: PedidoExameCreateNestedManyWithoutPedidoInput
    laudos?: LaudoCreateNestedManyWithoutPedidoInput
  }

  export type PedidoUncheckedCreateWithoutContasInput = {
    id?: number
    numero: string
    clienteId: number
    animalId: number
    profissionalId?: number | null
    usuarioId: number
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exames?: PedidoExameUncheckedCreateNestedManyWithoutPedidoInput
    laudos?: LaudoUncheckedCreateNestedManyWithoutPedidoInput
  }

  export type PedidoCreateOrConnectWithoutContasInput = {
    where: PedidoWhereUniqueInput
    create: XOR<PedidoCreateWithoutContasInput, PedidoUncheckedCreateWithoutContasInput>
  }

  export type BancoCreateWithoutContasInput = {
    codigo?: string | null
    nome: string
    agencia?: string | null
    nomeAgencia?: string | null
    conta?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BancoUncheckedCreateWithoutContasInput = {
    id?: number
    codigo?: string | null
    nome: string
    agencia?: string | null
    nomeAgencia?: string | null
    conta?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BancoCreateOrConnectWithoutContasInput = {
    where: BancoWhereUniqueInput
    create: XOR<BancoCreateWithoutContasInput, BancoUncheckedCreateWithoutContasInput>
  }

  export type PedidoUpsertWithoutContasInput = {
    update: XOR<PedidoUpdateWithoutContasInput, PedidoUncheckedUpdateWithoutContasInput>
    create: XOR<PedidoCreateWithoutContasInput, PedidoUncheckedCreateWithoutContasInput>
    where?: PedidoWhereInput
  }

  export type PedidoUpdateToOneWithWhereWithoutContasInput = {
    where?: PedidoWhereInput
    data: XOR<PedidoUpdateWithoutContasInput, PedidoUncheckedUpdateWithoutContasInput>
  }

  export type PedidoUpdateWithoutContasInput = {
    numero?: StringFieldUpdateOperationsInput | string
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutPedidosNestedInput
    animal?: AnimalUpdateOneRequiredWithoutPedidosNestedInput
    profissional?: ProfissionalUpdateOneWithoutPedidosSolicitadosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosCriadosNestedInput
    exames?: PedidoExameUpdateManyWithoutPedidoNestedInput
    laudos?: LaudoUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutContasInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    clienteId?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: IntFieldUpdateOperationsInput | number
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exames?: PedidoExameUncheckedUpdateManyWithoutPedidoNestedInput
    laudos?: LaudoUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type BancoUpsertWithoutContasInput = {
    update: XOR<BancoUpdateWithoutContasInput, BancoUncheckedUpdateWithoutContasInput>
    create: XOR<BancoCreateWithoutContasInput, BancoUncheckedCreateWithoutContasInput>
    where?: BancoWhereInput
  }

  export type BancoUpdateToOneWithWhereWithoutContasInput = {
    where?: BancoWhereInput
    data: XOR<BancoUpdateWithoutContasInput, BancoUncheckedUpdateWithoutContasInput>
  }

  export type BancoUpdateWithoutContasInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nome?: StringFieldUpdateOperationsInput | string
    agencia?: NullableStringFieldUpdateOperationsInput | string | null
    nomeAgencia?: NullableStringFieldUpdateOperationsInput | string | null
    conta?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BancoUncheckedUpdateWithoutContasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nome?: StringFieldUpdateOperationsInput | string
    agencia?: NullableStringFieldUpdateOperationsInput | string | null
    nomeAgencia?: NullableStringFieldUpdateOperationsInput | string | null
    conta?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateManyUsuarioInput = {
    id?: number
    numero: string
    clienteId: number
    animalId: number
    profissionalId?: number | null
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaudoCreateManyUsuarioInput = {
    id?: number
    pedidoId: number
    profissionalId?: number | null
    conteudo: string
    observacoes?: string | null
    dataLiberacao?: Date | string | null
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoUpdateWithoutUsuarioInput = {
    numero?: StringFieldUpdateOperationsInput | string
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutPedidosNestedInput
    animal?: AnimalUpdateOneRequiredWithoutPedidosNestedInput
    profissional?: ProfissionalUpdateOneWithoutPedidosSolicitadosNestedInput
    exames?: PedidoExameUpdateManyWithoutPedidoNestedInput
    laudos?: LaudoUpdateManyWithoutPedidoNestedInput
    contas?: ContaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    clienteId?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exames?: PedidoExameUncheckedUpdateManyWithoutPedidoNestedInput
    laudos?: LaudoUncheckedUpdateManyWithoutPedidoNestedInput
    contas?: ContaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    clienteId?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaudoUpdateWithoutUsuarioInput = {
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutLaudosNestedInput
    profissional?: ProfissionalUpdateOneWithoutLaudosAssinadosNestedInput
  }

  export type LaudoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaudoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfissionalCreateManyConselhoInput = {
    id?: number
    nome: string
    documento?: string | null
    registro?: string | null
    telefone?: string | null
    email?: string | null
    endereco?: string | null
    cidade?: string | null
    uf?: string | null
    cep?: string | null
    tipo: $Enums.TipoProfissional
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfissionalUpdateWithoutConselhoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidosSolicitados?: PedidoUpdateManyWithoutProfissionalNestedInput
    laudosAssinados?: LaudoUpdateManyWithoutProfissionalNestedInput
    clientesResponsavel?: ClienteUpdateManyWithoutVeterinarioRespNestedInput
  }

  export type ProfissionalUncheckedUpdateWithoutConselhoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidosSolicitados?: PedidoUncheckedUpdateManyWithoutProfissionalNestedInput
    laudosAssinados?: LaudoUncheckedUpdateManyWithoutProfissionalNestedInput
    clientesResponsavel?: ClienteUncheckedUpdateManyWithoutVeterinarioRespNestedInput
  }

  export type ProfissionalUncheckedUpdateManyWithoutConselhoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    documento?: NullableStringFieldUpdateOperationsInput | string | null
    registro?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoProfissionalFieldUpdateOperationsInput | $Enums.TipoProfissional
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateManyProfissionalInput = {
    id?: number
    numero: string
    clienteId: number
    animalId: number
    usuarioId: number
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaudoCreateManyProfissionalInput = {
    id?: number
    pedidoId: number
    usuarioId?: number | null
    conteudo: string
    observacoes?: string | null
    dataLiberacao?: Date | string | null
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClienteCreateManyVeterinarioRespInput = {
    id?: number
    nome: string
    endereco?: string | null
    numero?: string | null
    complemento?: string | null
    bairro?: string | null
    cep?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    fax?: string | null
    celular?: string | null
    email?: string | null
    cpfCnpj?: string | null
    contato?: string | null
    dataCadastro?: Date | string
    restricao?: string | null
    dataAtualizacao?: Date | string | null
    ativo?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoUpdateWithoutProfissionalInput = {
    numero?: StringFieldUpdateOperationsInput | string
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutPedidosNestedInput
    animal?: AnimalUpdateOneRequiredWithoutPedidosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosCriadosNestedInput
    exames?: PedidoExameUpdateManyWithoutPedidoNestedInput
    laudos?: LaudoUpdateManyWithoutPedidoNestedInput
    contas?: ContaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    clienteId?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exames?: PedidoExameUncheckedUpdateManyWithoutPedidoNestedInput
    laudos?: LaudoUncheckedUpdateManyWithoutPedidoNestedInput
    contas?: ContaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    clienteId?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaudoUpdateWithoutProfissionalInput = {
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutLaudosNestedInput
    usuario?: UsuarioUpdateOneWithoutLaudosLiberadosNestedInput
  }

  export type LaudoUncheckedUpdateWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaudoUncheckedUpdateManyWithoutProfissionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteUpdateWithoutVeterinarioRespInput = {
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contato?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    restricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataAtualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animais?: AnimalUpdateManyWithoutClienteNestedInput
    pedidos?: PedidoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutVeterinarioRespInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contato?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    restricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataAtualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animais?: AnimalUncheckedUpdateManyWithoutClienteNestedInput
    pedidos?: PedidoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateManyWithoutVeterinarioRespInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    complemento?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    fax?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cpfCnpj?: NullableStringFieldUpdateOperationsInput | string | null
    contato?: NullableStringFieldUpdateOperationsInput | string | null
    dataCadastro?: DateTimeFieldUpdateOperationsInput | Date | string
    restricao?: NullableStringFieldUpdateOperationsInput | string | null
    dataAtualizacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ativo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimalCreateManyClienteInput = {
    id?: number
    nome: string
    especieId: number
    raca?: string | null
    sexo: $Enums.SexoAnimal
    idade?: string | null
    peso?: Decimal | DecimalJsLike | number | string | null
    cor?: string | null
    observacoes?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoCreateManyClienteInput = {
    id?: number
    numero: string
    animalId: number
    profissionalId?: number | null
    usuarioId: number
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnimalUpdateWithoutClienteInput = {
    nome?: StringFieldUpdateOperationsInput | string
    raca?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoAnimalFieldUpdateOperationsInput | $Enums.SexoAnimal
    idade?: NullableStringFieldUpdateOperationsInput | string | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    especie?: EspecieUpdateOneRequiredWithoutAnimaisNestedInput
    pedidos?: PedidoUpdateManyWithoutAnimalNestedInput
  }

  export type AnimalUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    especieId?: IntFieldUpdateOperationsInput | number
    raca?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoAnimalFieldUpdateOperationsInput | $Enums.SexoAnimal
    idade?: NullableStringFieldUpdateOperationsInput | string | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUncheckedUpdateManyWithoutAnimalNestedInput
  }

  export type AnimalUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    especieId?: IntFieldUpdateOperationsInput | number
    raca?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoAnimalFieldUpdateOperationsInput | $Enums.SexoAnimal
    idade?: NullableStringFieldUpdateOperationsInput | string | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoUpdateWithoutClienteInput = {
    numero?: StringFieldUpdateOperationsInput | string
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animal?: AnimalUpdateOneRequiredWithoutPedidosNestedInput
    profissional?: ProfissionalUpdateOneWithoutPedidosSolicitadosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosCriadosNestedInput
    exames?: PedidoExameUpdateManyWithoutPedidoNestedInput
    laudos?: LaudoUpdateManyWithoutPedidoNestedInput
    contas?: ContaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    animalId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: IntFieldUpdateOperationsInput | number
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exames?: PedidoExameUncheckedUpdateManyWithoutPedidoNestedInput
    laudos?: LaudoUncheckedUpdateManyWithoutPedidoNestedInput
    contas?: ContaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    animalId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: IntFieldUpdateOperationsInput | number
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimalCreateManyEspecieInput = {
    id?: number
    nome: string
    raca?: string | null
    sexo: $Enums.SexoAnimal
    idade?: string | null
    peso?: Decimal | DecimalJsLike | number | string | null
    cor?: string | null
    clienteId: number
    observacoes?: string | null
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnimalUpdateWithoutEspecieInput = {
    nome?: StringFieldUpdateOperationsInput | string
    raca?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoAnimalFieldUpdateOperationsInput | $Enums.SexoAnimal
    idade?: NullableStringFieldUpdateOperationsInput | string | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutAnimaisNestedInput
    pedidos?: PedidoUpdateManyWithoutAnimalNestedInput
  }

  export type AnimalUncheckedUpdateWithoutEspecieInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    raca?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoAnimalFieldUpdateOperationsInput | $Enums.SexoAnimal
    idade?: NullableStringFieldUpdateOperationsInput | string | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    clienteId?: IntFieldUpdateOperationsInput | number
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidos?: PedidoUncheckedUpdateManyWithoutAnimalNestedInput
  }

  export type AnimalUncheckedUpdateManyWithoutEspecieInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    raca?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoAnimalFieldUpdateOperationsInput | $Enums.SexoAnimal
    idade?: NullableStringFieldUpdateOperationsInput | string | null
    peso?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cor?: NullableStringFieldUpdateOperationsInput | string | null
    clienteId?: IntFieldUpdateOperationsInput | number
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoCreateManyAnimalInput = {
    id?: number
    numero: string
    clienteId: number
    profissionalId?: number | null
    usuarioId: number
    dataColeta: Date | string
    observacoes?: string | null
    status?: $Enums.StatusPedido
    valorTotal?: Decimal | DecimalJsLike | number | string | null
    desconto?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoUpdateWithoutAnimalInput = {
    numero?: StringFieldUpdateOperationsInput | string
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutPedidosNestedInput
    profissional?: ProfissionalUpdateOneWithoutPedidosSolicitadosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutPedidosCriadosNestedInput
    exames?: PedidoExameUpdateManyWithoutPedidoNestedInput
    laudos?: LaudoUpdateManyWithoutPedidoNestedInput
    contas?: ContaUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateWithoutAnimalInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    clienteId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: IntFieldUpdateOperationsInput | number
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exames?: PedidoExameUncheckedUpdateManyWithoutPedidoNestedInput
    laudos?: LaudoUncheckedUpdateManyWithoutPedidoNestedInput
    contas?: ContaUncheckedUpdateManyWithoutPedidoNestedInput
  }

  export type PedidoUncheckedUpdateManyWithoutAnimalInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    clienteId?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: IntFieldUpdateOperationsInput | number
    dataColeta?: DateTimeFieldUpdateOperationsInput | Date | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusPedidoFieldUpdateOperationsInput | $Enums.StatusPedido
    valorTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    desconto?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParametroExameCreateManyExameInput = {
    id?: number
    nome: string
    unidade?: string | null
    valorReferencia?: string | null
    ordem?: number
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoExameCreateManyExameInput = {
    id?: number
    pedidoId: number
    valor?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.StatusExame
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParametroExameUpdateWithoutExameInput = {
    nome?: StringFieldUpdateOperationsInput | string
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    valorReferencia?: NullableStringFieldUpdateOperationsInput | string | null
    ordem?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultados?: ResultadoExameUpdateManyWithoutParametroNestedInput
  }

  export type ParametroExameUncheckedUpdateWithoutExameInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    valorReferencia?: NullableStringFieldUpdateOperationsInput | string | null
    ordem?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultados?: ResultadoExameUncheckedUpdateManyWithoutParametroNestedInput
  }

  export type ParametroExameUncheckedUpdateManyWithoutExameInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    unidade?: NullableStringFieldUpdateOperationsInput | string | null
    valorReferencia?: NullableStringFieldUpdateOperationsInput | string | null
    ordem?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoExameUpdateWithoutExameInput = {
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFieldUpdateOperationsInput | $Enums.StatusExame
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneRequiredWithoutExamesNestedInput
    resultados?: ResultadoExameUpdateManyWithoutPedidoExameNestedInput
  }

  export type PedidoExameUncheckedUpdateWithoutExameInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFieldUpdateOperationsInput | $Enums.StatusExame
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultados?: ResultadoExameUncheckedUpdateManyWithoutPedidoExameNestedInput
  }

  export type PedidoExameUncheckedUpdateManyWithoutExameInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: IntFieldUpdateOperationsInput | number
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFieldUpdateOperationsInput | $Enums.StatusExame
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultadoExameCreateManyParametroInput = {
    id?: number
    pedidoExameId: number
    valor?: string | null
    observacao?: string | null
    alterado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultadoExameUpdateWithoutParametroInput = {
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    alterado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidoExame?: PedidoExameUpdateOneRequiredWithoutResultadosNestedInput
  }

  export type ResultadoExameUncheckedUpdateWithoutParametroInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoExameId?: IntFieldUpdateOperationsInput | number
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    alterado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultadoExameUncheckedUpdateManyWithoutParametroInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoExameId?: IntFieldUpdateOperationsInput | number
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    alterado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoExameCreateManyPedidoInput = {
    id?: number
    exameId: number
    valor?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.StatusExame
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaudoCreateManyPedidoInput = {
    id?: number
    profissionalId?: number | null
    usuarioId?: number | null
    conteudo: string
    observacoes?: string | null
    dataLiberacao?: Date | string | null
    assinado?: boolean
    enviado?: boolean
    dataEnvio?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContaCreateManyPedidoInput = {
    id?: number
    bancoId?: number | null
    tipo: $Enums.TipoConta
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    dataVencimento: Date | string
    dataPagamento?: Date | string | null
    status?: $Enums.StatusConta
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PedidoExameUpdateWithoutPedidoInput = {
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFieldUpdateOperationsInput | $Enums.StatusExame
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exame?: ExameUpdateOneRequiredWithoutPedidoExamesNestedInput
    resultados?: ResultadoExameUpdateManyWithoutPedidoExameNestedInput
  }

  export type PedidoExameUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    exameId?: IntFieldUpdateOperationsInput | number
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFieldUpdateOperationsInput | $Enums.StatusExame
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultados?: ResultadoExameUncheckedUpdateManyWithoutPedidoExameNestedInput
  }

  export type PedidoExameUncheckedUpdateManyWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    exameId?: IntFieldUpdateOperationsInput | number
    valor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumStatusExameFieldUpdateOperationsInput | $Enums.StatusExame
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaudoUpdateWithoutPedidoInput = {
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profissional?: ProfissionalUpdateOneWithoutLaudosAssinadosNestedInput
    usuario?: UsuarioUpdateOneWithoutLaudosLiberadosNestedInput
  }

  export type LaudoUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaudoUncheckedUpdateManyWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    profissionalId?: NullableIntFieldUpdateOperationsInput | number | null
    usuarioId?: NullableIntFieldUpdateOperationsInput | number | null
    conteudo?: StringFieldUpdateOperationsInput | string
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    dataLiberacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assinado?: BoolFieldUpdateOperationsInput | boolean
    enviado?: BoolFieldUpdateOperationsInput | boolean
    dataEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContaUpdateWithoutPedidoInput = {
    tipo?: EnumTipoContaFieldUpdateOperationsInput | $Enums.TipoConta
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusContaFieldUpdateOperationsInput | $Enums.StatusConta
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    banco?: BancoUpdateOneWithoutContasNestedInput
  }

  export type ContaUncheckedUpdateWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    bancoId?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: EnumTipoContaFieldUpdateOperationsInput | $Enums.TipoConta
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusContaFieldUpdateOperationsInput | $Enums.StatusConta
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContaUncheckedUpdateManyWithoutPedidoInput = {
    id?: IntFieldUpdateOperationsInput | number
    bancoId?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: EnumTipoContaFieldUpdateOperationsInput | $Enums.TipoConta
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusContaFieldUpdateOperationsInput | $Enums.StatusConta
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultadoExameCreateManyPedidoExameInput = {
    id?: number
    parametroId: number
    valor?: string | null
    observacao?: string | null
    alterado?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultadoExameUpdateWithoutPedidoExameInput = {
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    alterado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parametro?: ParametroExameUpdateOneRequiredWithoutResultadosNestedInput
  }

  export type ResultadoExameUncheckedUpdateWithoutPedidoExameInput = {
    id?: IntFieldUpdateOperationsInput | number
    parametroId?: IntFieldUpdateOperationsInput | number
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    alterado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultadoExameUncheckedUpdateManyWithoutPedidoExameInput = {
    id?: IntFieldUpdateOperationsInput | number
    parametroId?: IntFieldUpdateOperationsInput | number
    valor?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    alterado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContaCreateManyBancoInput = {
    id?: number
    pedidoId?: number | null
    tipo: $Enums.TipoConta
    descricao: string
    valor: Decimal | DecimalJsLike | number | string
    dataVencimento: Date | string
    dataPagamento?: Date | string | null
    status?: $Enums.StatusConta
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContaUpdateWithoutBancoInput = {
    tipo?: EnumTipoContaFieldUpdateOperationsInput | $Enums.TipoConta
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusContaFieldUpdateOperationsInput | $Enums.StatusConta
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedido?: PedidoUpdateOneWithoutContasNestedInput
  }

  export type ContaUncheckedUpdateWithoutBancoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: EnumTipoContaFieldUpdateOperationsInput | $Enums.TipoConta
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusContaFieldUpdateOperationsInput | $Enums.StatusConta
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContaUncheckedUpdateManyWithoutBancoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pedidoId?: NullableIntFieldUpdateOperationsInput | number | null
    tipo?: EnumTipoContaFieldUpdateOperationsInput | $Enums.TipoConta
    descricao?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataVencimento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPagamento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusContaFieldUpdateOperationsInput | $Enums.StatusConta
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConselhoCountOutputTypeDefaultArgs instead
     */
    export type ConselhoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConselhoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfissionalCountOutputTypeDefaultArgs instead
     */
    export type ProfissionalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfissionalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteCountOutputTypeDefaultArgs instead
     */
    export type ClienteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspecieCountOutputTypeDefaultArgs instead
     */
    export type EspecieCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspecieCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnimalCountOutputTypeDefaultArgs instead
     */
    export type AnimalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnimalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExameCountOutputTypeDefaultArgs instead
     */
    export type ExameCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExameCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParametroExameCountOutputTypeDefaultArgs instead
     */
    export type ParametroExameCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParametroExameCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoCountOutputTypeDefaultArgs instead
     */
    export type PedidoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoExameCountOutputTypeDefaultArgs instead
     */
    export type PedidoExameCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoExameCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BancoCountOutputTypeDefaultArgs instead
     */
    export type BancoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BancoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpresaDefaultArgs instead
     */
    export type EmpresaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpresaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConselhoDefaultArgs instead
     */
    export type ConselhoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConselhoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfissionalDefaultArgs instead
     */
    export type ProfissionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfissionalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteDefaultArgs instead
     */
    export type ClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspecieDefaultArgs instead
     */
    export type EspecieArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspecieDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnimalDefaultArgs instead
     */
    export type AnimalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnimalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExameDefaultArgs instead
     */
    export type ExameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParametroExameDefaultArgs instead
     */
    export type ParametroExameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParametroExameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoDefaultArgs instead
     */
    export type PedidoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PedidoExameDefaultArgs instead
     */
    export type PedidoExameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PedidoExameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResultadoExameDefaultArgs instead
     */
    export type ResultadoExameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResultadoExameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LaudoDefaultArgs instead
     */
    export type LaudoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LaudoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BancoDefaultArgs instead
     */
    export type BancoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BancoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContaDefaultArgs instead
     */
    export type ContaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogSistemaDefaultArgs instead
     */
    export type LogSistemaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogSistemaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfiguracaoSistemaDefaultArgs instead
     */
    export type ConfiguracaoSistemaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfiguracaoSistemaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}